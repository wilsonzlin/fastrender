name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1
  # Minimum supported Rust version
  MSRV: "1.70"
  # perf_smoke is a lightweight offline perf signal; keep this conservative to avoid flakiness.
  PERF_SMOKE_REGRESSION_THRESHOLD: "0.10"
  # Deterministic complexity counters (DOM nodes, fragments, display items, etc) should not drift
  # far without an explicit change; keep this conservative while still catching blowups.
  PERF_SMOKE_COUNT_REGRESSION_THRESHOLD: "0.20"
  # Enforce pageset-guardrails budget_ms entries (offline perf smoke hard cap).
  PERF_SMOKE_FAIL_ON_BUDGET: "1"

jobs:
  # ===========================================================================
  # Lockfile Job - Ensure Cargo.lock is present and up to date
  # ===========================================================================
  lockfile:
    name: Lockfile
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Ensure lockfile is committed
        run: |
          test -f Cargo.lock
          git ls-files --error-unmatch Cargo.lock

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Validate lockfile with Cargo
        run: cargo metadata --locked --format-version 1 > /dev/null

  # ===========================================================================
  # Test Job - Run all tests across multiple platforms and Rust versions
  # ===========================================================================
  test:
    name: Test (${{ matrix.os }} / ${{ matrix.rust }})
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest]
        rust: [stable, beta]
        include:
          # Test on macOS with stable
          - os: macos-latest
            rust: stable
          # Test on Windows with stable
          - os: windows-latest
            rust: stable
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: ${{ matrix.rust }}

      - name: Cache cargo registry
        uses: actions/cache@v4
        with:
          path: ~/.cargo/registry
          key: ${{ runner.os }}-cargo-registry-${{ hashFiles('**/Cargo.lock') }}

      - name: Cache cargo index
        uses: actions/cache@v4
        with:
          path: ~/.cargo/git
          key: ${{ runner.os }}-cargo-index-${{ hashFiles('**/Cargo.lock') }}

      - name: Cache cargo build
        uses: actions/cache@v4
        with:
          path: target
          key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('**/Cargo.lock') }}

      - name: Run tests
        run: cargo test --all-features --verbose

      - name: Run doc tests
        run: cargo test --doc --all-features --verbose

      - name: Pageset guardrails perf smoke (release, offline fixtures)
        if: matrix.os == 'ubuntu-latest' && matrix.rust == 'stable'
        id: perf_smoke_pageset_guardrails
        run: |
          set -o pipefail
          extra_args=()
          if [ "${PERF_SMOKE_FAIL_ON_BUDGET}" = "1" ]; then
            extra_args+=(--fail-on-budget)
          fi
          # Keep CI invocation explicit (instead of delegating to `cargo xtask perf-smoke`) so we
          # can't silently drift from the perf_smoke guardrails we intend to enforce here.
          # Note: `cargo xtask perf-smoke` now exposes these flags; consider switching if we want
          # to reduce duplication between local workflows and CI.
          cargo run --release --bin perf_smoke -- \
            --suite pageset-guardrails \
            --fail-on-missing-fixtures \
            --fail-on-failure \
            --fail-on-fetch-errors \
            --isolate \
            "${extra_args[@]}" \
            --top 5 \
            --output target/perf_smoke_pageset_guardrails.json \
            | tee target/perf_smoke_pageset_guardrails.log
          test -s target/perf_smoke_pageset_guardrails.json
          python3 - <<'PY'
          import json
          from pathlib import Path
          path = Path("target/perf_smoke_pageset_guardrails.json")
          data = json.loads(path.read_text())
          assert isinstance(data.get("schema_version"), int), "perf_smoke output missing schema_version"
          assert isinstance(data.get("fixtures"), list), "perf_smoke output missing fixtures list"
          PY

      - name: Download perf_smoke pageset-guardrails baseline (main)
        if: matrix.os == 'ubuntu-latest' && matrix.rust == 'stable' && steps.perf_smoke_pageset_guardrails.outcome == 'success'
        id: download_perf_smoke_pageset_guardrails_baseline
        uses: dawidd6/action-download-artifact@v3
        continue-on-error: true
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          workflow: ci.yml
          workflow_conclusion: success
          branch: main
          name: perf_smoke_pageset_guardrails
          path: baseline

      - name: Locate perf_smoke pageset-guardrails baseline JSON
        if: matrix.os == 'ubuntu-latest' && matrix.rust == 'stable' && steps.perf_smoke_pageset_guardrails.outcome == 'success' && steps.download_perf_smoke_pageset_guardrails_baseline.outcome == 'success'
        run: |
          set -e
          if [ -f baseline/target/perf_smoke_pageset_guardrails.json ]; then
            echo "PERF_SMOKE_PAGESET_GUARDRAILS_BASELINE=baseline/target/perf_smoke_pageset_guardrails.json" >> "$GITHUB_ENV"
            exit 0
          fi
          match=$(find baseline -type f -name "perf_smoke_pageset_guardrails.json" | head -n 1 || true)
          if [ -z "$match" ]; then
            echo "Downloaded baseline artifact did not contain perf_smoke_pageset_guardrails.json" >&2
            exit 1
          fi
          echo "PERF_SMOKE_PAGESET_GUARDRAILS_BASELINE=$match" >> "$GITHUB_ENV"
          echo "Using perf_smoke baseline at $match"

      - name: Perf regression check (perf_smoke pageset-guardrails)
        if: matrix.os == 'ubuntu-latest' && matrix.rust == 'stable' && steps.perf_smoke_pageset_guardrails.outcome == 'success' && steps.download_perf_smoke_pageset_guardrails_baseline.outcome == 'success'
        run: |
          # To reproduce locally:
          #   cargo run --release --bin perf_smoke -- \
          #     --suite pageset-guardrails \
          #     --fail-on-missing-fixtures \
          #     --fail-on-failure \
          #     --fail-on-fetch-errors \
          #     --isolate \
          #     --baseline <path> \
          #     --fail-on-regression \
          #     --threshold 0.10 \
          #     --count-threshold 0.20 \
          #     # Optional once budgets are calibrated:
          #     # --fail-on-budget
          report_path=target/perf_smoke_pageset_guardrails_regression_report.txt
          status=0
          extra_args=()
          if [ "${PERF_SMOKE_FAIL_ON_BUDGET}" = "1" ]; then
            extra_args+=(--fail-on-budget)
          fi

          # Use the already-built binary to keep the report free of cargo build noise.
          target/release/perf_smoke \
            --suite pageset-guardrails \
            --fail-on-missing-fixtures \
            --fail-on-failure \
            --fail-on-fetch-errors \
            --isolate \
            --top 5 \
            --output target/perf_smoke_pageset_guardrails.json \
            --baseline "${PERF_SMOKE_PAGESET_GUARDRAILS_BASELINE}" \
            --fail-on-regression \
            "${extra_args[@]}" \
            --threshold "${PERF_SMOKE_REGRESSION_THRESHOLD}" \
            --count-threshold "${PERF_SMOKE_COUNT_REGRESSION_THRESHOLD}" \
            > /dev/null 2> "${report_path}" || status=$?

          cat "${report_path}" >&2

          {
            echo "## perf_smoke pageset-guardrails regression check"
            echo
            echo "Baseline: ${PERF_SMOKE_PAGESET_GUARDRAILS_BASELINE}"
            echo "Threshold: ${PERF_SMOKE_REGRESSION_THRESHOLD} (relative)"
            echo "Count threshold: ${PERF_SMOKE_COUNT_REGRESSION_THRESHOLD} (relative)"
            if [ "${PERF_SMOKE_FAIL_ON_BUDGET}" = "1" ]; then
              echo "Budget gate: enabled"
            else
              echo "Budget gate: disabled (set PERF_SMOKE_FAIL_ON_BUDGET=1 to enable)"
            fi
            echo

            result="no regressions detected"
            if grep -q "Regressions detected vs baseline" "${report_path}"; then
              result="regressions detected"
            fi
            if grep -q "Budget failures" "${report_path}"; then
              if [ "$result" = "no regressions detected" ]; then
                result="budget failures detected"
              else
                result="${result}; budget failures detected"
              fi
            fi
            if grep -q "Fixture failures" "${report_path}"; then
              if [ "$result" = "no regressions detected" ]; then
                result="fixture failures detected"
              else
                result="${result}; fixture failures detected"
              fi
            fi
            if grep -q "Missing pageset-guardrails fixtures" "${report_path}"; then
              result="missing pageset-guardrails fixtures"
            fi
            if grep -q "baseline schema_version" "${report_path}"; then
              result="baseline incompatible (schema mismatch); skipping regression gate"
            fi

            echo "**Result: ${result}**"
            echo
            echo '```'
            cat "${report_path}"
            echo '```'
          } >> "$GITHUB_STEP_SUMMARY"

          # If the baseline is from an older perf_smoke schema, skip gating and let this run
          # upload a new baseline artifact.
          if grep -q "baseline schema_version" "${report_path}"; then
            exit 0
          fi

          exit $status

      - name: Baseline unavailable
        if: matrix.os == 'ubuntu-latest' && matrix.rust == 'stable' && steps.perf_smoke_pageset_guardrails.outcome == 'success' && steps.download_perf_smoke_pageset_guardrails_baseline.outcome != 'success'
        run: |
          echo "Previous perf_smoke pageset-guardrails artifact not found; skipping regression gate."
          {
            echo "## perf_smoke pageset-guardrails regression check"
            echo
            echo "No prior baseline artifact was available from main."
            echo "Threshold: ${PERF_SMOKE_REGRESSION_THRESHOLD} (relative)"
            echo "Count threshold: ${PERF_SMOKE_COUNT_REGRESSION_THRESHOLD} (relative)"
            if [ "${PERF_SMOKE_FAIL_ON_BUDGET}" = "1" ]; then
              echo "Budget gate: enabled"
            else
              echo "Budget gate: disabled (set PERF_SMOKE_FAIL_ON_BUDGET=1 to enable)"
            fi
            echo
            echo "The uploaded perf_smoke output from this run will serve as the next baseline."
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Upload perf_smoke pageset-guardrails output
        if: always() && matrix.os == 'ubuntu-latest' && matrix.rust == 'stable' && steps.perf_smoke_pageset_guardrails.outcome == 'success'
        uses: actions/upload-artifact@v4
        with:
          name: perf_smoke_pageset_guardrails
          path: target/perf_smoke_pageset_guardrails.json
          if-no-files-found: error

  # ===========================================================================
  # MSRV Job - Verify minimum supported Rust version
  # ===========================================================================
  msrv:
    name: MSRV (${{ env.MSRV }})
    runs-on: ubuntu-latest
    env:
      MSRV: "1.70"
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install MSRV toolchain
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: ${{ env.MSRV }}

      - name: Cache cargo registry
        uses: actions/cache@v4
        with:
          path: ~/.cargo/registry
          key: ${{ runner.os }}-msrv-cargo-registry-${{ hashFiles('**/Cargo.lock') }}

      - name: Cache cargo build
        uses: actions/cache@v4
        with:
          path: target
          key: ${{ runner.os }}-msrv-cargo-build-${{ hashFiles('**/Cargo.lock') }}

      - name: Build with MSRV
        run: cargo build --all-features

      - name: Run tests with MSRV
        run: cargo test --all-features

  # ===========================================================================
  # Clippy Job - Linting
  # ===========================================================================
  clippy:
    name: Clippy
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          components: clippy

      - name: Cache cargo registry
        uses: actions/cache@v4
        with:
          path: ~/.cargo/registry
          key: ${{ runner.os }}-cargo-registry-${{ hashFiles('**/Cargo.lock') }}

      - name: Cache cargo index
        uses: actions/cache@v4
        with:
          path: ~/.cargo/git
          key: ${{ runner.os }}-cargo-index-${{ hashFiles('**/Cargo.lock') }}

      - name: Cache cargo build
        uses: actions/cache@v4
        with:
          path: target
          key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('**/Cargo.lock') }}

      - name: Run clippy
        run: cargo clippy --all-targets --all-features -- -D warnings

  # ===========================================================================
  # Format Job - Check code formatting
  # ===========================================================================
  format:
    name: Format
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt

      - name: Check formatting
        run: cargo fmt --all -- --check

  # ===========================================================================
  # Docs Job - Check documentation builds
  # ===========================================================================
  docs:
    name: Documentation
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Cache cargo registry
        uses: actions/cache@v4
        with:
          path: ~/.cargo/registry
          key: ${{ runner.os }}-cargo-registry-${{ hashFiles('**/Cargo.lock') }}

      - name: Cache cargo index
        uses: actions/cache@v4
        with:
          path: ~/.cargo/git
          key: ${{ runner.os }}-cargo-index-${{ hashFiles('**/Cargo.lock') }}

      - name: Cache cargo build
        uses: actions/cache@v4
        with:
          path: target
          key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('**/Cargo.lock') }}

      - name: Build documentation
        run: cargo doc --no-deps --all-features
        env:
          RUSTDOCFLAGS: -D warnings

  # ===========================================================================
  # Dependency Audit Job - Check for security vulnerabilities
  # ===========================================================================
  audit:
    name: Security Audit
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Install cargo-audit
        run: cargo install cargo-audit

      - name: Run security audit
        run: cargo audit

  # ===========================================================================
  # Fuzz Smoke Job - Quick libFuzzer sanity runs
  # ===========================================================================
  fuzz-smoke:
    name: Fuzz Smoke
    runs-on: ubuntu-latest
    timeout-minutes: 25
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install nightly toolchain for fuzzing
        uses: dtolnay/rust-toolchain@nightly
        with:
          components: llvm-tools-preview

      - name: Capture nightly toolchain info
        id: nightly_toolchain
        run: |
          set -euo pipefail
          rustc_version="$(rustc -V)"
          rustc_hash="$(rustc -Vv | awk '/^commit-hash:/ {print $2}')"
          echo "rustc_version=${rustc_version}" >> "$GITHUB_OUTPUT"
          echo "rustc_hash=${rustc_hash}" >> "$GITHUB_OUTPUT"

      - name: Cache cargo registry (fuzz-smoke)
        uses: actions/cache@v4
        with:
          path: ~/.cargo/registry
          key: ${{ runner.os }}-fuzz-cargo-registry-${{ hashFiles('Cargo.lock', 'fuzz/Cargo.toml') }}

      - name: Cache cargo git (fuzz-smoke)
        uses: actions/cache@v4
        with:
          path: ~/.cargo/git
          key: ${{ runner.os }}-fuzz-cargo-git-${{ hashFiles('Cargo.lock', 'fuzz/Cargo.toml') }}

      - name: Cache fuzz target dir
        uses: actions/cache@v4
        with:
          path: fuzz/target
          key: ${{ runner.os }}-fuzz-target-${{ steps.nightly_toolchain.outputs.rustc_hash }}-${{ hashFiles('Cargo.lock', 'fuzz/Cargo.toml') }}

      - name: Install cargo-fuzz
        uses: taiki-e/install-action@cargo-fuzz

      - name: Run fuzz smoke tests
        working-directory: fuzz
        run: |
          set -euo pipefail
          export ASAN_OPTIONS=detect_leaks=0
          cargo fuzz run css_parser ../tests/fuzz_corpus -- -max_total_time=5 -runs=256
          cargo fuzz run selectors ../tests/fuzz_corpus -- -max_total_time=5 -runs=128
          cargo fuzz run vars_and_calc ../tests/fuzz_corpus -- -max_total_time=5 -runs=128
          cargo fuzz run svg_filters ../tests/fuzz_corpus -- -max_total_time=5 -runs=128
          cargo fuzz run animation_properties ../tests/fuzz_corpus -- -max_total_time=5 -runs=128
          mkdir -p /tmp/fuzz_color_fonts_corpus
          cp ../tests/fixtures/fonts/FastRenderEmoji.ttf /tmp/fuzz_color_fonts_corpus/
          cp ../tests/fixtures/fonts/TestSbixJPEG.ttf /tmp/fuzz_color_fonts_corpus/
          cp ../tests/fixtures/fonts/PaletteTestCOLRv1.ttf /tmp/fuzz_color_fonts_corpus/
          cp ../tests/fixtures/fonts/colrv1-test.ttf /tmp/fuzz_color_fonts_corpus/
          cargo fuzz run color_fonts /tmp/fuzz_color_fonts_corpus -- -max_total_time=5 -runs=64 -timeout=5 -rss_limit_mb=4096

      - name: Upload fuzz artifacts (on failure)
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: fuzz_smoke_artifacts
          path: fuzz/artifacts
          if-no-files-found: ignore

      - name: Fuzz smoke step summary
        if: always()
        run: |
          {
            echo "## Fuzz smoke"
            echo
            echo "- Rust (nightly): ${{ steps.nightly_toolchain.outputs.rustc_version }}"
            echo "- Rust commit hash: ${{ steps.nightly_toolchain.outputs.rustc_hash }}"
            echo "- cargo-fuzz: $(cargo fuzz --version 2>/dev/null || echo 'unavailable')"
            echo
            echo "Targets:"
            echo "- css_parser: -max_total_time=5 -runs=256"
            echo "- selectors: -max_total_time=5 -runs=128"
            echo "- vars_and_calc: -max_total_time=5 -runs=128"
            echo "- svg_filters: -max_total_time=5 -runs=128"
            echo "- animation_properties: -max_total_time=5 -runs=128"
            echo "- color_fonts: -max_total_time=5 -runs=64 -timeout=5 -rss_limit_mb=4096"
            echo
            if [ -d fuzz/artifacts ]; then
              echo "Artifacts directory (fuzz/artifacts) exists; contents:"
              echo
              echo '```'
              find fuzz/artifacts -maxdepth 2 -type f -print | head -n 50 || true
              echo '```'
            else
              echo "No fuzz artifacts directory was created."
            fi
          } >> "$GITHUB_STEP_SUMMARY"

  # ===========================================================================
  # Coverage Job - Measure test coverage
  # ===========================================================================
  coverage:
    name: Coverage
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Cache cargo registry
        uses: actions/cache@v4
        with:
          path: ~/.cargo/registry
          key: ${{ runner.os }}-coverage-cargo-registry-${{ hashFiles('**/Cargo.lock') }}

      - name: Cache cargo build
        uses: actions/cache@v4
        with:
          path: target
          key: ${{ runner.os }}-coverage-cargo-build-${{ hashFiles('**/Cargo.lock') }}

      - name: Install cargo-llvm-cov
        uses: taiki-e/install-action@cargo-llvm-cov

      - name: Generate coverage
        run: cargo llvm-cov --all-features --lcov --output-path lcov.info

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v4
        with:
          files: lcov.info
          fail_ci_if_error: false
        env:
          CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}

  # ===========================================================================
  # Benchmark Job - Run performance benchmarks (on main branch only)
  # ===========================================================================
  benchmark:
    name: Benchmark
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.event_name == 'pull_request'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Cache cargo registry
        uses: actions/cache@v4
        with:
          path: ~/.cargo/registry
          key: ${{ runner.os }}-bench-cargo-registry-${{ hashFiles('**/Cargo.lock') }}

      - name: Cache cargo build
        uses: actions/cache@v4
        with:
          path: target
          key: ${{ runner.os }}-bench-cargo-build-${{ hashFiles('**/Cargo.lock') }}

      - name: Run benchmarks
        run: cargo bench --no-run

      - name: Run benchmarks and save baseline
        run: cargo bench -- --noplot --save-baseline main 2>&1 | tee benchmark-results.txt
        continue-on-error: true

      - name: Upload benchmark results
        uses: actions/upload-artifact@v4
        with:
          name: benchmark-results
          path: |
            benchmark-results.txt
            target/criterion

  # ===========================================================================
  # CI Status - Final check that all jobs passed
  # ===========================================================================
  ci-status:
    name: CI Status
    runs-on: ubuntu-latest
    needs: [lockfile, test, msrv, clippy, format, docs, audit, fuzz-smoke]
    if: always()
    steps:
      - name: Check CI Status
        run: |
          if [ "${{ needs.test.result }}" != "success" ] || \
             [ "${{ needs.lockfile.result }}" != "success" ] || \
             [ "${{ needs.msrv.result }}" != "success" ] || \
             [ "${{ needs.clippy.result }}" != "success" ] || \
             [ "${{ needs.format.result }}" != "success" ] || \
             [ "${{ needs.docs.result }}" != "success" ] || \
             [ "${{ needs.audit.result }}" != "success" ] || \
             [ "${{ needs.fuzz-smoke.result }}" != "success" ]; then
            echo "One or more CI jobs failed"
            exit 1
          fi
          echo "All CI jobs passed!"
