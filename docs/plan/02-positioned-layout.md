# Phase 2: Positioned Layout

**Duration:** Week 6-7 of Phase 2 (7-10 days)
**Prerequisites:**
- Phase 1 complete (type system, formatting contexts, box generation)
- Block layout complete
- Inline layout complete
**Dependencies:**
- FormattingContext trait
- BoxNode, FragmentNode types
- Stacking context implementation
**Output:** CSS positioning (relative, absolute, fixed, sticky) implementation

## Objectives

Implement CSS positioned layout - the positioning schemes that remove boxes from normal flow or adjust their position. This includes:
- **Relative positioning** - Offset from normal position
- **Absolute positioning** - Positioned relative to containing block
- **Fixed positioning** - Positioned relative to viewport
- **Sticky positioning** - Hybrid of relative and fixed

**Key Insight:** Positioned layout is not a formatting context, but a post-process that happens after normal layout.

## Context

CSS defines several positioning schemes that affect how boxes are positioned.

**From CSS 2.1 Section 9.3:**
> "Once boxes have been generated, the CSS visual formatting model lays out boxes according to their containing block. The position and size of an element's box(es) are sometimes calculated relative to a certain rectangle, called the containing block of the element."

**Positioning values:**
- `position: static` - Normal flow (default)
- `position: relative` - Offset from normal position
- `position: absolute` - Removed from flow, positioned relative to containing block
- `position: fixed` - Positioned relative to viewport
- `position: sticky` - Conditional relative/fixed hybrid

## The Problem V1 Has

V1 uses Taffy, which has limited support for absolute positioning and no support for:
- Proper containing block determination
- Z-index and stacking contexts
- Fixed positioning
- Sticky positioning

## The Solution

Implement positioned layout as a **two-pass process**:
1. **Layout pass** - Normal layout (static/relative)
2. **Positioning pass** - Apply absolute/fixed positioning

## CSS Specification References

**Primary:**
- **CSS 2.1 Section 9.3:** Positioning schemes
- **CSS 2.1 Section 10.3.7:** Absolutely positioned, non-replaced elements
- **CSS 2.1 Section 10.6.4:** Absolutely positioned, non-replaced elements (height)
- **CSS Position Module Level 3:** Sticky positioning

**Key Concepts:**
- **Containing block** - The box relative to which positioning is calculated
- **Stacking context** - Z-ordering of overlapping elements
- **Initial containing block** - The viewport
- **Offset properties** - top, right, bottom, left

## Step-by-Step Implementation

### Step 1: Containing Block Determination (Day 1)

The containing block is critical for absolute positioning.

**File: `src/layout/containing_block.rs`**

```rust
//! Containing block determination
//!
//! CSS 2.1 Section 10.1: Definition of "containing block"

use crate::tree::{BoxNode, FragmentNode};
use crate::style::{Position, Display};
use crate::geometry::Rect;

/// Determines the containing block for a positioned element
///
/// CSS 2.1 Section 10.1:
/// 1. For root element: initial containing block (viewport)
/// 2. For position: static or relative: content box of nearest block container ancestor
/// 3. For position: absolute:
///    - If ancestor is inline: generated by padding box of first and last inline boxes
///    - Otherwise: padding box of nearest positioned ancestor
/// 4. For position: fixed: initial containing block (viewport)
pub fn get_containing_block(
    box_node: &BoxNode,
    fragment_tree: &FragmentNode,
    viewport_size: Size,
) -> Rect {
    let position = box_node.style.position;

    match position {
        Position::Static | Position::Relative => {
            // Containing block is the content box of the nearest block container ancestor
            find_block_container_ancestor(box_node, fragment_tree)
                .map(|f| f.content_box())
                .unwrap_or_else(|| {
                    // No ancestor - use viewport
                    Rect::new(Point::zero(), viewport_size)
                })
        }
        Position::Absolute => {
            // Containing block is the padding box of the nearest positioned ancestor
            find_positioned_ancestor(box_node, fragment_tree)
                .map(|f| f.padding_box())
                .unwrap_or_else(|| {
                    // No positioned ancestor - use viewport (initial containing block)
                    Rect::new(Point::zero(), viewport_size)
                })
        }
        Position::Fixed => {
            // Containing block is always the viewport (initial containing block)
            Rect::new(Point::zero(), viewport_size)
        }
        Position::Sticky => {
            // Sticky uses the same containing block as static/relative
            find_block_container_ancestor(box_node, fragment_tree)
                .map(|f| f.content_box())
                .unwrap_or_else(|| {
                    Rect::new(Point::zero(), viewport_size)
                })
        }
    }
}

/// Finds the nearest block container ancestor
fn find_block_container_ancestor(
    box_node: &BoxNode,
    fragment_tree: &FragmentNode,
) -> Option<FragmentNode> {
    // Walk up the tree looking for a block container
    let mut current = box_node.parent()?;

    loop {
        if is_block_container(&current.style.display) {
            // Find corresponding fragment
            return find_fragment_for_box(current.id(), fragment_tree);
        }

        current = current.parent()?;
    }
}

/// Finds the nearest positioned ancestor
///
/// A positioned box is one with position != static
fn find_positioned_ancestor(
    box_node: &BoxNode,
    fragment_tree: &FragmentNode,
) -> Option<FragmentNode> {
    let mut current = box_node.parent()?;

    loop {
        if current.style.position != Position::Static {
            // This is a positioned ancestor
            return find_fragment_for_box(current.id(), fragment_tree);
        }

        current = current.parent()?;
    }
}

/// Checks if a display value creates a block container
fn is_block_container(display: &Display) -> bool {
    matches!(display, Display::Block | Display::ListItem | Display::InlineBlock)
}

/// Finds the fragment corresponding to a box node ID
fn find_fragment_for_box(
    box_id: BoxNodeId,
    fragment_tree: &FragmentNode,
) -> Option<FragmentNode> {
    // TODO: Implement efficient box->fragment lookup
    // For now, linear search
    if fragment_tree.box_id() == box_id {
        return Some(fragment_tree.clone());
    }

    for child in fragment_tree.children() {
        if let Some(found) = find_fragment_for_box(box_id, child) {
            return Some(found);
        }
    }

    None
}
```

### Step 2: Relative Positioning (Day 2)

Relative positioning is the simplest - just offset from normal position.

**File: `src/layout/positioning/relative.rs`**

```rust
//! Relative positioning
//!
//! CSS 2.1 Section 9.3.2: Relative positioning

use crate::tree::FragmentNode;
use crate::geometry::{Point, Rect};
use crate::style::ComputedStyle;
use crate::error::Result;

/// Applies relative positioning to a fragment
///
/// Relative positioning:
/// 1. Box is laid out in normal flow
/// 2. Then offset by top/right/bottom/left properties
/// 3. Original space is preserved (no reflow)
pub fn apply_relative_position(
    fragment: &mut FragmentNode,
    style: &ComputedStyle,
) -> Result<()> {
    // Compute offset from top/right/bottom/left properties
    let offset = compute_relative_offset(fragment.rect(), style);

    // Apply offset to fragment position
    let current_pos = fragment.rect().origin;
    fragment.set_position(Point::new(
        current_pos.x + offset.x,
        current_pos.y + offset.y,
    ));

    // Note: Children are NOT affected by relative positioning
    // Their positions are relative to the original (un-offset) position

    Ok(())
}

/// Computes the offset for relative positioning
///
/// CSS 2.1 Section 9.3.2:
/// - If both top and bottom are specified, top wins
/// - If both left and right are specified, left wins (for LTR)
fn compute_relative_offset(
    current_rect: &Rect,
    style: &ComputedStyle,
) -> Point {
    let mut offset_x = 0.0;
    let mut offset_y = 0.0;

    // Vertical offset (top/bottom)
    if let Some(top) = style.top {
        offset_y = resolve_offset_value(&top, current_rect.size.height);
    } else if let Some(bottom) = style.bottom {
        offset_y = -resolve_offset_value(&bottom, current_rect.size.height);
    }

    // Horizontal offset (left/right)
    if let Some(left) = style.left {
        offset_x = resolve_offset_value(&left, current_rect.size.width);
    } else if let Some(right) = style.right {
        offset_x = -resolve_offset_value(&right, current_rect.size.width);
    }

    Point::new(offset_x, offset_y)
}

/// Resolves an offset value (may be percentage)
fn resolve_offset_value(value: &LengthPercentageAuto, base: f32) -> f32 {
    match value {
        LengthPercentageAuto::Length(len) => len.to_px(),
        LengthPercentageAuto::Percentage(pct) => base * pct / 100.0,
        LengthPercentageAuto::Auto => 0.0, // Auto = 0 for relative positioning
    }
}
```

### Step 3: Absolute Positioning (Day 3-5)

Absolute positioning is more complex: the box is removed from flow and positioned using offset properties.

**File: `src/layout/positioning/absolute.rs`**

```rust
//! Absolute positioning
//!
//! CSS 2.1 Section 10.3.7: Absolutely positioned, non-replaced elements

use crate::tree::{BoxNode, FragmentNode};
use crate::geometry::{Point, Size, Rect};
use crate::style::ComputedStyle;
use crate::layout::containing_block::get_containing_block;
use crate::text::FontContext;
use crate::error::Result;

/// Lays out an absolutely positioned box
///
/// Process:
/// 1. Determine containing block
/// 2. Compute position and size using offset properties
/// 3. Layout contents
/// 4. Create positioned fragment
pub fn layout_absolute_box(
    box_node: &BoxNode,
    fragment_tree: &FragmentNode,
    viewport_size: Size,
    font_context: &FontContext,
) -> Result<FragmentNode> {
    let containing_block = get_containing_block(
        box_node,
        fragment_tree,
        viewport_size,
    );

    // Compute width and horizontal position
    let (x, width) = compute_absolute_horizontal(
        &box_node.style,
        &containing_block,
    )?;

    // Compute height and vertical position
    let (y, height) = compute_absolute_vertical(
        &box_node.style,
        &containing_block,
        box_node,
        font_context,
    )?;

    // Layout contents with computed size
    let constraints = LayoutConstraints {
        available_width: Some(width),
        available_height: Some(height),
        percentage_base_width: width,
        percentage_base_height: height,
    };

    let fc = FormattingContextFactory::get_for_box(box_node);
    let mut fragment = fc.layout(box_node, &constraints, font_context)?;

    // Position the fragment
    fragment.set_position(Point::new(x, y));

    Ok(fragment)
}

/// Computes horizontal position and width for absolutely positioned box
///
/// CSS 2.1 Section 10.3.7: Constraint equation:
/// left + margin-left + border-left + padding-left + width +
/// padding-right + border-right + margin-right + right = containing block width
///
/// Cases:
/// 1. All three (left, width, right) specified → compute margin-right (overconstrained)
/// 2. width and right specified → compute left
/// 3. left and right specified → compute width
/// 4. Only one offset specified → compute the other using shrink-to-fit
/// 5. Neither offset specified → use static position
fn compute_absolute_horizontal(
    style: &ComputedStyle,
    containing_block: &Rect,
) -> Result<(f32, f32)> {
    let cb_width = containing_block.size.width;

    // Get offset values (may be auto)
    let left = style.left;
    let right = style.right;
    let width = style.width;

    // Get margins (may be auto)
    let margin_left = style.margin_left;
    let margin_right = style.margin_right;

    // Padding and border (never auto)
    let padding_left = style.padding_left.to_px();
    let padding_right = style.padding_right.to_px();
    let border_left = style.border_left_width;
    let border_right = style.border_right_width;

    // Apply constraint equation based on which values are specified
    // This is complex - many cases!

    if let (Some(left_val), Some(width_val), Some(right_val)) = (left, width, right) {
        // Case 1: All three specified (overconstrained)
        // Ignore right for LTR
        let left_px = resolve_offset(left_val, cb_width);
        let width_px = resolve_length(width_val, cb_width);

        let x = containing_block.origin.x + left_px + resolve_margin(margin_left, cb_width) + border_left + padding_left;

        Ok((x, width_px))
    } else if let (Some(left_val), Some(width_val), None) = (left, width, right) {
        // Case 2: left and width specified, right is auto
        let left_px = resolve_offset(left_val, cb_width);
        let width_px = resolve_length(width_val, cb_width);

        let x = containing_block.origin.x + left_px + resolve_margin(margin_left, cb_width) + border_left + padding_left;

        Ok((x, width_px))
    } else if let (Some(left_val), None, Some(right_val)) = (left, width, right) {
        // Case 3: left and right specified, width is auto
        let left_px = resolve_offset(left_val, cb_width);
        let right_px = resolve_offset(right_val, cb_width);

        let ml = resolve_margin(margin_left, cb_width);
        let mr = resolve_margin(margin_right, cb_width);

        // Solve for width
        let width_px = cb_width - left_px - right_px - ml - mr - padding_left - padding_right - border_left - border_right;

        let x = containing_block.origin.x + left_px + ml + border_left + padding_left;

        Ok((x, width_px.max(0.0)))
    } else {
        // Case 4/5: More complex cases involving auto values
        // Use shrink-to-fit for width if needed
        // Use static position if offsets are auto

        // TODO: Implement remaining cases
        // For now, simple default
        Ok((containing_block.origin.x, 200.0))
    }
}

/// Computes vertical position and height for absolutely positioned box
///
/// Similar to horizontal, but with top/bottom/height
fn compute_absolute_vertical(
    style: &ComputedStyle,
    containing_block: &Rect,
    box_node: &BoxNode,
    font_context: &FontContext,
) -> Result<(f32, f32)> {
    let cb_height = containing_block.size.height;

    let top = style.top;
    let bottom = style.bottom;
    let height = style.height;

    // Similar constraint equation as horizontal
    // For simplicity, handle a few common cases

    if let (Some(top_val), Some(height_val)) = (top, height) {
        // Top and height specified
        let top_px = resolve_offset(top_val, cb_height);
        let height_px = resolve_length(height_val, cb_height);

        let y = containing_block.origin.y + top_px + style.margin_top.to_px() + style.border_top_width + style.padding_top.to_px();

        Ok((y, height_px))
    } else if let (Some(top_val), None, Some(bottom_val)) = (top, height, bottom) {
        // Top and bottom specified, height auto
        let top_px = resolve_offset(top_val, cb_height);
        let bottom_px = resolve_offset(bottom_val, cb_height);

        let height_px = cb_height - top_px - bottom_px
            - style.margin_top.to_px() - style.margin_bottom.to_px()
            - style.padding_top.to_px() - style.padding_bottom.to_px()
            - style.border_top_width - style.border_bottom_width;

        let y = containing_block.origin.y + top_px + style.margin_top.to_px() + style.border_top_width + style.padding_top.to_px();

        Ok((y, height_px.max(0.0)))
    } else {
        // Default case
        Ok((containing_block.origin.y, 100.0))
    }
}

fn resolve_offset(offset: LengthPercentageAuto, base: f32) -> f32 {
    match offset {
        LengthPercentageAuto::Length(len) => len.to_px(),
        LengthPercentageAuto::Percentage(pct) => base * pct / 100.0,
        LengthPercentageAuto::Auto => 0.0,
    }
}

fn resolve_length(length: Length, base: f32) -> f32 {
    match length.unit {
        LengthUnit::Px => length.value,
        LengthUnit::Percent => base * length.value / 100.0,
        _ => 0.0,
    }
}

fn resolve_margin(margin: LengthOrAuto, base: f32) -> f32 {
    match margin {
        LengthOrAuto::Length(len) => resolve_length(len, base),
        LengthOrAuto::Auto => 0.0, // For absolute positioning, auto margins are 0 unless overconstrained
    }
}
```

### Step 4: Fixed Positioning (Day 5)

Fixed positioning is like absolute, but always relative to viewport.

**File: `src/layout/positioning/fixed.rs`**

```rust
//! Fixed positioning
//!
//! CSS 2.1 Section 9.6.1: Fixed positioning

use crate::tree::{BoxNode, FragmentNode};
use crate::geometry::Size;
use crate::text::FontContext;
use crate::error::Result;

/// Lays out a fixed positioned box
///
/// Fixed positioning is like absolute, but:
/// 1. Containing block is always the viewport
/// 2. Box does not scroll with the page
pub fn layout_fixed_box(
    box_node: &BoxNode,
    viewport_size: Size,
    font_context: &FontContext,
) -> Result<FragmentNode> {
    // Create a fake containing block for the viewport
    let viewport_rect = Rect::new(Point::zero(), viewport_size);

    // Use absolute positioning logic with viewport as containing block
    // (Fixed is essentially absolute relative to viewport)

    // Reuse absolute positioning computation
    let (x, width) = super::absolute::compute_absolute_horizontal(
        &box_node.style,
        &viewport_rect,
    )?;

    let (y, height) = super::absolute::compute_absolute_vertical(
        &box_node.style,
        &viewport_rect,
        box_node,
        font_context,
    )?;

    // Layout and position
    let constraints = LayoutConstraints {
        available_width: Some(width),
        available_height: Some(height),
        percentage_base_width: width,
        percentage_base_height: height,
    };

    let fc = FormattingContextFactory::get_for_box(box_node);
    let mut fragment = fc.layout(box_node, &constraints, font_context)?;

    fragment.set_position(Point::new(x, y));

    // Mark fragment as fixed so renderer knows not to scroll it
    fragment.set_fixed(true);

    Ok(fragment)
}
```

### Step 5: Sticky Positioning (Day 6-7)

Sticky is the most complex - it's relative until a threshold, then fixed.

**File: `src/layout/positioning/sticky.rs`**

```rust
//! Sticky positioning
//!
//! CSS Position Module Level 3: Sticky positioning
//! https://www.w3.org/TR/css-position-3/#sticky-pos

use crate::tree::FragmentNode;
use crate::geometry::{Point, Rect};
use crate::style::ComputedStyle;

/// Applies sticky positioning to a fragment
///
/// Sticky positioning:
/// 1. Initially, box is positioned in normal flow (like relative)
/// 2. Once scroll position reaches threshold, box becomes fixed
/// 3. Box is constrained to containing block
///
/// Note: The actual "sticking" behavior is determined by the renderer
/// based on scroll position. Layout just computes the sticky offsets.
pub fn apply_sticky_position(
    fragment: &mut FragmentNode,
    style: &ComputedStyle,
    containing_block: &Rect,
    scroll_offset: Point,
) {
    // Compute sticky constraints from offset properties
    let top_constraint = style.top.map(|v| resolve_offset(v, containing_block.size.height));
    let bottom_constraint = style.bottom.map(|v| resolve_offset(v, containing_block.size.height));
    let left_constraint = style.left.map(|v| resolve_offset(v, containing_block.size.width));
    let right_constraint = style.right.map(|v| resolve_offset(v, containing_block.size.width));

    // Store sticky constraints on fragment for renderer
    fragment.set_sticky_constraints(StickyConstraints {
        top: top_constraint,
        bottom: bottom_constraint,
        left: left_constraint,
        right: right_constraint,
    });

    // Initial position is normal flow position (like relative with no offset)
    // Renderer will adjust based on scroll
}

#[derive(Debug, Clone)]
pub struct StickyConstraints {
    pub top: Option<f32>,
    pub bottom: Option<f32>,
    pub left: Option<f32>,
    pub right: Option<f32>,
}

fn resolve_offset(offset: LengthPercentageAuto, base: f32) -> f32 {
    match offset {
        LengthPercentageAuto::Length(len) => len.to_px(),
        LengthPercentageAuto::Percentage(pct) => base * pct / 100.0,
        LengthPercentageAuto::Auto => 0.0,
    }
}
```

### Step 6: Stacking Contexts and Z-Index (Day 8)

Positioned elements participate in stacking contexts for z-ordering.

**File: `src/layout/stacking_context.rs`**

```rust
//! Stacking contexts
//!
//! CSS 2.1 Appendix E: Painting order

use crate::tree::FragmentNode;
use crate::style::Position;

/// A stacking context groups elements for z-ordering
#[derive(Debug)]
pub struct StackingContext {
    /// Root fragment of this stacking context
    root: FragmentNode,

    /// Z-index of this stacking context (if positioned)
    z_index: i32,

    /// Child stacking contexts
    children: Vec<StackingContext>,

    /// Non-positioned children (z-index: auto)
    auto_children: Vec<FragmentNode>,
}

impl StackingContext {
    /// Creates a new stacking context from a fragment tree
    pub fn from_fragment_tree(root: FragmentNode) -> Self {
        let z_index = get_z_index(&root);

        let mut children = Vec::new();
        let mut auto_children = Vec::new();

        for child in root.children() {
            if creates_stacking_context(child) {
                // Child creates its own stacking context
                children.push(StackingContext::from_fragment_tree(child.clone()));
            } else {
                // Child participates in this stacking context
                auto_children.push(child.clone());
            }
        }

        // Sort children by z-index
        children.sort_by_key(|ctx| ctx.z_index);

        Self {
            root,
            z_index,
            children,
            auto_children,
        }
    }

    /// Returns fragments in painting order
    ///
    /// CSS 2.1 Appendix E: Painting order
    /// 1. Background and borders of root
    /// 2. Positioned descendants with negative z-index
    /// 3. Non-positioned descendants
    /// 4. Positioned descendants with z-index: auto or 0
    /// 5. Positioned descendants with positive z-index
    pub fn painting_order(&self) -> Vec<&FragmentNode> {
        let mut result = Vec::new();

        // 1. Root background/border (implicitly painted first)

        // 2. Negative z-index children
        for child_ctx in &self.children {
            if child_ctx.z_index < 0 {
                result.extend(child_ctx.painting_order());
            }
        }

        // 3. Non-positioned children
        for child in &self.auto_children {
            result.push(child);
        }

        // 4. Positioned children with z-index: auto or 0
        for child_ctx in &self.children {
            if child_ctx.z_index == 0 {
                result.extend(child_ctx.painting_order());
            }
        }

        // 5. Positive z-index children
        for child_ctx in &self.children {
            if child_ctx.z_index > 0 {
                result.extend(child_ctx.painting_order());
            }
        }

        result
    }
}

/// Determines if a fragment creates a new stacking context
///
/// A stacking context is created by:
/// 1. Root element
/// 2. Positioned element with z-index != auto
/// 3. Elements with opacity < 1
/// 4. Elements with transform
/// 5. Elements with filter
/// 6. Elements with isolation: isolate
/// 7. Flex/grid items with z-index != auto
fn creates_stacking_context(fragment: &FragmentNode) -> bool {
    let style = fragment.style();

    // Positioned with z-index
    if style.position != Position::Static && style.z_index.is_some() {
        return true;
    }

    // Opacity
    if style.opacity < 1.0 {
        return true;
    }

    // Transform
    if style.transform.is_some() {
        return true;
    }

    // TODO: Other conditions (filter, isolation, etc.)

    false
}

fn get_z_index(fragment: &FragmentNode) -> i32 {
    fragment.style().z_index.unwrap_or(0)
}
```

### Step 7: Comprehensive Tests (Day 9-10)

**File: `tests/layout/positioned_layout_test.rs`**

```rust
//! Tests for positioned layout

use fastrender::layout::positioning::*;
use fastrender::tree::BoxNode;
use fastrender::style::*;

#[test]
fn test_relative_position_basic() {
    let mut fragment = create_fragment_at(100.0, 100.0, 200.0, 150.0);

    let style = ComputedStyle {
        position: Position::Relative,
        top: Some(LengthPercentageAuto::Length(Length::px(20.0))),
        left: Some(LengthPercentageAuto::Length(Length::px(30.0))),
        ..Default::default()
    };

    relative::apply_relative_position(&mut fragment, &style).unwrap();

    // Fragment should be offset by (30, 20)
    assert_eq!(fragment.rect().origin.x, 130.0); // 100 + 30
    assert_eq!(fragment.rect().origin.y, 120.0); // 100 + 20
}

#[test]
fn test_relative_position_top_overrides_bottom() {
    let mut fragment = create_fragment_at(0.0, 0.0, 100.0, 100.0);

    let style = ComputedStyle {
        position: Position::Relative,
        top: Some(LengthPercentageAuto::Length(Length::px(10.0))),
        bottom: Some(LengthPercentageAuto::Length(Length::px(20.0))), // Should be ignored
        ..Default::default()
    };

    relative::apply_relative_position(&mut fragment, &style).unwrap();

    // Only top should be applied
    assert_eq!(fragment.rect().origin.y, 10.0);
}

#[test]
fn test_absolute_position_with_left_and_width() {
    let box_node = create_absolute_box(
        Some(LengthPercentageAuto::Length(Length::px(50.0))), // left
        None, // right
        Some(Length::px(200.0)), // width
        None, // height
    );

    let fragment_tree = create_containing_block(0.0, 0.0, 400.0, 600.0);
    let viewport_size = Size::new(800.0, 600.0);
    let font_ctx = FontContext::new();

    let fragment = absolute::layout_absolute_box(
        &box_node,
        &fragment_tree,
        viewport_size,
        &font_ctx,
    ).unwrap();

    // X should be 50 (left offset from containing block)
    assert_eq!(fragment.rect().origin.x, 50.0);
    // Width should be 200
    assert_eq!(fragment.rect().size.width, 200.0);
}

#[test]
fn test_absolute_position_with_left_and_right() {
    let box_node = create_absolute_box(
        Some(LengthPercentageAuto::Length(Length::px(50.0))), // left
        Some(LengthPercentageAuto::Length(Length::px(50.0))), // right
        None, // width (should be computed)
        None,
    );

    let fragment_tree = create_containing_block(0.0, 0.0, 400.0, 600.0);
    let viewport_size = Size::new(800.0, 600.0);
    let font_ctx = FontContext::new();

    let fragment = absolute::layout_absolute_box(
        &box_node,
        &fragment_tree,
        viewport_size,
        &font_ctx,
    ).unwrap();

    // Width should be: 400 (cb) - 50 (left) - 50 (right) = 300
    assert_eq!(fragment.rect().size.width, 300.0);
}

#[test]
fn test_fixed_position_relative_to_viewport() {
    let box_node = create_fixed_box(
        Some(LengthPercentageAuto::Length(Length::px(20.0))), // left
        Some(LengthPercentageAuto::Length(Length::px(20.0))), // top
        Some(Length::px(100.0)), // width
        Some(Length::px(100.0)), // height
    );

    let viewport_size = Size::new(800.0, 600.0);
    let font_ctx = FontContext::new();

    let fragment = fixed::layout_fixed_box(
        &box_node,
        viewport_size,
        &font_ctx,
    ).unwrap();

    // Should be positioned relative to viewport
    assert_eq!(fragment.rect().origin.x, 20.0);
    assert_eq!(fragment.rect().origin.y, 20.0);
    assert_eq!(fragment.rect().size.width, 100.0);
    assert_eq!(fragment.rect().size.height, 100.0);

    // Should be marked as fixed
    assert!(fragment.is_fixed());
}

#[test]
fn test_stacking_context_z_index_ordering() {
    // Create fragments with different z-indices
    let fragment1 = create_positioned_fragment(0.0, 0.0, 100.0, 100.0, 1);
    let fragment2 = create_positioned_fragment(0.0, 0.0, 100.0, 100.0, 3);
    let fragment3 = create_positioned_fragment(0.0, 0.0, 100.0, 100.0, 2);

    let root = create_fragment_with_children(vec![fragment1, fragment2, fragment3]);

    let stacking_ctx = StackingContext::from_fragment_tree(root);
    let painting_order = stacking_ctx.painting_order();

    // Should be ordered by z-index: 1, 2, 3
    assert_eq!(painting_order[0].style().z_index, Some(1));
    assert_eq!(painting_order[1].style().z_index, Some(2));
    assert_eq!(painting_order[2].style().z_index, Some(3));
}

#[test]
fn test_negative_z_index_paints_first() {
    let fragment1 = create_positioned_fragment(0.0, 0.0, 100.0, 100.0, -1);
    let fragment2 = create_positioned_fragment(0.0, 0.0, 100.0, 100.0, 0);
    let fragment3 = create_positioned_fragment(0.0, 0.0, 100.0, 100.0, 1);

    let root = create_fragment_with_children(vec![fragment1, fragment2, fragment3]);

    let stacking_ctx = StackingContext::from_fragment_tree(root);
    let painting_order = stacking_ctx.painting_order();

    // Negative z-index should paint first
    assert_eq!(painting_order[0].style().z_index, Some(-1));
}

// Helper functions
fn create_fragment_at(x: f32, y: f32, width: f32, height: f32) -> FragmentNode {
    FragmentNode::new(
        Rect::new(Point::new(x, y), Size::new(width, height)),
        Arc::new(ComputedStyle::default()),
        vec![],
    )
}

fn create_absolute_box(
    left: Option<LengthPercentageAuto>,
    right: Option<LengthPercentageAuto>,
    width: Option<Length>,
    height: Option<Length>,
) -> BoxNode {
    BoxNode::new_block(
        ComputedStyle {
            position: Position::Absolute,
            left,
            right,
            width,
            height,
            ..Default::default()
        },
        vec![],
    )
}

fn create_fixed_box(
    left: Option<LengthPercentageAuto>,
    top: Option<LengthPercentageAuto>,
    width: Option<Length>,
    height: Option<Length>,
) -> BoxNode {
    BoxNode::new_block(
        ComputedStyle {
            position: Position::Fixed,
            left,
            top,
            width,
            height,
            ..Default::default()
        },
        vec![],
    )
}
```

## Acceptance Criteria

- [ ] Relative positioning works
- [ ] Absolute positioning works with various offset combinations
- [ ] Fixed positioning works (relative to viewport)
- [ ] Sticky positioning records constraints (rendering to be implemented later)
- [ ] Containing block determination is correct for all position types
- [ ] Z-index and stacking contexts work
- [ ] Negative z-index paints below normal flow
- [ ] Overconstrained cases handled correctly
- [ ] All tests pass: `cargo test positioned_layout`
- [ ] Code follows 10-code-standards.md

## Common Pitfalls

### Pitfall 1: Not Removing Absolute Elements from Flow

**Wrong:**
```rust
// Including absolute element in normal flow layout
current_y += absolute_child.height;
```

**Right:**
```rust
// Absolute elements don't affect normal flow
if child.position == Absolute {
    // Handle separately, don't affect current_y
    continue;
}
```

### Pitfall 2: Wrong Containing Block

**Wrong:**
```rust
// Always using parent as containing block
containing_block = parent_box;
```

**Right:**
```rust
// Containing block depends on position type
containing_block = match position {
    Absolute => find_positioned_ancestor(),
    Fixed => viewport,
    _ => find_block_container_ancestor(),
};
```

### Pitfall 3: Not Handling Overconstrained Cases

When left, width, and right are all specified:

**Wrong:**
```rust
// Using all three values - violates constraint equation
```

**Right:**
```rust
// Ignore 'right' for LTR (CSS 2.1 Section 10.3.7)
if left.is_some() && width.is_some() && right.is_some() {
    // Ignore right
    compute_using_left_and_width();
}
```

## Edge Cases

### Auto Margins in Absolute Positioning

When left/right are specified and margins are auto:

```css
position: absolute;
left: 0;
right: 0;
width: 100px;
margin-left: auto;
margin-right: auto;
```

Auto margins should center the element.

### Percentage Heights in Absolute Positioning

```css
position: absolute;
top: 10%;
height: 50%;
```

Percentages are relative to containing block, which may have auto height.

### Sticky with Scrollable Ancestor

Sticky positioning depends on scroll containers - requires coordination with rendering.

## Performance Considerations

1. **Cache containing blocks** - Expensive to compute
2. **Batch positioned elements** - Layout all absolute elements together
3. **Optimize stacking context traversal** - Use spatial index for paint order

## Next Steps

After positioned layout:
- Integrate with all other layout modes
- Implement rendering for fixed/sticky positioning
- Add support for CSS transforms (affects stacking contexts)

## References

- **CSS 2.1 Section 9.3:** Positioning schemes
- **CSS 2.1 Section 10.3.7:** Absolute positioning
- **CSS Position Module Level 3:** https://www.w3.org/TR/css-position-3/
- **CSS 2.1 Appendix E:** Painting order and stacking contexts
- **Servo's positioned layout:** `components/layout_2020/positioned.rs`

---

**Last Updated:** 2025-01-19
**Status:** Ready for Implementation
