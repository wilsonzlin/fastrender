---
task_id: "W5.T02"
title: "Implement Display List Builder (Fragment Tree to Display List)"
wave: 5
estimated_hours: 8-10
depends_on:
  - "W5.T01"
  - "W2.T03"
inputs:
  - "outputs/notes/W5.T01-notes.md"
  - "outputs/notes/W2.T03-notes.md"
  - "src/paint/display_list.rs"
  - "src/tree/fragment.rs"
outputs:
  - "src/paint/display_list_builder.rs"
  - "outputs/notes/W5.T02-notes.md"
skills_required:
  - "Rust"
  - "Tree traversal"
  - "Graphics primitives"
context_files:
  - "docs/plan/04-display-list.md"
verification:
  - "cargo test paint::display_list_builder"
  - "Can convert fragment tree to display list"
---

# Implement Display List Builder (Fragment Tree to Display List)

## Context

The Display List is an intermediate representation between layout and painting. It converts the Fragment Tree (positioned boxes) into a flat list of paint commands (draw rect, draw text, draw image).

**Pipeline:**
```
Fragment Tree → Display List Builder → Display List → Rasterizer → Pixels
```

### Background

**Why Display List?**

1. **Optimization**: Can reorder, cull, deduplicate paint operations
2. **Compositing**: Can identify layers for GPU compositing
3. **Caching**: Can cache parts of display list between frames
4. **Simplicity**: Rasterizer just executes commands, no tree traversal

**Display List Commands:**

- **DrawRect**: Fill rectangle with color
- **DrawBorder**: Draw border around rectangle
- **DrawText**: Draw shaped text at position
- **DrawImage**: Draw image into rectangle
- **PushClip**: Clip subsequent commands
- **PopClip**: End clipping region

**Algorithm:**
```
function build_display_list(fragment):
    for each fragment in tree (depth-first):
        1. Draw background (if any)
        2. Draw borders (if any)
        3. Draw content:
           - If text: DrawText command
           - If image: DrawImage command
           - If children: recurse
        4. Append to display list
```

### Why This Matters

Display list builder is consumed by:
- **W5.T07**: Rasterizer (executes display list)
- **W6.T02**: Rendering pipeline (converts layout result to pixels)

This bridges layout and paint phases.

## Prerequisites

### Required Knowledge
- **Tree traversal**: Depth-first traversal
- **Graphics commands**: Rectangles, text, images
- **CSS painting order**: Background → borders → content

### Required Reading
1. **outputs/notes/W5.T01-notes.md**: DisplayList types
2. **outputs/notes/W2.T03-notes.md**: Fragment tree structure
3. **docs/plan/04-display-list.md**: Display list design

## Objectives

### Primary Goals

1. **Implement DisplayListBuilder**: Converts Fragment → DisplayList
2. **Fragment traversal**: Visit all fragments in paint order
3. **Background painting**: Emit DrawRect for backgrounds
4. **Border painting**: Emit DrawBorder commands
5. **Text painting**: Emit DrawText for text fragments
6. **Image painting**: Emit DrawImage for replaced elements
7. **Clipping**: Handle overflow: hidden
8. **Comprehensive tests**: Verify correct command generation

### Success Criteria

- [ ] DisplayListBuilder converts fragments to display list
- [ ] Backgrounds painted correctly
- [ ] Borders painted correctly
- [ ] Text fragments converted to DrawText
- [ ] Images converted to DrawImage
- [ ] Clipping regions work
- [ ] Commands in correct paint order
- [ ] Tests verify all command types
- [ ] Can generate display list for real page

## Implementation Guide

### Step 1: Create Display List Builder (Estimated: 3-4 hours)

**`src/paint/display_list_builder.rs`:**
```rust
//! Display list builder - converts fragment tree to display list

use crate::tree::Fragment;
use crate::paint::{DisplayList, DisplayItem, DrawRect, DrawBorder, DrawText, DrawImage};
use crate::geometry::{Rect, Point};
use crate::style::ComputedStyle;

pub struct DisplayListBuilder {
    items: Vec<DisplayItem>,
}

impl DisplayListBuilder {
    pub fn new() -> Self {
        Self {
            items: Vec::new(),
        }
    }
    
    /// Builds a display list from a fragment tree
    pub fn build(mut self, root: &Fragment) -> DisplayList {
        self.build_fragment(root);
        DisplayList::new(self.items)
    }
    
    fn build_fragment(&mut self, fragment: &Fragment) {
        // 1. Draw background
        self.draw_background(fragment);
        
        // 2. Draw borders
        self.draw_borders(fragment);
        
        // 3. Draw content
        self.draw_content(fragment);
        
        // 4. Recurse to children
        for child in &fragment.children {
            self.build_fragment(child);
        }
    }
    
    fn draw_background(&mut self, fragment: &Fragment) {
        let bg_color = fragment.style.background_color();
        
        if bg_color.is_transparent() {
            return;
        }
        
        self.items.push(DisplayItem::DrawRect(DrawRect {
            rect: fragment.bounds,
            color: bg_color,
        }));
    }
    
    fn draw_borders(&mut self, fragment: &Fragment) {
        let border = fragment.style.border();
        
        if border.is_empty() {
            return;
        }
        
        self.items.push(DisplayItem::DrawBorder(DrawBorder {
            rect: fragment.bounds,
            top: border.top,
            right: border.right,
            bottom: border.bottom,
            left: border.left,
        }));
    }
    
    fn draw_content(&mut self, fragment: &Fragment) {
        match &fragment.content {
            FragmentContent::Text { shaped, range } => {
                self.items.push(DisplayItem::DrawText(DrawText {
                    position: fragment.bounds.origin,
                    shaped_text: shaped.clone(),
                    range: *range,
                    color: fragment.style.color(),
                }));
            }
            
            FragmentContent::Replaced { replaced_type } => {
                match replaced_type {
                    ReplacedContentType::Image { src } => {
                        self.items.push(DisplayItem::DrawImage(DrawImage {
                            rect: fragment.bounds,
                            src: src.clone(),
                        }));
                    }
                    _ => {
                        // Other replaced types (video, canvas, etc.)
                        // TODO: implement in future
                    }
                }
            }
            
            _ => {
                // Block, inline, anonymous - no direct content
                // Children will be painted in recursion
            }
        }
    }
}

impl Default for DisplayListBuilder {
    fn default() -> Self {
        Self::new()
    }
}
```

### Step 2: Add Clipping Support (Estimated: 2 hours)

```rust
impl DisplayListBuilder {
    fn build_fragment_with_clip(&mut self, fragment: &Fragment) {
        // Check if this fragment clips children
        let should_clip = fragment.style.overflow() == Overflow::Hidden;
        
        if should_clip {
            self.items.push(DisplayItem::PushClip {
                rect: fragment.bounds,
            });
        }
        
        // Draw fragment
        self.draw_background(fragment);
        self.draw_borders(fragment);
        self.draw_content(fragment);
        
        // Recurse to children
        for child in &fragment.children {
            self.build_fragment_with_clip(child);
        }
        
        if should_clip {
            self.items.push(DisplayItem::PopClip);
        }
    }
}
```

### Step 3: Add Stacking Context Handling (Estimated: 2-3 hours)

```rust
impl DisplayListBuilder {
    fn build_with_stacking(&mut self, fragment: &Fragment) {
        // Paint order:
        // 1. Background/borders of positioning context
        // 2. Negative z-index children
        // 3. Normal flow children
        // 4. Positive z-index children
        
        // For now, simplified: just paint in tree order
        // Full stacking context in W5.T03
        self.build_fragment(fragment);
    }
}
```

### Step 4: Write Tests (Estimated: 2 hours)

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_simple_block_with_background() {
        let fragment = create_fragment_with_background();
        
        let builder = DisplayListBuilder::new();
        let display_list = builder.build(&fragment);
        
        assert_eq!(display_list.items().len(), 1);
        assert!(matches!(
            display_list.items()[0],
            DisplayItem::DrawRect(_)
        ));
    }
    
    #[test]
    fn test_text_fragment() {
        let fragment = create_text_fragment();
        
        let builder = DisplayListBuilder::new();
        let display_list = builder.build(&fragment);
        
        assert_eq!(display_list.items().len(), 1);
        assert!(matches!(
            display_list.items()[0],
            DisplayItem::DrawText(_)
        ));
    }
    
    #[test]
    fn test_nested_fragments() {
        let root = create_nested_fragments();
        
        let builder = DisplayListBuilder::new();
        let display_list = builder.build(&root);
        
        // Should have commands for parent and children
        assert!(display_list.items().len() > 1);
    }
    
    #[test]
    fn test_clipping() {
        let fragment = create_fragment_with_clip();
        
        let builder = DisplayListBuilder::new();
        let display_list = builder.build(&fragment);
        
        // Should have PushClip and PopClip
        let has_push = display_list.items().iter()
            .any(|item| matches!(item, DisplayItem::PushClip { .. }));
        let has_pop = display_list.items().iter()
            .any(|item| matches!(item, DisplayItem::PopClip));
        
        assert!(has_push && has_pop);
    }
}
```

## Testing Requirements

Run: `cargo test paint::display_list_builder`

Tests should verify:
- Backgrounds emit DrawRect
- Borders emit DrawBorder
- Text emits DrawText
- Images emit DrawImage
- Clipping works
- Paint order correct

## Output Artifacts

### Code Files

1. **`src/paint/display_list_builder.rs`** (~400 lines)
2. **Tests**: Inline (~200 lines)

### Notes File

Create: **`outputs/notes/W5.T02-notes.md`**

Must document:
- Builder API
- Paint order
- How clipping works
- Integration with W5.T07 (rasterizer)
- Performance notes

## Common Pitfalls

### Pitfall 1: Wrong Paint Order

**Wrong:** Painting in random order
**Right:** Background → border → content → children

### Pitfall 2: Not Handling Clipping

**Wrong:** Painting everything
**Right:** Use PushClip/PopClip for overflow: hidden

### Pitfall 3: Missing Items

**Wrong:** Only painting some fragments
**Right:** Traverse entire tree, paint everything visible

## Verification Checklist

- [ ] Can build display list
- [ ] All paint commands generated
- [ ] Tests pass
- [ ] Notes complete

## Time Tracking

- **Basic builder:** 3-4hrs
- **Clipping:** 2hrs
- **Stacking context:** 2-3hrs
- **Testing:** 2hrs
- **Total:** 8-10 hours
