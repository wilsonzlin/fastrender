---
task_id: "W6.T02"
title: "Wire Complete Rendering Pipeline (HTML to Pixels)"
wave: 6
estimated_hours: 8-12
depends_on:
  - "W6.T01"
  - "W5.T08"
  - "W3.T04"
  - "W4.T12"
  - "W2.T10"
inputs:
  - "docs/tasks/notes/W6.T01-notes.md"
  - "docs/tasks/notes/W5.T08-notes.md"
  - "docs/tasks/notes/W3.T04-notes.md"
  - "docs/tasks/notes/W4.T12-notes.md"
  - "src/layout/engine.rs"
  - "src/paint/rasterize.rs"
outputs:
  - "src/renderer.rs"
  - "src/lib.rs"
  - "docs/tasks/notes/W6.T02-notes.md"
skills_required:
  - "Rust"
  - "System integration"
  - "Error handling"
context_files:
  - "docs/core/integration.md"
verification:
  - "cargo test renderer"
  - "Can render simple HTML to image"
  - "End-to-end integration works"
---

# Wire Complete Rendering Pipeline (HTML to Pixels)

## Context

This is the **final integration task** - connecting all the pieces to render HTML to pixels. This validates that the entire architecture works end-to-end.

**Complete Pipeline:**
```
HTML String
  ↓ (parse)
DOM Tree
  ↓ (style)
Styled DOM
  ↓ (box generation)
Box Tree
  ↓ (layout)
Fragment Tree
  ↓ (display list)
Display List
  ↓ (rasterize)
Pixel Buffer
  ↓ (save)
PNG Image
```

This task wires all phases together into a single `render()` function.

### Background

**What This Does:**

Takes HTML and CSS as input, produces PNG image as output.

**All Dependencies:**

- **W3.T01**: Box generation (DOM → BoxTree)
- **W2.T10**: Layout engine (BoxTree → FragmentTree)
- **W3.T04**: Block layout
- **W4.T12**: Inline layout
- **W5.T02**: Display list builder (FragmentTree → DisplayList)
- **W5.T08**: Rasterizer (DisplayList → Pixels)

**Error Handling:**

Each phase can fail. Must propagate errors gracefully.

### Why This Matters

This creates the public API of FastRender V2:

```rust
let html = "<html><body><h1>Hello</h1></body></html>";
let css = "h1 { color: blue; }";
let image = fastrender::render(html, css, 800, 600)?;
image.save("output.png")?;
```

This is what users interact with. This validates everything works.

## Prerequisites

### Required Knowledge
- **Rust**: Error handling, Result types
- **Integration patterns**: Connecting subsystems
- **All previous tasks**: Understanding of each phase

### Required Reading
1. **docs/tasks/notes/W6.T01-notes.md**: FC factory integration
2. **docs/tasks/notes/W5.T08-notes.md**: Rasterizer API
3. **docs/core/integration.md**: Integration strategy

## Objectives

### Primary Goals

1. **Implement Renderer struct**: Main entry point
2. **Wire parsing phase**: HTML/CSS → DOM
3. **Wire styling phase**: DOM → Styled DOM
4. **Wire box generation**: Styled DOM → BoxTree
5. **Wire layout phase**: BoxTree → FragmentTree
6. **Wire paint phase**: FragmentTree → DisplayList → Pixels
7. **Error handling**: Propagate errors through pipeline
8. **Public API**: Simple `render()` function
9. **Integration tests**: End-to-end tests

### Success Criteria

- [ ] Can render simple HTML to image
- [ ] Each phase connected correctly
- [ ] Error propagation works
- [ ] Public API is ergonomic
- [ ] At least 5 end-to-end tests
- [ ] Can render real HTML pages
- [ ] Documentation complete
- [ ] Examples work

## Implementation Guide

### Step 1: Create Renderer (Estimated: 3-4 hours)

**`src/renderer.rs`:**
```rust
//! Main rendering pipeline

use crate::dom::parse_html;
use crate::css::parse_css;
use crate::style::StyleEngine;
use crate::tree::{BoxTree, BoxNode};
use crate::layout::{LayoutEngine, LayoutConstraints};
use crate::paint::{DisplayListBuilder, Rasterizer};
use crate::geometry::Size;
use crate::image_output::RgbaImage;

/// Main renderer - orchestrates the rendering pipeline
pub struct Renderer {
    style_engine: StyleEngine,
    layout_engine: LayoutEngine,
}

impl Renderer {
    /// Creates a new renderer
    pub fn new() -> Self {
        Self {
            style_engine: StyleEngine::new(),
            layout_engine: LayoutEngine::new(),
        }
    }
    
    /// Renders HTML and CSS to an image
    ///
    /// # Arguments
    /// * `html` - HTML source
    /// * `css` - CSS source
    /// * `viewport_width` - Viewport width in pixels
    /// * `viewport_height` - Viewport height in pixels
    ///
    /// # Returns
    /// RGBA image buffer
    ///
    /// # Errors
    /// Returns error if any phase fails
    pub fn render(
        &mut self,
        html: &str,
        css: &str,
        viewport_width: u32,
        viewport_height: u32,
    ) -> Result<RgbaImage, RenderError> {
        // 1. Parse HTML to DOM
        let dom = parse_html(html)
            .map_err(RenderError::ParseError)?;
        
        // 2. Parse CSS
        let stylesheet = parse_css(css)
            .map_err(RenderError::CssError)?;
        
        // 3. Apply styles
        let styled_dom = self.style_engine.apply_styles(&dom, &stylesheet)
            .map_err(RenderError::StyleError)?;
        
        // 4. Generate box tree
        let box_tree = generate_box_tree(&styled_dom)
            .map_err(RenderError::BoxGenerationError)?;
        
        // 5. Layout
        let constraints = LayoutConstraints::with_definite_size(
            viewport_width as f32,
            viewport_height as f32,
        );
        
        let fragment_tree = self.layout_engine.layout(&box_tree.root, &constraints)
            .map_err(RenderError::LayoutError)?;
        
        // 6. Build display list
        let builder = DisplayListBuilder::new();
        let display_list = builder.build(&fragment_tree);
        
        // 7. Rasterize
        let mut rasterizer = Rasterizer::new(viewport_width, viewport_height);
        rasterizer.execute(&display_list);
        
        // 8. Get image
        let image = rasterizer.into_image();
        
        Ok(image)
    }
}

impl Default for Renderer {
    fn default() -> Self {
        Self::new()
    }
}

/// Rendering errors
#[derive(Debug)]
pub enum RenderError {
    ParseError(String),
    CssError(String),
    StyleError(String),
    BoxGenerationError(String),
    LayoutError(String),
}

impl std::fmt::Display for RenderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ParseError(e) => write!(f, "Parse error: {}", e),
            Self::CssError(e) => write!(f, "CSS error: {}", e),
            Self::StyleError(e) => write!(f, "Style error: {}", e),
            Self::BoxGenerationError(e) => write!(f, "Box generation error: {}", e),
            Self::LayoutError(e) => write!(f, "Layout error: {}", e),
        }
    }
}

impl std::error::Error for RenderError {}
```

### Step 2: Public API (Estimated: 1 hour)

**`src/lib.rs`:**
```rust
//! FastRender V2 - A lightweight HTML/CSS rendering engine

pub mod geometry;
pub mod style;
pub mod tree;
pub mod layout;
pub mod paint;
pub mod text;
pub mod dom;
pub mod css;
pub mod image_output;
pub mod renderer;

pub use renderer::{Renderer, RenderError};
pub use image_output::RgbaImage;

/// Convenience function to render HTML/CSS to an image
///
/// # Examples
///
/// ```
/// let html = "<html><body><h1>Hello, World!</h1></body></html>";
/// let css = "h1 { color: blue; font-size: 24px; }";
///
/// let image = fastrender::render(html, css, 800, 600)?;
/// image.save("output.png")?;
/// ```
pub fn render(
    html: &str,
    css: &str,
    width: u32,
    height: u32,
) -> Result<RgbaImage, RenderError> {
    let mut renderer = Renderer::new();
    renderer.render(html, css, width, height)
}
```

### Step 3: Integration Tests (Estimated: 3-4 hours)

**`tests/integration_test.rs`:**
```rust
use fastrender::render;

#[test]
fn test_render_simple_html() {
    let html = "<html><body><div>Hello</div></body></html>";
    let css = "";
    
    let result = render(html, css, 800, 600);
    assert!(result.is_ok());
}

#[test]
fn test_render_with_styles() {
    let html = "<html><body><div class='box'>Styled</div></body></html>";
    let css = ".box { background-color: red; width: 100px; height: 50px; }";
    
    let result = render(html, css, 800, 600);
    assert!(result.is_ok());
}

#[test]
fn test_render_text() {
    let html = "<html><body><p>This is a paragraph of text.</p></body></html>";
    let css = "p { font-size: 16px; }";
    
    let result = render(html, css, 800, 600);
    assert!(result.is_ok());
}

#[test]
fn test_render_nested_boxes() {
    let html = r#"
        <html><body>
            <div class='outer'>
                <div class='inner'>Nested</div>
            </div>
        </body></html>
    "#;
    let css = r#"
        .outer { background-color: blue; padding: 20px; }
        .inner { background-color: green; width: 100px; height: 50px; }
    "#;
    
    let result = render(html, css, 800, 600);
    assert!(result.is_ok());
}

#[test]
fn test_render_save_image() {
    let html = "<html><body><h1>FastRender V2</h1></body></html>";
    let css = "h1 { color: blue; font-size: 48px; }";
    
    let image = render(html, css, 800, 600).unwrap();
    let save_result = image.save("/tmp/test_output.png");
    assert!(save_result.is_ok());
}
```

### Step 4: Examples (Estimated: 1-2 hours)

Create **`examples/simple.rs`:**
```rust
use fastrender::render;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let html = r#"
        <html>
            <body>
                <h1>Hello, FastRender V2!</h1>
                <p>This is a simple example.</p>
            </body>
        </html>
    "#;
    
    let css = r#"
        body { margin: 20px; background-color: #f0f0f0; }
        h1 { color: #0066cc; font-size: 36px; }
        p { font-size: 16px; color: #333; }
    "#;
    
    let image = render(html, css, 800, 600)?;
    image.save("output.png")?;
    
    println!("Rendered to output.png");
    Ok(())
}
```

## Testing Requirements

Run:
- `cargo test`
- `cargo run --example simple`

Should produce working image.

## Output Artifacts

### Code Files

1. **`src/renderer.rs`** (~300 lines)
2. **`src/lib.rs`** (updated)
3. **Integration tests** (~200 lines)
4. **Examples** (~50 lines each)

### Notes File

Create: **`docs/tasks/notes/W6.T02-notes.md`**

Must document:
- Complete pipeline
- Public API
- Error handling
- Performance notes
- Future optimizations

## Common Pitfalls

### Pitfall 1: Not Propagating Errors

**Wrong:** Panicking on errors
**Right:** Use Result and propagate with ?

### Pitfall 2: Missing Phase

**Wrong:** Skipping a phase
**Right:** All phases must run in order

### Pitfall 3: Not Testing End-to-End

**Wrong:** Only unit tests
**Right:** Integration tests that render actual HTML

## Verification Checklist

- [ ] Can render simple HTML
- [ ] Can render styled HTML
- [ ] Can render text
- [ ] Can save images
- [ ] Examples work
- [ ] Tests pass
- [ ] Documentation complete

## Time Tracking

- **Renderer implementation:** 3-4hrs
- **Public API:** 1hr
- **Integration tests:** 3-4hrs
- **Examples:** 1-2hrs
- **Total:** 8-12 hours

**This is it! The final integration that validates everything works!**
