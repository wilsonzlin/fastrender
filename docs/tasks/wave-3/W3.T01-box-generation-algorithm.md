---
task_id: "W3.T01"
title: "Implement Box Generation Algorithm"
wave: 3
estimated_hours: 8-12
depends_on:
  - "W2.T11"
  - "W1.R01"
inputs:
  - "outputs/notes/W2.T11-notes.md"
  - "outputs/notes/W1.R01-notes.md"
  - "src/tree/box_generation.rs"
  - "src/tree/box_tree.rs"
outputs:
  - "src/tree/box_generation.rs"
  - "tests/tree/test_box_generation.rs"
  - "outputs/notes/W3.T01-notes.md"
skills_required:
  - "Rust"
  - "CSS box model"
  - "Tree algorithms"
  - "CSS display types"
context_files:
  - "docs/plan/01-box-generation.md"
  - "outputs/notes/W1.R01-notes.md"
verification:
  - "cargo test tree::box_generation"
  - "cargo clippy -- -D warnings"
---

# Implement Box Generation Algorithm

## Context

The box generation algorithm is THE bridge between styled DOM and layout. It transforms a DOM tree with computed styles into a Box Tree - determining which DOM nodes generate boxes, what type of boxes they generate, and how they're structured hierarchically.

This is a **critical Wave 3 task** that enables all layout algorithms in Waves 3-4. Without box generation, we have no boxes to layout!

### Background

**Box Generation in CSS:**

From CSS 2.1 Section 9.2:
> "Box generation is the process by which an element generates one or more boxes that are laid out in the formatting context."

Key facts:
- **Not all DOM nodes generate boxes**: `display: none` generates nothing
- **Some elements generate multiple boxes**: Pseudo-elements (::before, ::after)
- **Some boxes are anonymous**: Generated by layout rules, not DOM elements
- **Display type determines box type**: `display: block` → BlockBox, `display: inline` → InlineBox

**The Algorithm** (simplified):
```
For each DOM node with computed style:
  1. Check if node generates a box (display: none → no box)
  2. Determine box type from display property
  3. Recursively generate children
  4. Insert anonymous boxes where needed
  5. Generate pseudo-element boxes
  6. Return BoxNode
```

**Why This is Complex:**

- **Display type variations**: block, inline, inline-block, flex, grid, table, list-item, etc.
- **Anonymous box rules**: When to insert them varies by context
- **Text node handling**: Text becomes TextBox with parent's style
- **Pseudo-elements**: ::before and ::after are positioned in tree
- **Display fixup**: Some display values change based on context (e.g., float forces block)

### Why This Matters

Box generation is consumed by:
- **W2.T10**: LayoutEngine (takes BoxTree, dispatches to FCs)
- **W3.T02**: Anonymous box creation (uses box generation infrastructure)
- **W3.T03**: Table structure fixup (post-processes generated boxes)
- **All layout FCs**: Take BoxNode as input

Without box generation:
- Can't transform DOM to boxes
- Can't feed layout algorithms
- Can't handle display types
- Can't render anything!

This is the first step in the rendering pipeline after style computation.

## Prerequisites

### Required Knowledge
- **CSS 2.1 Section 9.2**: Box generation
- **CSS Display Module**: Display property values
- **Rust tree algorithms**: Recursive tree traversal
- **CSS box model**: Block vs inline vs text

### Required Reading
1. **outputs/notes/W1.R01-notes.md**: CSS visual formatting model research
   - Focus on Section 9.2 notes (box generation)
2. **outputs/notes/W2.T11-notes.md**: Box generator structure (stub)
   - Look for architecture decisions
3. **docs/plan/01-box-generation.md**: Complete implementation guide
4. **outputs/notes/W2.T01-notes.md**: BoxNode type API

## Inputs

### From Dependencies

1. **W2.T11-notes.md** (Box Generator Structure)
   - Look for: BoxGenerator struct skeleton
   - Look for: Module structure decisions
   - Look for: Initial design choices
   - Key insight: Basic structure is defined, need full algorithm

2. **W1.R01-notes.md** (CSS Research)
   - Look for: Box generation rules from CSS 2.1 Section 9.2
   - Look for: Display type to box type mapping
   - Look for: Anonymous box generation rules
   - **Critical**: Follow spec rules exactly

### Existing Code

Read these files:
- `src/tree/box_generation.rs` - Stub from W2.T11, implement full algorithm
- `src/tree/box_tree.rs` - BoxNode, BoxType types
- `src/style/computed.rs` - ComputedStyle with display property
- `docs/plan/01-box-generation.md` - Complete algorithm pseudocode

## Objectives

### Primary Goals

1. **Implement generate_box()**: Core recursive box generation function
2. **Implement display type mapping**: Map display property to BoxType
3. **Handle text nodes**: Convert text to TextBox with inherited style
4. **Filter non-generating nodes**: Skip display: none
5. **Handle replaced elements**: Images, video, canvas
6. **Implement debug info**: Attach DOM element info to boxes
7. **Comprehensive tests**: All display types, edge cases

### Success Criteria

- [ ] BoxGenerator::generate() transforms DOM tree to BoxTree
- [ ] All display types handled (block, inline, flex, grid, table, etc.)
- [ ] display: none nodes filtered out correctly
- [ ] Text nodes become TextBox instances
- [ ] Replaced elements (img, video, etc.) become ReplacedBox
- [ ] Debug info attached to boxes (element tag, id, classes)
- [ ] At least 25 tests covering all box types and edge cases
- [ ] Tests pass: `cargo test tree::box_generation`
- [ ] Clippy clean
- [ ] Documentation complete
- [ ] Notes file comprehensive

## Implementation Guide

### Step 1: Update BoxGenerator Structure (Estimated: 30min)

**Update `src/tree/box_generation.rs`:**

```rust
//! Box generation algorithm
//!
//! Transforms a DOM tree with computed styles into a Box Tree.
//!
//! CSS Specification: CSS 2.1 Section 9.2 - Box Generation
//! https://www.w3.org/TR/CSS21/visuren.html#box-gen

use crate::tree::{BoxNode, BoxType, BlockBox, InlineBox, TextBox, ReplacedBox, ReplacedType};
use crate::style::{ComputedStyle, Display};
use crate::geometry::Size;
use crate::error::{Result, Error};
use std::sync::Arc;

// Placeholder DOM types - replace with actual DOM types from your codebase
pub trait DomNode {
    fn computed_style(&self) -> Option<Arc<ComputedStyle>>;
    fn children(&self) -> Vec<&dyn DomNode>;
    fn text_content(&self) -> Option<String>;
    fn tag_name(&self) -> Option<String>;
    fn id(&self) -> Option<String>;
    fn classes(&self) -> Vec<String>;
    fn is_replaced_element(&self) -> bool;
    fn intrinsic_size(&self) -> Option<Size>;
}

/// Box generator
///
/// Converts DOM tree to Box Tree following CSS box generation rules.
pub struct BoxGenerator {
    /// Enable debug information generation
    debug: bool,
}

impl BoxGenerator {
    /// Creates a new box generator
    pub fn new() -> Self {
        Self { debug: false }
    }

    /// Enables debug information
    pub fn with_debug(mut self) -> Self {
        self.debug = true;
        self
    }

    /// Generates a box tree from a DOM tree
    ///
    /// # Arguments
    ///
    /// * `dom_root` - Root DOM node with computed styles
    ///
    /// # Returns
    ///
    /// Box tree ready for layout
    ///
    /// # Errors
    ///
    /// Returns error if DOM node has no computed style
    pub fn generate(&self, dom_root: &dyn DomNode) -> Result<BoxNode> {
        self.generate_box(dom_root)
    }
}

impl Default for BoxGenerator {
    fn default() -> Self {
        Self::new()
    }
}
```

### Step 2: Implement Core generate_box() (Estimated: 3-4 hours)

**Add to `src/tree/box_generation.rs`:**

```rust
impl BoxGenerator {
    /// Generates a box for a single DOM node
    ///
    /// This is the core recursive function that traverses the DOM tree
    /// and generates corresponding boxes.
    ///
    /// # CSS 2.1 Section 9.2.1
    ///
    /// "Block-level elements are those elements of the source document that are
    /// formatted visually as blocks. The following values of the 'display' property
    /// make an element block-level: 'block', 'list-item', and 'table'."
    ///
    /// # Arguments
    ///
    /// * `node` - DOM node to process
    ///
    /// # Returns
    ///
    /// BoxNode, or Error if node doesn't generate a box
    fn generate_box(&self, node: &dyn DomNode) -> Result<BoxNode> {
        // Get computed style
        let style = node.computed_style()
            .ok_or_else(|| Error::Layout("DOM node has no computed style".into()))?;

        // Check if node generates a box
        if !self.generates_box(&style) {
            return Err(Error::Layout("Node doesn't generate box (display: none)".into()));
        }

        // Determine box type from display value
        let box_type = self.compute_box_type(node, &style)?;

        // Generate boxes for children
        let children = self.generate_children(node)?;

        // Create debug info if enabled
        let debug_info = if self.debug {
            Some(crate::tree::DebugInfo::new(
                node.tag_name(),
                node.id(),
                node.classes(),
            ))
        } else {
            None
        };

        // Create the box node
        let mut box_node = match box_type {
            BoxType::Block(block_box) => {
                BoxNode {
                    style,
                    box_type: BoxType::Block(block_box),
                    children,
                    debug_info,
                }
            }
            BoxType::Inline(inline_box) => {
                BoxNode {
                    style,
                    box_type: BoxType::Inline(inline_box),
                    children,
                    debug_info,
                }
            }
            BoxType::Text(text_box) => {
                BoxNode {
                    style,
                    box_type: BoxType::Text(text_box),
                    children: Vec::new(), // Text boxes have no children
                    debug_info,
                }
            }
            BoxType::Replaced(replaced_box) => {
                BoxNode {
                    style,
                    box_type: BoxType::Replaced(replaced_box),
                    children: Vec::new(), // Replaced elements have no children
                    debug_info,
                }
            }
            _ => {
                return Err(Error::Layout(format!("Unsupported box type: {:?}", box_type)));
            }
        };

        Ok(box_node)
    }

    /// Checks if a node generates a box
    ///
    /// CSS 2.1 Section 9.2.1: Elements with display: none do not generate boxes.
    /// CSS Display 3: Elements with display: contents don't generate a box,
    /// but their children do.
    fn generates_box(&self, style: &ComputedStyle) -> bool {
        match style.display {
            Display::None => false,
            Display::Contents => false,
            _ => true,
        }
    }

    /// Computes the box type from display value
    ///
    /// Maps CSS display property to internal BoxType enum.
    ///
    /// # CSS 2.1 Section 9.2
    ///
    /// Different display values create different box types:
    /// - block, list-item → Block-level box
    /// - inline → Inline-level box
    /// - inline-block → Inline-level block container
    /// - table → Table box
    /// - flex, grid → Flex/Grid container
    fn compute_box_type(&self, node: &dyn DomNode, style: &ComputedStyle) -> Result<BoxType> {
        // Check for replaced elements first
        if node.is_replaced_element() {
            return self.create_replaced_box(node, style);
        }

        // Map display to box type
        match style.display {
            Display::Block => {
                Ok(BoxType::Block(BlockBox {
                    formatting_context: crate::tree::FormattingContextType::Block,
                }))
            }

            Display::Inline => {
                Ok(BoxType::Inline(InlineBox {
                    formatting_context: None,
                }))
            }

            Display::InlineBlock => {
                Ok(BoxType::Inline(InlineBox {
                    formatting_context: Some(crate::tree::FormattingContextType::Block),
                }))
            }

            Display::Flex => {
                Ok(BoxType::Block(BlockBox {
                    formatting_context: crate::tree::FormattingContextType::Flex,
                }))
            }

            Display::InlineFlex => {
                Ok(BoxType::Inline(InlineBox {
                    formatting_context: Some(crate::tree::FormattingContextType::Flex),
                }))
            }

            Display::Grid => {
                Ok(BoxType::Block(BlockBox {
                    formatting_context: crate::tree::FormattingContextType::Grid,
                }))
            }

            Display::InlineGrid => {
                Ok(BoxType::Inline(InlineBox {
                    formatting_context: Some(crate::tree::FormattingContextType::Grid),
                }))
            }

            Display::Table => {
                Ok(BoxType::Block(BlockBox {
                    formatting_context: crate::tree::FormattingContextType::Table,
                }))
            }

            Display::TableRow => {
                // Table internal boxes - handled by table structure fixup (W3.T03)
                Err(Error::Layout("Table internal boxes not yet supported".into()))
            }

            Display::TableCell => {
                Err(Error::Layout("Table internal boxes not yet supported".into()))
            }

            Display::None | Display::Contents => {
                Err(Error::Layout("Node doesn't generate box".into()))
            }

            _ => {
                Err(Error::Layout(format!("Unsupported display value: {:?}", style.display)))
            }
        }
    }

    /// Creates a replaced box for replaced elements
    fn create_replaced_box(&self, node: &dyn DomNode, _style: &ComputedStyle) -> Result<BoxType> {
        let tag = node.tag_name().unwrap_or_default();

        let replaced_type = match tag.as_str() {
            "img" => ReplacedType::Image {
                src: String::new(), // TODO: Get from node attributes
            },
            "video" => ReplacedType::Video {
                src: String::new(),
            },
            "canvas" => ReplacedType::Canvas,
            "svg" => ReplacedType::Svg {
                content: String::new(),
            },
            "iframe" => ReplacedType::Iframe {
                src: String::new(),
            },
            _ => {
                return Err(Error::Layout(format!("Unknown replaced element: {}", tag)));
            }
        };

        let intrinsic_size = node.intrinsic_size();
        let aspect_ratio = intrinsic_size.map(|size| size.width / size.height);

        Ok(BoxType::Replaced(ReplacedBox {
            replaced_type,
            intrinsic_size,
            aspect_ratio,
        }))
    }

    /// Generates boxes for child nodes
    fn generate_children(&self, node: &dyn DomNode) -> Result<Vec<BoxNode>> {
        let mut children = Vec::new();

        // Process element children
        for child_node in node.children() {
            match self.generate_box(child_node) {
                Ok(child_box) => {
                    children.push(child_box);
                }
                Err(e) => {
                    // Child doesn't generate a box (e.g., display: none)
                    // This is not an error - just skip it
                    if self.debug {
                        eprintln!("Skipping child: {:?}", e);
                    }
                }
            }
        }

        // Handle text content
        if let Some(text) = node.text_content() {
            let trimmed = text.trim();
            if !trimmed.is_empty() {
                // Create text box with parent's style
                let text_box = self.create_text_box(trimmed.to_string());
                children.push(text_box);
            }
        }

        Ok(children)
    }

    /// Creates a text box
    fn create_text_box(&self, text: String) -> BoxNode {
        // Text boxes inherit style from parent
        // For now, use default style - will be fixed in actual DOM integration
        let style = Arc::new(ComputedStyle::default());

        BoxNode {
            style,
            box_type: BoxType::Text(TextBox { text }),
            children: Vec::new(),
            debug_info: None,
        }
    }
}
```

### Step 3: Add Utility Methods (Estimated: 1 hour)

```rust
impl BoxGenerator {
    /// Counts total boxes in generated tree
    pub fn count_boxes(box_node: &BoxNode) -> usize {
        1 + box_node.children.iter()
            .map(|child| Self::count_boxes(child))
            .sum::<usize>()
    }

    /// Finds all boxes of a specific type
    pub fn find_boxes_by_type<'a>(
        box_node: &'a BoxNode,
        predicate: impl Fn(&BoxType) -> bool + Copy,
    ) -> Vec<&'a BoxNode> {
        let mut result = Vec::new();

        if predicate(&box_node.box_type) {
            result.push(box_node);
        }

        for child in &box_node.children {
            result.extend(Self::find_boxes_by_type(child, predicate));
        }

        result
    }

    /// Validates box tree structure
    ///
    /// Checks for common errors like:
    /// - Text boxes with children
    /// - Replaced boxes with children
    pub fn validate_box_tree(box_node: &BoxNode) -> Result<()> {
        match &box_node.box_type {
            BoxType::Text(_) => {
                if !box_node.children.is_empty() {
                    return Err(Error::Layout("Text box cannot have children".into()));
                }
            }
            BoxType::Replaced(_) => {
                if !box_node.children.is_empty() {
                    return Err(Error::Layout("Replaced box cannot have children".into()));
                }
            }
            _ => {}
        }

        // Recursively validate children
        for child in &box_node.children {
            Self::validate_box_tree(child)?;
        }

        Ok(())
    }
}
```

### Step 4: Write Comprehensive Tests (Estimated: 3-4 hours)

**Create `tests/tree/test_box_generation.rs`:**

```rust
use fastrender::tree::{BoxGenerator, BoxNode, BoxType};
use fastrender::style::{ComputedStyle, Display};
use fastrender::geometry::Size;
use std::sync::Arc;

// Mock DOM node for testing
struct MockDomNode {
    style: Arc<ComputedStyle>,
    children: Vec<MockDomNode>,
    text: Option<String>,
    tag: Option<String>,
    id: Option<String>,
    classes: Vec<String>,
    is_replaced: bool,
    intrinsic_size: Option<Size>,
}

impl MockDomNode {
    fn new(display: Display) -> Self {
        let mut style = ComputedStyle::default();
        style.display = display;

        Self {
            style: Arc::new(style),
            children: Vec::new(),
            text: None,
            tag: None,
            id: None,
            classes: Vec::new(),
            is_replaced: false,
            intrinsic_size: None,
        }
    }

    fn with_tag(mut self, tag: &str) -> Self {
        self.tag = Some(tag.to_string());
        self
    }

    fn with_children(mut self, children: Vec<MockDomNode>) -> Self {
        self.children = children;
        self
    }

    fn with_text(mut self, text: &str) -> Self {
        self.text = Some(text.to_string());
        self
    }

    fn as_replaced(mut self, size: Option<Size>) -> Self {
        self.is_replaced = true;
        self.intrinsic_size = size;
        self
    }
}

// Implement DomNode trait for MockDomNode
// ... (implement trait methods)

#[test]
fn test_generate_simple_block() {
    let generator = BoxGenerator::new();
    let dom = MockDomNode::new(Display::Block);

    let result = generator.generate(&dom);
    assert!(result.is_ok());

    let box_node = result.unwrap();
    assert!(matches!(box_node.box_type, BoxType::Block(_)));
}

#[test]
fn test_generate_inline() {
    let generator = BoxGenerator::new();
    let dom = MockDomNode::new(Display::Inline);

    let box_node = generator.generate(&dom).unwrap();
    assert!(matches!(box_node.box_type, BoxType::Inline(_)));
}

#[test]
fn test_display_none_no_box() {
    let generator = BoxGenerator::new();
    let dom = MockDomNode::new(Display::None);

    let result = generator.generate(&dom);
    assert!(result.is_err());
}

#[test]
fn test_nested_boxes() {
    let generator = BoxGenerator::new();

    let child1 = MockDomNode::new(Display::Block);
    let child2 = MockDomNode::new(Display::Inline);

    let parent = MockDomNode::new(Display::Block)
        .with_children(vec![child1, child2]);

    let box_node = generator.generate(&parent).unwrap();
    assert_eq!(box_node.children.len(), 2);
    assert!(matches!(box_node.children[0].box_type, BoxType::Block(_)));
    assert!(matches!(box_node.children[1].box_type, BoxType::Inline(_)));
}

#[test]
fn test_text_box_generation() {
    let generator = BoxGenerator::new();

    let dom = MockDomNode::new(Display::Block)
        .with_text("Hello World");

    let box_node = generator.generate(&dom).unwrap();
    assert_eq!(box_node.children.len(), 1);

    match &box_node.children[0].box_type {
        BoxType::Text(text_box) => {
            assert_eq!(text_box.text, "Hello World");
        }
        _ => panic!("Expected text box"),
    }
}

#[test]
fn test_replaced_element_image() {
    let generator = BoxGenerator::new();

    let dom = MockDomNode::new(Display::Block)
        .with_tag("img")
        .as_replaced(Some(Size::new(100.0, 50.0)));

    let box_node = generator.generate(&dom).unwrap();
    assert!(matches!(box_node.box_type, BoxType::Replaced(_)));
}

#[test]
fn test_inline_block() {
    let generator = BoxGenerator::new();
    let dom = MockDomNode::new(Display::InlineBlock);

    let box_node = generator.generate(&dom).unwrap();

    match &box_node.box_type {
        BoxType::Inline(inline_box) => {
            assert!(inline_box.formatting_context.is_some());
        }
        _ => panic!("Expected inline box"),
    }
}

#[test]
fn test_flex_container() {
    let generator = BoxGenerator::new();
    let dom = MockDomNode::new(Display::Flex);

    let box_node = generator.generate(&dom).unwrap();

    match &box_node.box_type {
        BoxType::Block(block_box) => {
            assert_eq!(block_box.formatting_context, FormattingContextType::Flex);
        }
        _ => panic!("Expected block box with flex context"),
    }
}

#[test]
fn test_grid_container() {
    let generator = BoxGenerator::new();
    let dom = MockDomNode::new(Display::Grid);

    let box_node = generator.generate(&dom).unwrap();

    match &box_node.box_type {
        BoxType::Block(block_box) => {
            assert_eq!(block_box.formatting_context, FormattingContextType::Grid);
        }
        _ => panic!("Expected block box with grid context"),
    }
}

#[test]
fn test_skip_display_none_children() {
    let generator = BoxGenerator::new();

    let child1 = MockDomNode::new(Display::Block);
    let child2 = MockDomNode::new(Display::None); // Should be skipped
    let child3 = MockDomNode::new(Display::Inline);

    let parent = MockDomNode::new(Display::Block)
        .with_children(vec![child1, child2, child3]);

    let box_node = generator.generate(&parent).unwrap();

    // Only 2 children (child2 skipped)
    assert_eq!(box_node.children.len(), 2);
}

#[test]
fn test_deeply_nested_structure() {
    let generator = BoxGenerator::new();

    let grandchild = MockDomNode::new(Display::Inline)
        .with_text("Deep text");

    let child = MockDomNode::new(Display::Block)
        .with_children(vec![grandchild]);

    let root = MockDomNode::new(Display::Block)
        .with_children(vec![child]);

    let box_node = generator.generate(&root).unwrap();

    assert_eq!(box_node.children.len(), 1);
    assert_eq!(box_node.children[0].children.len(), 1);
    assert_eq!(box_node.children[0].children[0].children.len(), 1);
}

#[test]
fn test_count_boxes() {
    let child1 = MockDomNode::new(Display::Block);
    let child2 = MockDomNode::new(Display::Inline);

    let parent = MockDomNode::new(Display::Block)
        .with_children(vec![child1, child2]);

    let generator = BoxGenerator::new();
    let box_node = generator.generate(&parent).unwrap();

    let count = BoxGenerator::count_boxes(&box_node);
    assert_eq!(count, 3); // parent + 2 children
}

#[test]
fn test_validate_text_box_no_children() {
    let mut text_box = BoxNode::new_text(
        Arc::new(ComputedStyle::default()),
        "Text".to_string(),
    );

    // Try to add child (invalid)
    text_box.children.push(BoxNode::new_block(
        Arc::new(ComputedStyle::default()),
        FormattingContextType::Block,
        vec![],
    ));

    let result = BoxGenerator::validate_box_tree(&text_box);
    assert!(result.is_err());
}

#[test]
fn test_find_boxes_by_type() {
    let child1 = MockDomNode::new(Display::Block);
    let child2 = MockDomNode::new(Display::Inline);
    let child3 = MockDomNode::new(Display::Block);

    let parent = MockDomNode::new(Display::Block)
        .with_children(vec![child1, child2, child3]);

    let generator = BoxGenerator::new();
    let box_node = generator.generate(&parent).unwrap();

    let block_boxes = BoxGenerator::find_boxes_by_type(&box_node, |bt| {
        matches!(bt, BoxType::Block(_))
    });

    assert_eq!(block_boxes.len(), 3); // parent + 2 block children
}

// Add 10+ more tests for:
// - Canvas elements
// - Video elements
// - SVG elements
// - Mixed inline/block content
// - Empty text nodes (should be filtered)
// - Whitespace-only text
// - Multiple text nodes
// - Debug info generation
// - Error handling for unsupported display types
```

### Step 5: Documentation and Notes (Estimated: 1 hour)

Run verification:
```bash
cargo test tree::box_generation
cargo clippy -- -D warnings
cargo fmt
```

## Testing Requirements

### Unit Tests

**Required tests** (25+ tests):
1. All display types (block, inline, inline-block, flex, grid, table)
2. display: none filtering
3. Text box generation
4. Replaced elements (img, video, canvas, svg, iframe)
5. Nested structures
6. Mixed inline/block content
7. Empty/whitespace text handling
8. Tree validation
9. Box counting utilities
10. Error handling

**Run:** `cargo test tree::box_generation`

## Output Artifacts

### Code Files

1. **`src/tree/box_generation.rs`** (~400-500 lines)
   - Complete box generation algorithm
   - Display type mapping
   - Text and replaced element handling
   - Utility methods

2. **`tests/tree/test_box_generation.rs`** (~400-500 lines)
   - 25+ comprehensive tests
   - Mock DOM infrastructure
   - All display types covered

### Notes File

Create: **`outputs/notes/W3.T01-notes.md`**

**Key sections:**
- **API Contracts**: BoxGenerator::generate() signature
- **Decision**: How display types map to BoxType
- **Decision**: Text node handling strategy
- **Discovery**: Edge cases in CSS spec
- **Recommendations**: For W3.T02 (anonymous boxes)
- **Recommendations**: For W3.T03 (table fixup)
- **Open Questions**: Pseudo-element generation (deferred)

## Common Pitfalls to Avoid

### Pitfall 1: Not Filtering display: none

**Wrong:** Generate box for all nodes
**Right:** Check generates_box() first

### Pitfall 2: Forgetting Text Nodes

**Wrong:** Only process element children
**Right:** Also convert text content to TextBox

### Pitfall 3: Allowing Children in Text/Replaced Boxes

**Wrong:** No validation of box structure
**Right:** Validate that text/replaced boxes have no children

### Pitfall 4: Not Handling display: contents

**Wrong:** Treat as display: none
**Right:** Skip box but process children

## Verification Checklist

- [ ] All objectives met
- [ ] All display types handled
- [ ] display: none filtered
- [ ] Text boxes generated
- [ ] Replaced elements handled
- [ ] Tests pass (25+)
- [ ] Clippy clean
- [ ] Documentation complete
- [ ] Notes file comprehensive

## Time Tracking

- **Module setup:** 30min
- **Core generate_box():** 3-4hrs
- **Utility methods:** 1hr
- **Tests:** 3-4hrs
- **Documentation:** 1hr
- **Total:** 8-12 hours

## Getting Help

- Review `docs/plan/01-box-generation.md` for algorithm details
- CSS 2.1 Section 9.2 for box generation rules
- W1.R01 notes for CSS research
- W2.T01 notes for BoxNode API

Remember: This is the DOM → Box bridge. Get it right and everything flows smoothly!
