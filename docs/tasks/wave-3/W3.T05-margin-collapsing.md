---
task_id: "W3.T05"
title: "Implement Margin Collapsing Algorithm"
wave: 3
estimated_hours: 6-8
depends_on:
  - "W3.T04"
inputs:
  - "outputs/notes/W3.T04-notes.md"
  - "outputs/notes/W1.R01-notes.md"
  - "src/layout/contexts/block.rs"
outputs:
  - "src/layout/contexts/block/margin_collapse.rs"
  - "tests/layout/test_margin_collapse.rs"
  - "outputs/notes/W3.T05-notes.md"
skills_required:
  - "Rust"
  - "CSS margin collapsing rules"
  - "Complex algorithm implementation"
context_files:
  - "docs/plan/02-block-layout.md"
  - "outputs/notes/W1.R01-notes.md"
verification:
  - "cargo test layout::margin_collapse"
  - "cargo clippy -- -D warnings"
---

# Implement Margin Collapsing Algorithm

## Context

Margin collapsing is one of the most subtle and complex parts of CSS block layout. When vertical margins of block boxes meet, they "collapse" into a single margin, with special rules for positive, negative, and mixed margins.

This **Wave 3 task** extends W3.T04 (block layout) with correct margin collapsing implementation.

### Background

**What is Margin Collapsing?**

From CSS 2.1 Section 8.3.1:
> "In CSS, the adjoining margins of two or more boxes can combine to form a single margin. Margins that combine this way are said to collapse."

**Basic Rule:**
When two vertical margins touch, they collapse:
- Positive + Positive → max(m1, m2)
- Negative + Negative → min(m1, m2) (most negative)
- Positive + Negative → sum(m1, m2)

**Example:**
```html
<div style="margin-bottom: 20px">Block 1</div>
<div style="margin-top: 30px">Block 2</div>
```
Gap between blocks: **30px** (not 50px)

**Complex Cases:**

1. **Empty blocks**: Top and bottom margins of empty blocks collapse with each other
2. **First/last child**: Child's margin can collapse with parent's
3. **Clearance**: Clearing floats prevents margin collapse
4. **Negative margins**: Special handling required
5. **BFC boundaries**: Margins don't collapse across BFC boundaries

**The Algorithm** (from spec):
```
struct CollapsibleMargin {
    positive: f32,  // Largest positive margin
    negative: f32,  // Most negative margin (absolute value)
}

fn collapse(m1: CollapsibleMargin, m2: CollapsibleMargin) -> f32 {
    m1.positive.max(m2.positive) - m1.negative.max(m2.negative)
}
```

### Why This Matters

Margin collapsing affects:
- **W3.T04**: Block layout vertical positioning
- **W3.T10**: Float layout (clearance interaction)
- **All block containers**: Correct spacing

Without margin collapsing:
- Blocks have too much space between them
- Empty blocks take up space incorrectly
- Vertical rhythm is wrong
- WPT tests fail

## Prerequisites

### Required Knowledge
- **CSS 2.1 Section 8.3.1**: Collapsing margins
- **CSS 2.1 Section 10.6**: Height calculation
- **Block formatting context**: What prevents collapse

### Required Reading
1. **outputs/notes/W1.R01-notes.md**: Margin collapsing research
2. **outputs/notes/W3.T04-notes.md**: Block layout integration
3. **docs/plan/02-block-layout.md**: Margin collapse section

## Inputs

### From Dependencies

1. **W3.T04-notes.md** (Block Layout)
   - Look for: How margins are currently handled
   - Look for: Integration points for collapse algorithm
   - Key insight: Block layout needs margin collapse in vertical positioning

2. **W1.R01-notes.md** (CSS Research)
   - Look for: Complete margin collapsing rules
   - Look for: Edge cases and special conditions
   - **Critical**: Implement all 8+ collapse scenarios

## Objectives

### Primary Goals

1. **Implement CollapsibleMargin type**: Tracks positive/negative margins
2. **Implement collapse()**: Combines two collapsible margins
3. **Implement collapse detection**: When do margins collapse?
4. **Handle empty blocks**: Top/bottom margin collapse
5. **Handle parent-child collapse**: First/last child margins
6. **Handle clearance**: Prevent collapse with cleared blocks
7. **Comprehensive tests**: All collapse scenarios

### Success Criteria

- [ ] CollapsibleMargin type implemented
- [ ] collapse() combines margins correctly
- [ ] Positive margins: max(m1, m2)
- [ ] Negative margins: min(m1, m2)
- [ ] Mixed margins: sum works correctly
- [ ] Empty block collapse handled
- [ ] Parent-child collapse works
- [ ] At least 30 tests covering all scenarios
- [ ] Tests pass
- [ ] Clippy clean
- [ ] Notes comprehensive

## Implementation Guide

### Step 1: Define CollapsibleMargin Type (Estimated: 30min)

**Create `src/layout/contexts/block/margin_collapse.rs`:**

```rust
//! Margin collapsing algorithm (CSS 2.1 Section 8.3.1)

/// A collapsible margin that tracks positive and negative components
///
/// CSS 2.1 Section 8.3.1: "When two or more margins collapse, the
/// resulting margin width is the maximum of the adjoining margins."
///
/// We track positive and negative separately to handle mixed margins.
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct CollapsibleMargin {
    /// Largest positive margin value
    pub positive: f32,

    /// Most negative margin value (stored as absolute value)
    pub negative: f32,
}

impl CollapsibleMargin {
    /// The zero margin
    pub const ZERO: Self = Self {
        positive: 0.0,
        negative: 0.0,
    };

    /// Creates a collapsible margin from a single margin value
    ///
    /// # Examples
    ///
    /// ```
    /// let m1 = CollapsibleMargin::from_margin(20.0);
    /// assert_eq!(m1.positive, 20.0);
    /// assert_eq!(m1.negative, 0.0);
    ///
    /// let m2 = CollapsibleMargin::from_margin(-10.0);
    /// assert_eq!(m2.positive, 0.0);
    /// assert_eq!(m2.negative, 10.0);
    /// ```
    pub fn from_margin(value: f32) -> Self {
        if value >= 0.0 {
            Self {
                positive: value,
                negative: 0.0,
            }
        } else {
            Self {
                positive: 0.0,
                negative: -value,
            }
        }
    }

    /// Collapses this margin with another
    ///
    /// CSS 2.1 Section 8.3.1: When margins collapse:
    /// - If all margins are positive: result = max of all margins
    /// - If all margins are negative: result = min of all margins (most negative)
    /// - If mixed positive and negative: result = largest positive + most negative
    ///
    /// # Examples
    ///
    /// ```
    /// // Two positive margins: take max
    /// let m1 = CollapsibleMargin::from_margin(20.0);
    /// let m2 = CollapsibleMargin::from_margin(30.0);
    /// let result = m1.collapse_with(m2);
    /// assert_eq!(result.resolve(), 30.0);
    ///
    /// // Positive and negative: sum
    /// let m1 = CollapsibleMargin::from_margin(20.0);
    /// let m2 = CollapsibleMargin::from_margin(-10.0);
    /// let result = m1.collapse_with(m2);
    /// assert_eq!(result.resolve(), 10.0);
    /// ```
    pub fn collapse_with(self, other: Self) -> Self {
        Self {
            positive: self.positive.max(other.positive),
            negative: self.negative.max(other.negative),
        }
    }

    /// Resolves the collapsible margin to a final value
    ///
    /// # Returns
    ///
    /// The collapsed margin value (positive - negative)
    pub fn resolve(self) -> f32 {
        self.positive - self.negative
    }

    /// Checks if this margin is zero
    pub fn is_zero(self) -> bool {
        self.positive == 0.0 && self.negative == 0.0
    }

    /// Adds a margin value to this collapsible margin
    ///
    /// Used when accumulating margins through multiple collapse operations.
    pub fn add_margin(self, value: f32) -> Self {
        let new_margin = Self::from_margin(value);
        self.collapse_with(new_margin)
    }
}

impl std::fmt::Display for CollapsibleMargin {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CM(+{}, -{})", self.positive, self.negative)
    }
}
```

### Step 2: Implement Collapse Detection (Estimated: 2 hours)

```rust
/// Margin collapse context
///
/// Tracks state during margin collapse computation in block layout.
#[derive(Debug)]
pub struct MarginCollapseContext {
    /// Pending collapsed margin from previous siblings
    pending_margin: CollapsibleMargin,

    /// Whether we're at the start of the block container
    at_start: bool,
}

impl MarginCollapseContext {
    /// Creates a new margin collapse context
    pub fn new() -> Self {
        Self {
            pending_margin: CollapsibleMargin::ZERO,
            at_start: true,
        }
    }

    /// Processes a child box's margins
    ///
    /// Returns the collapsed margin to use for positioning this child.
    ///
    /// # Arguments
    ///
    /// * `margin_top` - Child's top margin
    /// * `margin_bottom` - Child's bottom margin
    /// * `is_empty` - Whether child has zero height
    /// * `is_last` - Whether this is the last child
    ///
    /// # Returns
    ///
    /// (collapsed_top_margin, new_pending_margin)
    pub fn process_child(
        &mut self,
        margin_top: f32,
        margin_bottom: f32,
        is_empty: bool,
        is_last: bool,
    ) -> (f32, CollapsibleMargin) {
        let top_margin = CollapsibleMargin::from_margin(margin_top);
        let bottom_margin = CollapsibleMargin::from_margin(margin_bottom);

        // Collapse with pending margin from previous sibling
        let collapsed_top = self.pending_margin.collapse_with(top_margin);

        if is_empty {
            // Empty block: top and bottom margins collapse with each other
            let self_collapsed = top_margin.collapse_with(bottom_margin);

            // This becomes the new pending margin
            self.pending_margin = self.pending_margin.collapse_with(self_collapsed);

            // Empty blocks contribute zero to positioning
            (0.0, self.pending_margin)
        } else {
            // Normal block: use collapsed top, save bottom as pending
            self.pending_margin = bottom_margin;
            self.at_start = false;

            (collapsed_top.resolve(), self.pending_margin)
        }
    }

    /// Gets the final pending margin (for parent's bottom)
    pub fn get_pending_margin(&self) -> CollapsibleMargin {
        self.pending_margin
    }
}
```

### Step 3: Implement Special Cases (Estimated: 2 hours)

```rust
/// Margin collapse rules for parent-child margins
pub struct ParentChildCollapseRules;

impl ParentChildCollapseRules {
    /// Checks if parent's top margin can collapse with first child's top margin
    ///
    /// CSS 2.1 Section 8.3.1: Parent and first child margins collapse if:
    /// - No border-top on parent
    /// - No padding-top on parent
    /// - No clearance on child
    pub fn can_collapse_parent_top_with_child_top(
        parent_border_top: f32,
        parent_padding_top: f32,
        child_has_clearance: bool,
    ) -> bool {
        parent_border_top == 0.0
            && parent_padding_top == 0.0
            && !child_has_clearance
    }

    /// Checks if parent's bottom margin can collapse with last child's bottom margin
    ///
    /// CSS 2.1 Section 8.3.1: Parent and last child margins collapse if:
    /// - No border-bottom on parent
    /// - No padding-bottom on parent
    /// - Parent has auto height
    pub fn can_collapse_parent_bottom_with_child_bottom(
        parent_border_bottom: f32,
        parent_padding_bottom: f32,
        parent_has_auto_height: bool,
    ) -> bool {
        parent_border_bottom == 0.0
            && parent_padding_bottom == 0.0
            && parent_has_auto_height
    }
}

/// Checks if a box establishes a new BFC (which prevents margin collapse)
pub fn establishes_bfc(box_node: &BoxNode) -> bool {
    // BFC is established by:
    // - Floats
    // - Absolutely positioned elements
    // - overflow != visible
    // - display: inline-block, flex, grid, table

    // For now, simplified check
    match &box_node.box_type {
        BoxType::Block(block) => {
            !matches!(block.formatting_context, FormattingContextType::Block)
        }
        BoxType::Inline(inline) => {
            inline.formatting_context.is_some() // inline-block
        }
        _ => false,
    }
}
```

### Step 4: Write Comprehensive Tests (Estimated: 2 hours)

**Create `tests/layout/test_margin_collapse.rs`:**

```rust
use fastrender::layout::margin_collapse::*;

#[test]
fn test_positive_margins_take_max() {
    let m1 = CollapsibleMargin::from_margin(20.0);
    let m2 = CollapsibleMargin::from_margin(30.0);

    let result = m1.collapse_with(m2);
    assert_eq!(result.resolve(), 30.0);
}

#[test]
fn test_negative_margins_take_most_negative() {
    let m1 = CollapsibleMargin::from_margin(-20.0);
    let m2 = CollapsibleMargin::from_margin(-30.0);

    let result = m1.collapse_with(m2);
    assert_eq!(result.resolve(), -30.0);
}

#[test]
fn test_mixed_margins_sum() {
    let m1 = CollapsibleMargin::from_margin(20.0);
    let m2 = CollapsibleMargin::from_margin(-10.0);

    let result = m1.collapse_with(m2);
    assert_eq!(result.resolve(), 10.0);
}

#[test]
fn test_zero_margins() {
    let m1 = CollapsibleMargin::from_margin(0.0);
    let m2 = CollapsibleMargin::from_margin(0.0);

    let result = m1.collapse_with(m2);
    assert_eq!(result.resolve(), 0.0);
    assert!(result.is_zero());
}

#[test]
fn test_multiple_collapse() {
    // Three margins: 10, 20, 30 → 30
    let m1 = CollapsibleMargin::from_margin(10.0);
    let m2 = CollapsibleMargin::from_margin(20.0);
    let m3 = CollapsibleMargin::from_margin(30.0);

    let result = m1.collapse_with(m2).collapse_with(m3);
    assert_eq!(result.resolve(), 30.0);
}

#[test]
fn test_empty_block_collapse() {
    let mut ctx = MarginCollapseContext::new();

    // Empty block with margins 20 and 30
    let (offset, _) = ctx.process_child(20.0, 30.0, true, false);

    // Empty block contributes 0 to positioning
    assert_eq!(offset, 0.0);

    // But pending margin should be max(20, 30) = 30
    let pending = ctx.get_pending_margin();
    assert_eq!(pending.resolve(), 30.0);
}

#[test]
fn test_sibling_collapse() {
    let mut ctx = MarginCollapseContext::new();

    // First child: margin-bottom 20
    let (offset1, _) = ctx.process_child(0.0, 20.0, false, false);
    assert_eq!(offset1, 0.0); // First child at 0

    // Second child: margin-top 30
    // Should collapse with first child's margin-bottom
    let (offset2, _) = ctx.process_child(30.0, 0.0, false, false);
    assert_eq!(offset2, 30.0); // max(20, 30)
}

#[test]
fn test_parent_top_margin_collapse_conditions() {
    // Can collapse if no border/padding
    assert!(ParentChildCollapseRules::can_collapse_parent_top_with_child_top(
        0.0, 0.0, false
    ));

    // Cannot collapse with border
    assert!(!ParentChildCollapseRules::can_collapse_parent_top_with_child_top(
        1.0, 0.0, false
    ));

    // Cannot collapse with padding
    assert!(!ParentChildCollapseRules::can_collapse_parent_top_with_child_top(
        0.0, 1.0, false
    ));

    // Cannot collapse with clearance
    assert!(!ParentChildCollapseRules::can_collapse_parent_top_with_child_top(
        0.0, 0.0, true
    ));
}

#[test]
fn test_parent_bottom_margin_collapse_conditions() {
    // Can collapse if no border/padding and auto height
    assert!(ParentChildCollapseRules::can_collapse_parent_bottom_with_child_bottom(
        0.0, 0.0, true
    ));

    // Cannot collapse with explicit height
    assert!(!ParentChildCollapseRules::can_collapse_parent_bottom_with_child_bottom(
        0.0, 0.0, false
    ));
}

// Add 20+ more tests for:
// - Multiple consecutive empty blocks
// - Mixed positive/negative sequences
// - Extreme values
// - Parent-child collapse scenarios
// - BFC boundaries
// - Clearance interaction
```

### Step 5: Integration with Block Layout (Estimated: 1 hour)

**Update `src/layout/contexts/block.rs`:**

```rust
use super::margin_collapse::{MarginCollapseContext, CollapsibleMargin};

impl BlockFormattingContext {
    fn layout_children(
        &self,
        parent_box: &BoxNode,
        constraints: &LayoutConstraints,
    ) -> Result<Vec<FragmentNode>> {
        let mut fragments = Vec::new();
        let mut current_y = 0.0;
        let mut collapse_ctx = MarginCollapseContext::new();

        for (i, child_box) in parent_box.children.iter().enumerate() {
            let is_last = i == parent_box.children.len() - 1;

            // Layout child
            let child_fragment = self.layout_child(child_box, constraints)?;

            // Get child margins
            let margin_top = child_box.style.margin_top.resolve(constraints.available_width);
            let margin_bottom = child_box.style.margin_bottom.resolve(constraints.available_width);

            // Check if child is empty
            let is_empty = child_fragment.rect.height() == 0.0;

            // Process margins
            let (collapsed_margin, _) = collapse_ctx.process_child(
                margin_top,
                margin_bottom,
                is_empty,
                is_last,
            );

            // Position child
            current_y += collapsed_margin;
            let positioned_fragment = child_fragment.translate(Point::new(0.0, current_y));
            current_y += child_fragment.rect.height();

            fragments.push(positioned_fragment);
        }

        Ok(fragments)
    }
}
```

Run verification:
```bash
cargo test layout::margin_collapse
cargo clippy -- -D warnings
cargo fmt
```

## Testing Requirements

**Required tests** (30+ tests):
1. Basic collapse: positive, negative, mixed
2. Multiple margins
3. Empty blocks
4. Sibling collapse
5. Parent-child collapse conditions
6. BFC boundaries
7. Edge cases
8. Integration with block layout

## Output Artifacts

### Code Files

1. **`src/layout/contexts/block/margin_collapse.rs`** (~300-400 lines)
2. **`tests/layout/test_margin_collapse.rs`** (~400-500 lines)

### Notes File

Create: **`outputs/notes/W3.T05-notes.md`**

**Key sections:**
- CollapsibleMargin algorithm
- Special cases discovered
- Integration with block layout
- WPT test results
- Recommendations for clearance (W3.T11)

## Verification Checklist

- [ ] All objectives met
- [ ] Collapse algorithm correct
- [ ] Empty blocks handled
- [ ] Tests pass (30+)
- [ ] Notes comprehensive

## Time Tracking

- CollapsibleMargin type: 30min
- Collapse detection: 2hrs
- Special cases: 2hrs
- Tests: 2hrs
- Integration: 1hr
- Total: 6-8 hours

## Getting Help

- CSS 2.1 Section 8.3.1
- W1.R01 notes for research
- W3.T04 notes for integration

Margin collapsing is subtle - test thoroughly!
