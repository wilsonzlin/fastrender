---
task_id: "W3.T04"
title: "Implement Block Formatting Context Algorithm"
wave: 3
estimated_hours: 10-14
depends_on:
  - "W2.T07"
  - "W1.R01"
  - "W2.T01"
inputs:
  - "docs/tasks/notes/W2.T07-notes.md"
  - "docs/tasks/notes/W1.R01-notes.md"
  - "docs/tasks/notes/W2.T01-notes.md"
  - "src/layout/formatting_context.rs"
outputs:
  - "src/layout/contexts/block.rs"
  - "src/layout/contexts/block/margin_collapse.rs"
  - "src/layout/contexts/block/width.rs"
  - "src/layout/contexts/mod.rs"
  - "docs/tasks/notes/W3.T04-notes.md"
skills_required:
  - "Rust"
  - "CSS layout algorithms"
  - "Complex algorithm implementation"
context_files:
  - "docs/layout/block.md"
  - "docs/tasks/notes/W1.R01-notes.md"
verification:
  - "cargo test layout::contexts::block"
  - "cargo clippy -- -D warnings"
---

# Implement Block Formatting Context Algorithm

## Context

The Block Formatting Context (BFC) is THE most fundamental layout algorithm in CSS. It's how normal document flow works - the default for almost all web pages. This is the first "real" formatting context implementation and validates the entire architecture.

This is **the most important layout implementation** in FastRender V2.

### Background

**What is Block Layout?**

From CSS 2.1 Section 9.4.1:
> "In a block formatting context, boxes are laid out one after the other, vertically, beginning at the top of a containing block."

Key behaviors:
- **Vertical stacking**: Blocks stack vertically
- **Width computation**: Blocks fill containing block width (width: auto)
- **Height computation**: Blocks grow to contain content (height: auto)
- **Margin collapsing**: Adjacent vertical margins collapse

**The Algorithm** (simplified):
```
1. Start at y = 0
2. For each child:
   a. Compute child width (fills container if auto)
   b. Layout child contents (recursive)
   c. Compute child height (content height if auto)
   d. Apply margin collapsing
   e. Position child at current y
   f. Add child height to y
3. Container height = final y (if auto)
```

**Why This is Complex:**

- Width computation has 7+ scenarios (auto margins, over-constrained, etc.)
- Margin collapsing has 8+ edge cases (empty boxes, clearance, etc.)
- Percentage heights depend on container height (potential circularity)
- Float interaction (BFCs contain floats)
- Clearance computation

### Why This Matters

Block layout is consumed by:
- **W2.T10**: LayoutEngine (dispatches block boxes here)
- **W3.T01**: Box generation (creates block boxes)
- **W4.T12**: Inline layout (establishes BFCs for inline-blocks)
- **W3.T10**: Float layout (interacts with BFC)

This validates:
- The FormattingContext trait (W2.T07)
- The BoxNode â†’ Fragment pipeline
- The constraint propagation system

If block layout works, the architecture works.

## Prerequisites

### Required Knowledge
- **CSS 2.1 Sections 9.4.1, 10.3.3, 10.6, 8.3.1**: BFC, width, height, margins
- **Rust**: Complex algorithms, recursion, error handling
- **Layout concepts**: Containing blocks, percentage resolution

### Required Reading
1. **docs/tasks/notes/W1.R01-notes.md**: Complete CSS research (focus on BFC section)
2. **docs/tasks/notes/W2.T07-notes.md**: FormattingContext trait contract
3. **docs/tasks/notes/W2.T01-notes.md**: BoxNode API
4. **docs/layout/block.md**: Implementation strategy

## Inputs

### From Dependencies

1. **W1.R01-notes.md** (CSS Research)
   - Look for: BFC layout algorithm (Section 9.4.1 notes)
   - Look for: Width computation pseudocode (Section 10.3.3)
   - Look for: Margin collapsing algorithm (Section 8.3.1)
   - **Critical**: Use the pseudocode provided, don't invent your own

2. **W2.T07-notes.md** (FC Trait)
   - Look for: Trait contract and requirements
   - Look for: How to handle recursive layout
   - Look for: Error handling patterns

3. **W2.T01-notes.md** (BoxNode)
   - Look for: How to check if box is block-level
   - Look for: How to iterate children

## Objectives

### Primary Goals

1. **Implement BlockFormattingContext struct**: Implements FormattingContext trait
2. **Implement width computation**: CSS 2.1 Section 10.3.3 algorithm
3. **Implement height computation**: Auto height from content
4. **Implement margin collapsing**: CSS 2.1 Section 8.3.1 algorithm
5. **Implement vertical positioning**: Stack children with collapsed margins
6. **Handle percentage values**: Resolve against containing block
7. **Comprehensive tests**: Cover all width/height/margin scenarios

### Success Criteria

- [ ] BlockFormattingContext implements FormattingContext trait
- [ ] Width computation matches CSS 2.1 Section 10.3.3 exactly
- [ ] Auto width fills containing block correctly
- [ ] Height: auto sums child heights correctly
- [ ] Margin collapsing handles all cases (positive, negative, mixed)
- [ ] Children positioned vertically with correct spacing
- [ ] Percentage widths/heights resolve correctly
- [ ] At least 20 tests covering all scenarios
- [ ] All tests pass
- [ ] Can render simple HTML pages end-to-end
- [ ] Notes file documents all decisions and edge cases

## Implementation Guide

### Step 1: Create Module Structure (Estimated: 30min)

```bash
mkdir -p src/layout/contexts/block
touch src/layout/contexts/block.rs
touch src/layout/contexts/block/margin_collapse.rs
touch src/layout/contexts/block/width.rs
touch src/layout/contexts/mod.rs
```

### Step 2: Implement Width Computation (Estimated: 3-4 hours)

**`src/layout/contexts/block/width.rs`:**
```rust
//! Block width computation (CSS 2.1 Section 10.3.3)

/// Computes width for block-level, non-replaced element in normal flow
///
/// CSS 2.1 Section 10.3.3 defines the constraint equation:
/// margin-left + border-left + padding-left + width + 
/// padding-right + border-right + margin-right = containing-block-width
///
/// Returns: (margin_left, width, margin_right)
pub fn compute_block_width(
    style: &ComputedStyle,
    containing_width: f32,
) -> (f32, f32, f32) {
    // Implementation follows CSS 2.1 exactly
    // ... (complete algorithm from W1.R01 notes)
}
```

### Step 3: Implement Margin Collapsing (Estimated: 3-4 hours)

**`src/layout/contexts/block/margin_collapse.rs`:**
```rust
//! Margin collapsing algorithm (CSS 2.1 Section 8.3.1)

#[derive(Debug, Clone, Copy)]
pub struct CollapsibleMargin {
    pub positive: f32,
    pub negative: f32,
}

impl CollapsibleMargin {
    pub fn new(value: f32) -> Self {
        if value >= 0.0 {
            Self { positive: value, negative: 0.0 }
        } else {
            Self { positive: 0.0, negative: -value }
        }
    }
    
    pub fn collapse_with(self, other: Self) -> Self {
        Self {
            positive: self.positive.max(other.positive),
            negative: self.negative.max(other.negative),
        }
    }
    
    pub fn resolve(self) -> f32 {
        self.positive - self.negative
    }
}

pub struct MarginCollapseState {
    pending_margin: CollapsibleMargin,
    at_start: bool,
}

impl MarginCollapseState {
    pub fn new() -> Self {
        Self {
            pending_margin: CollapsibleMargin::new(0.0),
            at_start: true,
        }
    }
    
    pub fn add_margin(&mut self, margin: f32) {
        self.pending_margin = self.pending_margin.collapse_with(
            CollapsibleMargin::new(margin)
        );
    }
    
    pub fn consume_pending(&mut self) -> f32 {
        let value = self.pending_margin.resolve();
        self.pending_margin = CollapsibleMargin::new(0.0);
        self.at_start = false;
        value
    }
}
```

### Step 4: Implement Main BFC Layout (Estimated: 4-5 hours)

**`src/layout/contexts/block.rs`:**
```rust
//! Block Formatting Context implementation

use crate::layout::{FormattingContext, LayoutConstraints, LayoutError};
use crate::tree::{BoxNode, Fragment};
use crate::geometry::{Point, Rect, Size};

mod margin_collapse;
mod width;

use margin_collapse::MarginCollapseState;

pub struct BlockFormattingContext;

impl BlockFormattingContext {
    pub fn new() -> Self {
        Self
    }
    
    fn layout_children(
        &self,
        box_node: &BoxNode,
        containing_width: f32,
        constraints: &LayoutConstraints,
    ) -> Result<Vec<Fragment>, LayoutError> {
        let mut fragments = Vec::new();
        let mut current_y = 0.0;
        let mut margin_state = MarginCollapseState::new();
        
        for child in &box_node.children {
            // Compute child constraints
            let child_constraints = LayoutConstraints::with_definite_size(
                containing_width,
                0.0, // Height is indefinite in normal flow
            );
            
            // Get appropriate FC for child
            let child_fc = get_fc_for_box(child);
            
            // Layout child
            let mut child_fragment = child_fc.layout(child, &child_constraints)?;
            
            // Get child margins
            let margin_top = get_margin_top(child, containing_width);
            let margin_bottom = get_margin_bottom(child, containing_width);
            
            // Apply collapsed margin
            margin_state.add_margin(margin_top);
            let collapsed = margin_state.consume_pending();
            current_y += collapsed;
            
            // Position child
            child_fragment.set_position(Point::new(0.0, current_y));
            current_y += child_fragment.size().height;
            
            // Store bottom margin for next iteration
            margin_state.add_margin(margin_bottom);
            
            fragments.push(child_fragment);
        }
        
        Ok(fragments)
    }
}

impl FormattingContext for BlockFormattingContext {
    fn layout(
        &self,
        box_node: &BoxNode,
        constraints: &LayoutConstraints,
    ) -> Result<Fragment, LayoutError> {
        // 1. Compute width
        let width = width::compute_block_width(
            &box_node.style,
            constraints.available_width.definite_value()
                .ok_or(LayoutError::MissingContext("Need definite width"))?,
        ).1;
        
        // 2. Layout children
        let children = self.layout_children(
            box_node,
            width,
            constraints,
        )?;
        
        // 3. Compute height (auto = sum of children)
        let height = compute_auto_height(&children);
        
        // 4. Create fragment
        Ok(Fragment::new_block(
            Rect::new(Point::ZERO, Size::new(width, height)),
            box_node.style.clone(),
            children,
        ))
    }
    
    fn compute_intrinsic_inline_size(
        &self,
        box_node: &BoxNode,
        mode: IntrinsicSizingMode,
    ) -> Result<f32, LayoutError> {
        // For blocks, intrinsic size is max of children
        let mut max_size = 0.0;
        for child in &box_node.children {
            let child_fc = get_fc_for_box(child);
            let child_size = child_fc.compute_intrinsic_inline_size(child, mode)?;
            max_size = max_size.max(child_size);
        }
        Ok(max_size)
    }
}

fn compute_auto_height(children: &[Fragment]) -> f32 {
    if children.is_empty() {
        return 0.0;
    }
    
    let last = children.last().unwrap();
    last.bounds.origin.y + last.bounds.size.height
}
```

### Step 5: Write Comprehensive Tests (Estimated: 3 hours)

Create extensive test suite covering:
- Width: auto, explicit, percentage
- Height: auto, explicit  
- Margins: positive, negative, mixed, collapsing scenarios
- Edge cases: empty blocks, single child, many children
- Nested blocks
- Integration tests with real HTML structures

## Testing Requirements

**Minimum 20 tests** covering:
1. Basic block stacking (3 tests)
2. Width computation scenarios (5 tests)
3. Height computation (3 tests)
4. Margin collapsing (6 tests)
5. Edge cases (3 tests)

## Output Artifacts

### Code Files

1. **`src/layout/contexts/block.rs`** (~400 lines)
2. **`src/layout/contexts/block/width.rs`** (~200 lines)
3. **`src/layout/contexts/block/margin_collapse.rs`** (~150 lines)
4. **Tests**: ~300 lines

### Notes File

Create: **`docs/tasks/notes/W3.T04-notes.md`**

Must include:
- Complete algorithm description
- All edge cases discovered
- Performance notes (any slow paths)
- Spec ambiguities and how resolved
- Test coverage map
- Integration notes for W4.T12 (inline layout)

## Common Pitfalls

### Pitfall 1: Not Following CSS 2.1 Exactly

**Wrong:** "This seems simpler..."
**Right:** Implement EXACTLY what CSS 2.1 says, even if it seems weird

### Pitfall 2: Forgetting Margin Collapsing

**Wrong:** Just add margins
**Right:** Use MarginCollapseState for all vertical margins

### Pitfall 3: Not Handling Percentages Correctly

**Wrong:** Always resolving percentages
**Right:** Some percentage heights should become auto if container height is auto

## Verification Checklist

- [ ] All 20+ tests pass
- [ ] Can render simple HTML page
- [ ] Margin collapsing matches browser behavior
- [ ] Width computation handles all CSS 2.1 cases
- [ ] Clippy clean
- [ ] Notes file complete with all edge cases documented

## Time Tracking

- **Width computation:** 3-4hrs
- **Margin collapsing:** 3-4hrs
- **Main layout:** 4-5hrs
- **Testing:** 3hrs
- **Total:** 10-14 hours

This is complex! Take time to get it right. This validates the entire architecture.
