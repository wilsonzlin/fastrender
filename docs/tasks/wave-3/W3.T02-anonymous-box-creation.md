---
task_id: "W3.T02"
title: "Implement Anonymous Box Creation"
wave: 3
estimated_hours: 6-8
depends_on:
  - "W3.T01"
inputs:
  - "docs/tasks/notes/W3.T01-notes.md"
  - "src/tree/box_generation.rs"
outputs:
  - "src/tree/box_generation.rs"
  - "src/tree/anonymous.rs"
  - "tests/tree/test_anonymous_boxes.rs"
  - "docs/tasks/notes/W3.T02-notes.md"
skills_required:
  - "Rust"
  - "CSS box model"
  - "Anonymous box rules"
context_files:
  - "docs/core/box-generation.md"
  - "docs/tasks/notes/W1.R01-notes.md"
verification:
  - "cargo test tree::anonymous"
  - "cargo clippy -- -D warnings"
---

# Implement Anonymous Box Creation

## Context

Anonymous boxes are boxes that don't correspond to any DOM element - they're generated automatically by layout algorithms to satisfy CSS structural rules. They're critical for correct rendering but invisible to the DOM.

This is a **Wave 3 task** that extends W3.T01 (box generation) to handle the complex rules around when and where to insert anonymous boxes.

### Background

**What are Anonymous Boxes?**

From CSS 2.1 Section 9.2.1.1:
> "If a block container box has a block-level box inside it, then we force it to have only block-level boxes inside it."

This means when you mix block and inline content, CSS automatically creates anonymous boxes:

```html
<div>
  Some text
  <p>A paragraph</p>
  More text
</div>
```

Becomes:
```
Block Box (div)
  ├─ Anonymous Block Box
  │  └─ Anonymous Inline Box ("Some text")
  ├─ Block Box (p)
  └─ Anonymous Block Box
     └─ Anonymous Inline Box ("More text")
```

**Types of Anonymous Boxes:**

1. **Anonymous Block Boxes** (CSS 2.1 Section 9.2.1.1)
   - Wrap inline content in block containers
   - Example: Text nodes adjacent to block boxes

2. **Anonymous Inline Boxes** (CSS 2.1 Section 9.2.2.1)
   - Wrap text that isn't in an inline element
   - Example: Raw text in a div

3. **Anonymous Table Boxes** (CSS 2.1 Section 17.2.1)
   - Table rows, row groups, columns
   - Created to fix incomplete table structure

**Why This is Complex:**

- **Context-dependent**: When to create anonymous boxes depends on parent/sibling types
- **Multiple passes**: May need to fixup after initial generation
- **Cascading implications**: Anonymous boxes inherit style but have no DOM source
- **Table special cases**: Tables have many anonymous box requirements

### Why This Matters

Anonymous box creation is consumed by:
- **W3.T01**: Box generation (calls anonymous box creator)
- **W3.T03**: Table structure fixup (uses table anonymous boxes)
- **W3.T04**: Block layout (processes anonymous block boxes)
- **W4.T12**: Inline layout (processes anonymous inline boxes)

Without anonymous boxes:
- Block/inline mixing renders incorrectly
- Tables with incomplete structure break
- Text nodes outside inlines have no box
- CSS spec violations everywhere

## Prerequisites

### Required Knowledge
- **CSS 2.1 Section 9.2.1.1**: Anonymous block boxes
- **CSS 2.1 Section 9.2.2.1**: Anonymous inline boxes
- **CSS 2.1 Section 17.2.1**: Anonymous table boxes
- **Rust tree algorithms**: Tree transformation

### Required Reading
1. **docs/tasks/notes/W3.T01-notes.md**: Box generation algorithm
   - Look for anonymous box integration points
2. **docs/tasks/notes/W1.R01-notes.md**: CSS research
   - Focus on anonymous box sections
3. **docs/core/box-generation.md**: Anonymous box algorithm

## Inputs

### From Dependencies

1. **W3.T01-notes.md** (Box Generation)
   - Look for: Hook points for anonymous box creation
   - Look for: Current box tree structure
   - Look for: Recommendations for anonymous box handling
   - Key insight: Basic generation done, now add fixup pass

### Existing Code

Read these files:
- `src/tree/box_generation.rs` - Extend with anonymous box logic
- `src/tree/box_tree.rs` - Anonymous box types
- `docs/core/box-generation.md` - Complete algorithm

## Objectives

### Primary Goals

1. **Implement anonymous block box creation**: Wrap inline content in block containers
2. **Implement anonymous inline box creation**: Wrap bare text nodes
3. **Implement fixup pass**: Post-process box tree to insert anonymous boxes
4. **Handle block/inline mixing**: Detect and fix mixed content
5. **Handle text nodes**: Wrap in anonymous inline boxes
6. **Preserve style inheritance**: Anonymous boxes inherit from parent
7. **Comprehensive tests**: All anonymous box scenarios

### Success Criteria

- [ ] Anonymous block boxes wrap inline children of block containers
- [ ] Anonymous inline boxes wrap text nodes
- [ ] Block/inline mixing handled correctly
- [ ] Style inheritance works for anonymous boxes
- [ ] fixup_anonymous_boxes() transforms tree correctly
- [ ] At least 20 tests covering all scenarios
- [ ] Tests pass: `cargo test tree::anonymous`
- [ ] Clippy clean
- [ ] Documentation complete
- [ ] Notes file comprehensive

## Implementation Guide

### Step 1: Create Anonymous Box Module (Estimated: 30min)

**Create `src/tree/anonymous.rs`:**

```rust
//! Anonymous box creation
//!
//! Implements CSS anonymous box generation rules.
//!
//! CSS Specification:
//! - CSS 2.1 Section 9.2.1.1 (Anonymous block boxes)
//! - CSS 2.1 Section 9.2.2.1 (Anonymous inline boxes)

use crate::tree::{BoxNode, BoxType, AnonymousBox, AnonymousType, BlockBox, InlineBox, FormattingContextType};
use std::sync::Arc;

/// Creates anonymous boxes in a box tree
pub struct AnonymousBoxCreator;

impl AnonymousBoxCreator {
    /// Fixes up a box tree by inserting anonymous boxes
    ///
    /// This is a post-processing step after initial box generation.
    ///
    /// # CSS 2.1 Section 9.2.1.1
    ///
    /// "If a block container box has a block-level box inside it, then we force
    /// it to have only block-level boxes inside it."
    pub fn fixup_tree(mut box_node: BoxNode) -> BoxNode {
        // First, recursively fix children
        box_node.children = box_node.children
            .into_iter()
            .map(Self::fixup_tree)
            .collect();

        // Then fix this node's children
        box_node.children = Self::fixup_children(box_node.children, &box_node.box_type);

        box_node
    }

    /// Fixes up children by inserting anonymous boxes
    fn fixup_children(children: Vec<BoxNode>, parent_type: &BoxType) -> Vec<BoxNode> {
        match parent_type {
            BoxType::Block(_) => Self::fixup_block_children(children),
            BoxType::Inline(_) => Self::fixup_inline_children(children),
            _ => children,
        }
    }
}
```

**Add to `src/tree/mod.rs`:**
```rust
pub mod anonymous;
pub use anonymous::AnonymousBoxCreator;
```

### Step 2: Implement Block Container Fixup (Estimated: 2-3 hours)

**Add to `src/tree/anonymous.rs`:**

```rust
impl AnonymousBoxCreator {
    /// Fixes up children of block containers
    ///
    /// CSS 2.1 Section 9.2.1.1: Block containers can only contain:
    /// - All block-level boxes, OR
    /// - All inline-level boxes
    ///
    /// If mixed, we create anonymous block boxes to wrap inline content.
    fn fixup_block_children(children: Vec<BoxNode>) -> Vec<BoxNode> {
        if children.is_empty() {
            return children;
        }

        // Check if we have mixed block/inline content
        let has_block = children.iter().any(|c| c.is_block_level());
        let has_inline = children.iter().any(|c| c.is_inline_level());

        if has_block && has_inline {
            // Mixed content - need to wrap inline runs in anonymous blocks
            Self::wrap_inline_runs_in_anonymous_blocks(children)
        } else if !has_block && has_inline {
            // All inline - need to wrap text nodes in anonymous inline boxes
            Self::wrap_text_in_anonymous_inline(children)
        } else {
            // All block or empty - no fixup needed
            children
        }
    }

    /// Wraps consecutive inline boxes in anonymous block boxes
    ///
    /// # Example
    ///
    /// Input: [Text, Text, Block, Inline, Block]
    /// Output: [AnonymousBlock[Text, Text], Block, AnonymousBlock[Inline], Block]
    fn wrap_inline_runs_in_anonymous_blocks(children: Vec<BoxNode>) -> Vec<BoxNode> {
        let mut result = Vec::new();
        let mut inline_run = Vec::new();

        for child in children {
            if child.is_inline_level() {
                // Accumulate inline boxes
                inline_run.push(child);
            } else {
                // Block box - flush inline run if any
                if !inline_run.is_empty() {
                    let anon_block = Self::create_anonymous_block(inline_run);
                    result.push(anon_block);
                    inline_run = Vec::new();
                }
                result.push(child);
            }
        }

        // Flush remaining inline run
        if !inline_run.is_empty() {
            let anon_block = Self::create_anonymous_block(inline_run);
            result.push(anon_block);
        }

        result
    }

    /// Wraps text boxes in anonymous inline boxes
    ///
    /// CSS 2.1 Section 9.2.2.1: Text that is not inside an inline box
    /// is treated as if it were inside an anonymous inline box.
    fn wrap_text_in_anonymous_inline(children: Vec<BoxNode>) -> Vec<BoxNode> {
        children.into_iter().map(|child| {
            if child.is_text() {
                // Wrap text in anonymous inline
                Self::create_anonymous_inline(vec![child])
            } else {
                child
            }
        }).collect()
    }

    /// Creates an anonymous block box
    fn create_anonymous_block(children: Vec<BoxNode>) -> BoxNode {
        // Anonymous boxes inherit style from containing block
        // For now, use default style - will be properly inherited in layout
        let style = Arc::new(crate::style::ComputedStyle::default());

        BoxNode {
            style,
            box_type: BoxType::Anonymous(AnonymousBox {
                anonymous_type: AnonymousType::Block,
            }),
            children,
            debug_info: None,
        }
    }

    /// Creates an anonymous inline box
    fn create_anonymous_inline(children: Vec<BoxNode>) -> BoxNode {
        let style = Arc::new(crate::style::ComputedStyle::default());

        BoxNode {
            style,
            box_type: BoxType::Anonymous(AnonymousBox {
                anonymous_type: AnonymousType::Inline,
            }),
            children,
            debug_info: None,
        }
    }
}
```

### Step 3: Implement Inline Container Fixup (Estimated: 1 hour)

```rust
impl AnonymousBoxCreator {
    /// Fixes up children of inline containers
    ///
    /// Inline boxes should only contain inline-level boxes and text.
    /// If there are block-level boxes, something's wrong (or this is inline-block).
    fn fixup_inline_children(children: Vec<BoxNode>) -> Vec<BoxNode> {
        // Wrap any bare text nodes in anonymous inline boxes
        children.into_iter().map(|child| {
            if child.is_text() {
                Self::create_anonymous_inline(vec![child])
            } else {
                child
            }
        }).collect()
    }
}
```

### Step 4: Integrate with Box Generation (Estimated: 1 hour)

**Update `src/tree/box_generation.rs`:**

```rust
use crate::tree::anonymous::AnonymousBoxCreator;

impl BoxGenerator {
    /// Generates a box tree from a DOM tree with anonymous box fixup
    ///
    /// This is the main entry point that includes anonymous box creation.
    pub fn generate(&self, dom_root: &dyn DomNode) -> Result<BoxNode> {
        // Generate initial box tree
        let box_tree = self.generate_box(dom_root)?;

        // Fix up with anonymous boxes
        let fixed_tree = AnonymousBoxCreator::fixup_tree(box_tree);

        Ok(fixed_tree)
    }
}
```

### Step 5: Write Comprehensive Tests (Estimated: 2-3 hours)

**Create `tests/tree/test_anonymous_boxes.rs`:**

```rust
use fastrender::tree::{BoxGenerator, AnonymousBoxCreator, BoxNode, BoxType, AnonymousType};
use fastrender::style::{ComputedStyle, Display};
use std::sync::Arc;

#[test]
fn test_wrap_inline_in_anonymous_block() {
    // Block container with text → should wrap text in anonymous block
    let text_box = BoxNode::new_text(
        Arc::new(ComputedStyle::default()),
        "Text".to_string(),
    );

    let block_box = BoxNode::new_block(
        Arc::new(ComputedStyle::default()),
        FormattingContextType::Block,
        vec![text_box],
    );

    let fixed = AnonymousBoxCreator::fixup_tree(block_box);

    // Should have one anonymous block child containing the text
    assert_eq!(fixed.children.len(), 1);

    match &fixed.children[0].box_type {
        BoxType::Anonymous(anon) => {
            assert_eq!(anon.anonymous_type, AnonymousType::Block);
            assert_eq!(fixed.children[0].children.len(), 1);
        }
        _ => panic!("Expected anonymous block"),
    }
}

#[test]
fn test_mixed_block_inline_content() {
    // div with: text, p, text
    let text1 = BoxNode::new_text(Arc::new(ComputedStyle::default()), "Text 1".to_string());
    let block = BoxNode::new_block(
        Arc::new(ComputedStyle::default()),
        FormattingContextType::Block,
        vec![],
    );
    let text2 = BoxNode::new_text(Arc::new(ComputedStyle::default()), "Text 2".to_string());

    let container = BoxNode::new_block(
        Arc::new(ComputedStyle::default()),
        FormattingContextType::Block,
        vec![text1, block, text2],
    );

    let fixed = AnonymousBoxCreator::fixup_tree(container);

    // Should have 3 children: anon block, block, anon block
    assert_eq!(fixed.children.len(), 3);

    // First child: anonymous block wrapping text1
    assert!(matches!(fixed.children[0].box_type, BoxType::Anonymous(_)));

    // Second child: original block
    assert!(matches!(fixed.children[1].box_type, BoxType::Block(_)));

    // Third child: anonymous block wrapping text2
    assert!(matches!(fixed.children[2].box_type, BoxType::Anonymous(_)));
}

#[test]
fn test_all_block_children_no_anonymous() {
    // Block container with only block children - no anonymous boxes needed
    let child1 = BoxNode::new_block(
        Arc::new(ComputedStyle::default()),
        FormattingContextType::Block,
        vec![],
    );
    let child2 = BoxNode::new_block(
        Arc::new(ComputedStyle::default()),
        FormattingContextType::Block,
        vec![],
    );

    let container = BoxNode::new_block(
        Arc::new(ComputedStyle::default()),
        FormattingContextType::Block,
        vec![child1, child2],
    );

    let fixed = AnonymousBoxCreator::fixup_tree(container);

    // Should still have 2 children, no wrapping
    assert_eq!(fixed.children.len(), 2);
    assert!(matches!(fixed.children[0].box_type, BoxType::Block(_)));
    assert!(matches!(fixed.children[1].box_type, BoxType::Block(_)));
}

#[test]
fn test_inline_runs_wrapped_together() {
    // Multiple consecutive inline boxes should be wrapped in same anonymous block
    let inline1 = BoxNode::new_inline(Arc::new(ComputedStyle::default()), vec![]);
    let inline2 = BoxNode::new_inline(Arc::new(ComputedStyle::default()), vec![]);
    let block = BoxNode::new_block(
        Arc::new(ComputedStyle::default()),
        FormattingContextType::Block,
        vec![],
    );
    let inline3 = BoxNode::new_inline(Arc::new(ComputedStyle::default()), vec![]);

    let container = BoxNode::new_block(
        Arc::new(ComputedStyle::default()),
        FormattingContextType::Block,
        vec![inline1, inline2, block, inline3],
    );

    let fixed = AnonymousBoxCreator::fixup_tree(container);

    // Should have 3 children: anon[inline1,inline2], block, anon[inline3]
    assert_eq!(fixed.children.len(), 3);

    // First anonymous block should contain 2 inlines
    match &fixed.children[0].box_type {
        BoxType::Anonymous(_) => {
            assert_eq!(fixed.children[0].children.len(), 2);
        }
        _ => panic!("Expected anonymous block"),
    }
}

#[test]
fn test_nested_anonymous_boxes() {
    // Test that fixup works recursively
    let inner_text = BoxNode::new_text(
        Arc::new(ComputedStyle::default()),
        "Inner".to_string(),
    );

    let inner_block = BoxNode::new_block(
        Arc::new(ComputedStyle::default()),
        FormattingContextType::Block,
        vec![inner_text],
    );

    let outer_text = BoxNode::new_text(
        Arc::new(ComputedStyle::default()),
        "Outer".to_string(),
    );

    let outer_block = BoxNode::new_block(
        Arc::new(ComputedStyle::default()),
        FormattingContextType::Block,
        vec![outer_text, inner_block],
    );

    let fixed = AnonymousBoxCreator::fixup_tree(outer_block);

    // Outer level should have 2 children
    assert_eq!(fixed.children.len(), 2);

    // First is anonymous block
    assert!(matches!(fixed.children[0].box_type, BoxType::Anonymous(_)));

    // Second is block with its own anonymous child
    assert!(matches!(fixed.children[1].box_type, BoxType::Block(_)));
    assert_eq!(fixed.children[1].children.len(), 1);
    assert!(matches!(fixed.children[1].children[0].box_type, BoxType::Anonymous(_)));
}

#[test]
fn test_text_in_inline_wrapped() {
    // Text inside inline should be wrapped in anonymous inline
    let text = BoxNode::new_text(
        Arc::new(ComputedStyle::default()),
        "Text".to_string(),
    );

    let inline = BoxNode::new_inline(
        Arc::new(ComputedStyle::default()),
        vec![text],
    );

    let fixed = AnonymousBoxCreator::fixup_tree(inline);

    // Text should be wrapped in anonymous inline
    assert_eq!(fixed.children.len(), 1);
    assert!(matches!(fixed.children[0].box_type, BoxType::Anonymous(_)));
}

#[test]
fn test_empty_container_no_crash() {
    let empty_block = BoxNode::new_block(
        Arc::new(ComputedStyle::default()),
        FormattingContextType::Block,
        vec![],
    );

    let fixed = AnonymousBoxCreator::fixup_tree(empty_block);
    assert_eq!(fixed.children.len(), 0);
}

#[test]
fn test_single_text_node_wrapped() {
    let text = BoxNode::new_text(
        Arc::new(ComputedStyle::default()),
        "Solo text".to_string(),
    );

    let container = BoxNode::new_block(
        Arc::new(ComputedStyle::default()),
        FormattingContextType::Block,
        vec![text],
    );

    let fixed = AnonymousBoxCreator::fixup_tree(container);

    // Text should be in anonymous block
    assert_eq!(fixed.children.len(), 1);
    assert!(matches!(fixed.children[0].box_type, BoxType::Anonymous(_)));
}

// Add 10+ more tests for:
// - Multiple text nodes in sequence
// - Text nodes with whitespace
// - Complex nesting scenarios
// - All inline children (no wrapping needed except text)
// - Replaced elements mixed with inline
// - Edge cases with empty text
```

### Step 6: Documentation and Verification (Estimated: 30min)

Run verification:
```bash
cargo test tree::anonymous
cargo clippy -- -D warnings
cargo fmt
cargo doc --no-deps --open
```

## Testing Requirements

### Unit Tests

**Required tests** (20+ tests):
1. Block container with text → anonymous block
2. Mixed block/inline → anonymous blocks wrap inlines
3. All block children → no anonymous boxes
4. Consecutive inline runs → wrapped together
5. Text in inline → anonymous inline wrapper
6. Nested structures
7. Empty containers
8. Single text node
9. Complex scenarios
10. Edge cases

## Output Artifacts

### Code Files

1. **`src/tree/anonymous.rs`** (~200-300 lines)
   - AnonymousBoxCreator with fixup logic
   - Block/inline fixup methods
   - Anonymous box creation helpers

2. **`tests/tree/test_anonymous_boxes.rs`** (~300-400 lines)
   - 20+ comprehensive tests
   - All anonymous box scenarios

### Notes File

Create: **`docs/tasks/notes/W3.T02-notes.md`**

**Key sections:**
- **API Contracts**: AnonymousBoxCreator::fixup_tree()
- **Decision**: When to create anonymous blocks vs inlines
- **Algorithm**: Block/inline mixing fixup strategy
- **Spec Interpretations**: CSS 2.1 Section 9.2 edge cases
- **Recommendations**: For W3.T03 (table fixup)
- **Recommendations**: For layout FCs (handle anonymous boxes)

## Common Pitfalls to Avoid

### Pitfall 1: Not Wrapping Consecutive Inlines Together

**Wrong:** Wrap each inline separately
**Right:** Group consecutive inlines in one anonymous block

### Pitfall 2: Creating Anonymous Boxes for All-Block Content

**Wrong:** Always create anonymous wrappers
**Right:** Only when mixing block/inline

### Pitfall 3: Forgetting Recursive Fixup

**Wrong:** Only fix top level
**Right:** Recursively fix entire tree

## Verification Checklist

- [ ] All objectives met
- [ ] Block/inline mixing handled
- [ ] Text wrapping works
- [ ] Recursive fixup works
- [ ] Tests pass (20+)
- [ ] Clippy clean
- [ ] Documentation complete
- [ ] Notes file comprehensive

## Time Tracking

- **Module creation:** 30min
- **Block fixup:** 2-3hrs
- **Inline fixup:** 1hr
- **Integration:** 1hr
- **Tests:** 2-3hrs
- **Total:** 6-8 hours

## Getting Help

- CSS 2.1 Sections 9.2.1.1 and 9.2.2.1
- W3.T01 notes for box generation context
- W1.R01 notes for CSS research
- docs/core/box-generation.md for algorithms

Anonymous boxes are subtle but critical. Take time to understand the rules!
