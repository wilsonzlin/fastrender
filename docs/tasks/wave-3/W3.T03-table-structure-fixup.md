---
task_id: "W3.T03"
title: "Implement Table Structure Fixup Algorithm"
wave: 3
estimated_hours: 6-8
depends_on:
  - "W3.T01"
  - "W1.R02"
inputs:
  - "docs/tasks/notes/W3.T01-notes.md"
  - "docs/tasks/notes/W1.R02-notes.md"
  - "src/tree/box_generation.rs"
outputs:
  - "src/tree/table_fixup.rs"
  - "tests/tree/test_table_fixup.rs"
  - "docs/tasks/notes/W3.T03-notes.md"
skills_required:
  - "Rust"
  - "CSS table model"
  - "Tree transformation algorithms"
context_files:
  - "docs/layout/table.md"
  - "docs/tasks/notes/W1.R02-notes.md"
verification:
  - "cargo test tree::table_fixup"
  - "cargo clippy -- -D warnings"
---

# Implement Table Structure Fixup Algorithm

## Context

CSS tables have a highly structured model with specific box requirements. When HTML tables are incomplete (missing rows, cells not in rows, etc.), CSS requires automatic generation of anonymous table boxes to complete the structure. This task implements that fixup algorithm.

This is a **Wave 3 task** that specializes box generation for tables, ensuring all tables have proper structure before layout.

### Background

**CSS Table Structure:**

From CSS 2.1 Section 17.2:
> "The table wrapper box contains the table box itself and any caption boxes."

Complete table structure:
```
Table Wrapper Box
  ├─ Caption Box(es) (optional)
  └─ Table Grid Box
     ├─ Column Group Box (optional)
     │  └─ Column Box(es)
     ├─ Row Group Box (thead, tbody, tfoot)
     │  └─ Row Box
     │     └─ Cell Box(es)
```

**Anonymous Box Requirements:**

CSS 2.1 Section 17.2.1 defines 6 cases requiring anonymous boxes:

1. **Missing table row group**: If table has cells/rows not in row-group → create anonymous row-group
2. **Missing table row**: If row-group has cells not in row → create anonymous row
3. **Missing table cell**: If row has non-cell content → wrap in anonymous cell
4. **Missing column**: Columns are inferred from cells
5. **Table wrapper**: Generated to contain table and captions
6. **Mixed content**: Non-table children wrapped appropriately

**The Algorithm** (from spec):
```
1. If table has children that are not caption/colgroup/rowgroup/row/cell:
   → Wrap in anonymous cell → anonymous row → anonymous row-group

2. If table has rows/cells not in row-groups:
   → Wrap in anonymous row-group (tbody)

3. If row-group has cells not in rows:
   → Wrap in anonymous row

4. For each row, infer column count from cells (accounting for colspan)

5. Create table wrapper if captions exist
```

**Why This is Complex:**

- **Multiple passes**: Need to fix at different levels
- **Colspan/rowspan**: Affect column inference
- **Order matters**: thead/tbody/tfoot have specific ordering
- **Missing vs. anonymous**: Different cases need different fixes

### Why This Matters

Table fixup is consumed by:
- **W3.T06**: Table layout algorithm (requires proper structure)
- **W3.T07**: Table column algorithm (needs accurate column structure)
- **W2.T10**: Layout engine (dispatches fixed tables to table FC)

Without table fixup:
- Incomplete tables fail to layout
- Column widths calculated incorrectly
- Cells positioned wrong
- Tables with <td> but no <tr> break

## Prerequisites

### Required Knowledge
- **CSS 2.1 Chapter 17**: Tables
- **CSS Tables Module Level 3**: Table structure
- **CSS anonymous boxes**: Section 17.2.1
- **Tree transformation algorithms**

### Required Reading
1. **docs/tasks/notes/W1.R02-notes.md**: Table layout research
   - Focus on anonymous box requirements
2. **docs/tasks/notes/W3.T01-notes.md**: Box generation
   - Look for table box creation
3. **docs/layout/table.md**: Table structure section

## Inputs

### From Dependencies

1. **W3.T01-notes.md** (Box Generation)
   - Look for: How tables are initially generated
   - Look for: Integration points for fixup
   - Key insight: Fixup is post-processing step

2. **W1.R02-notes.md** (Table Research)
   - Look for: Complete anonymous box rules
   - Look for: Table structure requirements
   - **Critical**: Follow spec exactly

### Existing Code

Read these files:
- `src/tree/box_generation.rs` - Will call table fixup
- `src/tree/box_tree.rs` - Table box types
- `docs/layout/table.md` - Complete algorithm

## Objectives

### Primary Goals

1. **Implement table structure validator**: Check if table structure is complete
2. **Implement row group fixup**: Create anonymous tbody for rows not in groups
3. **Implement row fixup**: Create anonymous rows for cells not in rows
4. **Implement cell fixup**: Wrap non-cell content in anonymous cells
5. **Implement column inference**: Determine column count from cells
6. **Implement wrapper generation**: Create table wrapper for tables with captions
7. **Comprehensive tests**: All table structure scenarios

### Success Criteria

- [ ] Incomplete table structures fixed automatically
- [ ] Missing row groups (tbody) generated
- [ ] Missing rows generated
- [ ] Non-cell content wrapped in anonymous cells
- [ ] Column count correctly inferred (with colspan)
- [ ] Table wrappers created when needed
- [ ] At least 20 tests covering all scenarios
- [ ] Tests pass: `cargo test tree::table_fixup`
- [ ] Clippy clean
- [ ] Notes file comprehensive

## Implementation Guide

### Step 1: Create Table Fixup Module (Estimated: 30min)

**Create `src/tree/table_fixup.rs`:**

```rust
//! Table structure fixup
//!
//! Ensures all tables have complete structure required by CSS spec.
//!
//! CSS Specification: CSS 2.1 Section 17.2.1
//! https://www.w3.org/TR/CSS21/tables.html#anonymous-boxes

use crate::tree::{BoxNode, BoxType, AnonymousBox, AnonymousType};
use crate::error::Result;
use std::sync::Arc;

/// Table structure fixer
///
/// Transforms incomplete table structures into complete ones by
/// inserting anonymous boxes as required by CSS 2.1 Section 17.2.1.
pub struct TableStructureFixer;

impl TableStructureFixer {
    /// Fixes up a table box tree
    ///
    /// Takes a box tree that may have incomplete table structure
    /// and returns a tree with all required anonymous boxes.
    ///
    /// # CSS Requirements
    ///
    /// 1. Table must contain row groups (thead, tbody, tfoot)
    /// 2. Row groups must contain rows
    /// 3. Rows must contain cells
    /// 4. Tables with captions need wrapper boxes
    pub fn fixup_table(table_box: BoxNode) -> Result<BoxNode> {
        // Verify this is actually a table
        if !Self::is_table_box(&table_box) {
            return Ok(table_box);
        }

        // Fix table structure
        let mut fixed = table_box;

        // Step 1: Wrap cells not in rows with anonymous rows
        fixed = Self::ensure_cells_in_rows(fixed)?;

        // Step 2: Wrap rows not in row-groups with anonymous tbody
        fixed = Self::ensure_rows_in_groups(fixed)?;

        // Step 3: Infer column structure
        fixed = Self::infer_columns(fixed)?;

        // Step 4: Create table wrapper if needed (captions)
        fixed = Self::create_wrapper_if_needed(fixed)?;

        Ok(fixed)
    }

    /// Checks if a box is a table box
    fn is_table_box(box_node: &BoxNode) -> bool {
        match &box_node.box_type {
            BoxType::Block(block) => {
                matches!(block.formatting_context, FormattingContextType::Table)
            }
            _ => false,
        }
    }
}
```

**Add to `src/tree/mod.rs`:**
```rust
pub mod table_fixup;
pub use table_fixup::TableStructureFixer;
```

### Step 2: Implement Cell-to-Row Fixup (Estimated: 1.5 hours)

```rust
impl TableStructureFixer {
    /// Ensures all cells are inside rows
    ///
    /// CSS 2.1 Section 17.2.1: "If a row group has cells not in a row,
    /// generate an anonymous row around those cells."
    fn ensure_cells_in_rows(mut table: BoxNode) -> Result<BoxNode> {
        let children = std::mem::take(&mut table.children);
        let fixed_children = Self::fixup_table_children_for_rows(children)?;
        table.children = fixed_children;
        Ok(table)
    }

    /// Fixes children to ensure cells are in rows
    fn fixup_table_children_for_rows(children: Vec<BoxNode>) -> Result<Vec<BoxNode>> {
        let mut result = Vec::new();
        let mut loose_cells = Vec::new();

        for child in children {
            if Self::is_table_cell(&child) {
                // Accumulate loose cells
                loose_cells.push(child);
            } else if Self::is_table_row_group(&child) {
                // Flush loose cells first
                if !loose_cells.is_empty() {
                    let anon_row = Self::create_anonymous_row(loose_cells)?;
                    result.push(anon_row);
                    loose_cells = Vec::new();
                }

                // Recursively fix row group
                let fixed_group = Self::fixup_row_group(child)?;
                result.push(fixed_group);
            } else if Self::is_table_row(&child) {
                // Flush loose cells
                if !loose_cells.is_empty() {
                    let anon_row = Self::create_anonymous_row(loose_cells)?;
                    result.push(anon_row);
                    loose_cells = Vec::new();
                }
                result.push(child);
            } else {
                // Other content (caption, colgroup) - pass through
                if !loose_cells.is_empty() {
                    let anon_row = Self::create_anonymous_row(loose_cells)?;
                    result.push(anon_row);
                    loose_cells = Vec::new();
                }
                result.push(child);
            }
        }

        // Flush remaining loose cells
        if !loose_cells.is_empty() {
            let anon_row = Self::create_anonymous_row(loose_cells)?;
            result.push(anon_row);
        }

        Ok(result)
    }

    /// Fixes row group to ensure cells are in rows
    fn fixup_row_group(mut group: BoxNode) -> Result<BoxNode> {
        let children = std::mem::take(&mut group.children);
        let mut result = Vec::new();
        let mut loose_cells = Vec::new();

        for child in children {
            if Self::is_table_cell(&child) {
                loose_cells.push(child);
            } else if Self::is_table_row(&child) {
                if !loose_cells.is_empty() {
                    let anon_row = Self::create_anonymous_row(loose_cells)?;
                    result.push(anon_row);
                    loose_cells = Vec::new();
                }
                result.push(child);
            } else {
                // Unexpected content - wrap in anonymous cell then row
                if !loose_cells.is_empty() {
                    let anon_row = Self::create_anonymous_row(loose_cells)?;
                    result.push(anon_row);
                    loose_cells = Vec::new();
                }

                let anon_cell = Self::create_anonymous_cell(vec![child])?;
                loose_cells.push(anon_cell);
            }
        }

        if !loose_cells.is_empty() {
            let anon_row = Self::create_anonymous_row(loose_cells)?;
            result.push(anon_row);
        }

        group.children = result;
        Ok(group)
    }

    /// Creates an anonymous table row
    fn create_anonymous_row(cells: Vec<BoxNode>) -> Result<BoxNode> {
        let style = Arc::new(ComputedStyle::default());

        Ok(BoxNode {
            style,
            box_type: BoxType::Anonymous(AnonymousBox {
                anonymous_type: AnonymousType::TableRow,
            }),
            children: cells,
            debug_info: None,
        })
    }
}
```

### Step 3: Implement Row-to-Group Fixup (Estimated: 1.5 hours)

```rust
impl TableStructureFixer {
    /// Ensures all rows are inside row groups
    ///
    /// CSS 2.1 Section 17.2.1: "If a table has rows not in a row group,
    /// generate an anonymous tbody around those rows."
    fn ensure_rows_in_groups(mut table: BoxNode) -> Result<BoxNode> {
        let children = std::mem::take(&mut table.children);
        let fixed_children = Self::wrap_loose_rows(children)?;
        table.children = fixed_children;
        Ok(table)
    }

    /// Wraps loose rows in anonymous tbody
    fn wrap_loose_rows(children: Vec<BoxNode>) -> Result<Vec<BoxNode>> {
        let mut result = Vec::new();
        let mut loose_rows = Vec::new();

        for child in children {
            if Self::is_table_row(&child) {
                // Accumulate loose rows
                loose_rows.push(child);
            } else if Self::is_table_row_group(&child) {
                // Flush loose rows first
                if !loose_rows.is_empty() {
                    let anon_tbody = Self::create_anonymous_row_group(loose_rows)?;
                    result.push(anon_tbody);
                    loose_rows = Vec::new();
                }
                result.push(child);
            } else {
                // Caption, colgroup, etc. - pass through
                if !loose_rows.is_empty() {
                    let anon_tbody = Self::create_anonymous_row_group(loose_rows)?;
                    result.push(anon_tbody);
                    loose_rows = Vec::new();
                }
                result.push(child);
            }
        }

        // Flush remaining loose rows
        if !loose_rows.is_empty() {
            let anon_tbody = Self::create_anonymous_row_group(loose_rows)?;
            result.push(anon_tbody);
        }

        Ok(result)
    }

    /// Creates an anonymous table row group (tbody)
    fn create_anonymous_row_group(rows: Vec<BoxNode>) -> Result<BoxNode> {
        let style = Arc::new(ComputedStyle::default());

        Ok(BoxNode {
            style,
            box_type: BoxType::Anonymous(AnonymousBox {
                anonymous_type: AnonymousType::TableRowGroup,
            }),
            children: rows,
            debug_info: None,
        })
    }
}
```

### Step 4: Implement Type Checkers (Estimated: 30min)

```rust
impl TableStructureFixer {
    /// Checks if box is a table row
    fn is_table_row(box_node: &BoxNode) -> bool {
        // Check display: table-row or anonymous table row
        matches!(&box_node.box_type,
            BoxType::Anonymous(anon) if anon.anonymous_type == AnonymousType::TableRow
        )
        // TODO: Also check for display: table-row when that's implemented
    }

    /// Checks if box is a table cell
    fn is_table_cell(box_node: &BoxNode) -> bool {
        // Check display: table-cell or anonymous table cell
        matches!(&box_node.box_type,
            BoxType::Anonymous(anon) if anon.anonymous_type == AnonymousType::TableCell
        )
        // TODO: Also check for display: table-cell
    }

    /// Checks if box is a table row group
    fn is_table_row_group(box_node: &BoxNode) -> bool {
        // Check for tbody, thead, tfoot
        matches!(&box_node.box_type,
            BoxType::Anonymous(anon) if anon.anonymous_type == AnonymousType::TableRowGroup
        )
        // TODO: Also check for display: table-row-group
    }

    /// Creates an anonymous table cell
    fn create_anonymous_cell(children: Vec<BoxNode>) -> Result<BoxNode> {
        let style = Arc::new(ComputedStyle::default());

        Ok(BoxNode {
            style,
            box_type: BoxType::Anonymous(AnonymousBox {
                anonymous_type: AnonymousType::TableCell,
            }),
            children,
            debug_info: None,
        })
    }
}
```

### Step 5: Implement Column Inference (Estimated: 1 hour)

```rust
impl TableStructureFixer {
    /// Infers column structure from cells
    ///
    /// CSS tables don't require explicit <col> elements - columns
    /// are inferred from the cells in the first row.
    fn infer_columns(table: BoxNode) -> Result<BoxNode> {
        // Find all row groups
        let row_groups: Vec<&BoxNode> = table.children.iter()
            .filter(|c| Self::is_table_row_group(c))
            .collect();

        if row_groups.is_empty() {
            return Ok(table);
        }

        // Find first row
        let first_row = row_groups[0].children.first();
        if let Some(row) = first_row {
            // Count columns from first row's cells (accounting for colspan)
            let col_count = Self::count_columns(row);

            // Store column count in table metadata
            // (For now, just validate we can count columns)
            if col_count == 0 {
                return Err(Error::Layout("Table has no columns".into()));
            }
        }

        Ok(table)
    }

    /// Counts columns in a row (accounting for colspan)
    fn count_columns(row: &BoxNode) -> usize {
        row.children.iter()
            .map(|cell| {
                // TODO: Get colspan from cell style
                // For now, assume colspan=1
                1
            })
            .sum()
    }
}
```

### Step 6: Implement Wrapper Creation (Estimated: 1 hour)

```rust
impl TableStructureFixer {
    /// Creates table wrapper if needed
    ///
    /// CSS 2.1: Tables with captions need a wrapper box
    fn create_wrapper_if_needed(table: BoxNode) -> Result<BoxNode> {
        // Check if table has any captions
        let has_caption = table.children.iter()
            .any(|c| Self::is_table_caption(c));

        if has_caption {
            // Create wrapper containing table and captions
            let style = Arc::new(ComputedStyle::default());

            Ok(BoxNode {
                style,
                box_type: BoxType::Anonymous(AnonymousBox {
                    anonymous_type: AnonymousType::TableWrapper,
                }),
                children: vec![table],
                debug_info: None,
            })
        } else {
            Ok(table)
        }
    }

    /// Checks if box is a table caption
    fn is_table_caption(_box_node: &BoxNode) -> bool {
        // TODO: Check for display: table-caption
        false
    }
}
```

### Step 7: Write Comprehensive Tests (Estimated: 2 hours)

**Create `tests/tree/test_table_fixup.rs`:**

```rust
use fastrender::tree::{TableStructureFixer, BoxNode, BoxType, AnonymousType};
use fastrender::style::ComputedStyle;
use std::sync::Arc;

// Helper to create table structure components
mod helpers {
    use super::*;

    pub fn table() -> BoxNode {
        BoxNode::new_block(
            Arc::new(ComputedStyle::default()),
            FormattingContextType::Table,
            vec![],
        )
    }

    pub fn row(cells: Vec<BoxNode>) -> BoxNode {
        let style = Arc::new(ComputedStyle::default());
        BoxNode {
            style,
            box_type: BoxType::Anonymous(AnonymousBox {
                anonymous_type: AnonymousType::TableRow,
            }),
            children: cells,
            debug_info: None,
        }
    }

    pub fn cell(content: Vec<BoxNode>) -> BoxNode {
        let style = Arc::new(ComputedStyle::default());
        BoxNode {
            style,
            box_type: BoxType::Anonymous(AnonymousBox {
                anonymous_type: AnonymousType::TableCell,
            }),
            children: content,
            debug_info: None,
        }
    }
}

use helpers::*;

#[test]
fn test_table_with_loose_cells() {
    // Table with cells not in rows
    let cell1 = cell(vec![]);
    let cell2 = cell(vec![]);

    let table = table().with_children(vec![cell1, cell2]);

    let fixed = TableStructureFixer::fixup_table(table).unwrap();

    // Cells should be wrapped in anonymous row
    assert_eq!(fixed.children.len(), 1);
    assert!(matches!(
        fixed.children[0].box_type,
        BoxType::Anonymous(AnonymousBox {
            anonymous_type: AnonymousType::TableRow
        })
    ));
    assert_eq!(fixed.children[0].children.len(), 2);
}

#[test]
fn test_table_with_loose_rows() {
    // Table with rows not in row group
    let row1 = row(vec![cell(vec![])]);
    let row2 = row(vec![cell(vec![])]);

    let table = table().with_children(vec![row1, row2]);

    let fixed = TableStructureFixer::fixup_table(table).unwrap();

    // Rows should be wrapped in anonymous tbody
    assert_eq!(fixed.children.len(), 1);
    // Should be anonymous row group
    assert_eq!(fixed.children[0].children.len(), 2);
}

#[test]
fn test_complete_table_no_fixup() {
    // Table with proper structure - no fixup needed
    let tbody = BoxNode::new_anonymous_row_group(
        Arc::new(ComputedStyle::default()),
        vec![
            row(vec![cell(vec![]), cell(vec![])]),
        ],
    );

    let table = table().with_children(vec![tbody]);

    let fixed = TableStructureFixer::fixup_table(table).unwrap();

    // Should remain unchanged
    assert_eq!(fixed.children.len(), 1);
}

// Add 15+ more tests for:
// - Mixed loose rows and row groups
// - Cells in row group but not in row
// - Multiple row groups
// - Empty table
// - Table with captions (wrapper needed)
// - Column inference
// - Complex nested scenarios
```

### Step 8: Integration and Verification (Estimated: 30min)

**Update `src/tree/box_generation.rs`:**

```rust
use crate::tree::table_fixup::TableStructureFixer;

impl BoxGenerator {
    pub fn generate(&self, dom_root: &dyn DomNode) -> Result<BoxNode> {
        let box_tree = self.generate_box(dom_root)?;

        // Fix up anonymous boxes
        let fixed_tree = AnonymousBoxCreator::fixup_tree(box_tree);

        // Fix up table structures
        let final_tree = TableStructureFixer::fixup_table(fixed_tree)?;

        Ok(final_tree)
    }
}
```

Run verification:
```bash
cargo test tree::table_fixup
cargo clippy -- -D warnings
cargo fmt
```

## Testing Requirements

**Required tests** (20+ tests):
1. Loose cells wrapped in anonymous row
2. Loose rows wrapped in anonymous tbody
3. Complete table (no fixup)
4. Mixed scenarios
5. Nested fixups
6. Empty tables
7. Table with captions
8. Column inference
9. Error handling

## Output Artifacts

### Code Files

1. **`src/tree/table_fixup.rs`** (~300-400 lines)
2. **`tests/tree/test_table_fixup.rs`** (~300-400 lines)

### Notes File

Create: **`docs/tasks/notes/W3.T03-notes.md`**

**Key sections:**
- Algorithm details
- Anonymous box insertion rules
- Integration with W3.T06 (table layout)
- Edge cases discovered

## Verification Checklist

- [ ] All table fixup cases handled
- [ ] Anonymous rows/groups generated
- [ ] Column inference works
- [ ] Tests pass (20+)
- [ ] Notes comprehensive

## Time Tracking

- Module creation: 30min
- Cell/row fixup: 3hrs
- Column inference: 1hr
- Tests: 2hrs
- Total: 6-8 hours

## Getting Help

- CSS 2.1 Chapter 17
- W1.R02 notes for table research
- W3.T01 notes for integration

Tables are the most complex CSS feature. Take time to understand the structure!
