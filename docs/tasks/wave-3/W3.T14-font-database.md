---
task_id: "W3.T14"
title: "Implement Font Database and Loading System"
wave: 3
estimated_hours: 8-10
depends_on:
  - "W1.T02"
inputs:
  - "outputs/notes/W1.T02-notes.md"
outputs:
  - "src/text/font_db.rs"
  - "src/text/font_loader.rs"
  - "src/text/mod.rs"
  - "outputs/notes/W3.T14-notes.md"
skills_required:
  - "Rust"
  - "Font file formats"
  - "External library integration (fontdb)"
context_files:
  - "docs/plan/03-font-system.md"
verification:
  - "cargo test text::font_db"
  - "Can load system fonts"
  - "Can query font by family/weight/style"
---

# Implement Font Database and Loading System

## Context

Text rendering requires fonts. The font system must:
1. Discover system fonts
2. Load font files (TTF, OTF, WOFF)
3. Query fonts by family, weight, style
4. Provide fallback chains
5. Cache loaded fonts

We'll use **fontdb** crate to handle font discovery and loading, wrapping it in our API.

### Background

**Font Matching:**

CSS font-family: "Arial, Helvetica, sans-serif" means:
1. Try to find "Arial"
2. If not found, try "Helvetica"
3. If not found, use generic sans-serif
4. Also match weight (100-900) and style (normal, italic, oblique)

**Font Files:**

- **TrueType (.ttf)**: Most common
- **OpenType (.otf)**: Modern format
- **WOFF/WOFF2**: Web fonts
- **Collection (.ttc)**: Multiple fonts in one file

**System Fonts:**

- Windows: C:\\Windows\\Fonts
- macOS: /Library/Fonts, /System/Library/Fonts
- Linux: /usr/share/fonts, ~/.fonts

### Why This Matters

Font database is consumed by:
- **W4.T03**: Text shaper (needs font files)
- **W3.T16**: Font metrics (needs font data)
- **W4.T12**: Inline layout (needs metrics for sizing)

Without fonts:
- Can't render text
- Can't measure text for layout
- Can't do proper inline layout

## Prerequisites

### Required Knowledge
- **Font concepts**: Family, weight, style, fallbacks
- **Rust**: File I/O, caching patterns, Arc usage
- **fontdb crate**: Basic API

### Required Reading
1. **fontdb documentation**: https://docs.rs/fontdb/
2. **CSS Fonts Module Level 3**: Font matching algorithm
3. **docs/plan/03-font-system.md**: Our font system design

## Objectives

### Primary Goals

1. **Wrap fontdb**: Create FontDatabase struct wrapping fontdb::Database
2. **System font loading**: Load all system fonts on startup
3. **Font querying**: Query by family/weight/style
4. **Font loading**: Load font data into memory
5. **Caching**: Cache loaded font data
6. **Fallback chains**: Handle font-family lists
7. **Generic families**: Map sans-serif, serif, monospace to system fonts

### Success Criteria

- [ ] FontDatabase wraps fontdb
- [ ] Can load system fonts
- [ ] Can query font by family name
- [ ] Can query with weight/style matching
- [ ] Returns best match (not just exact match)
- [ ] Font data is cached (Arc-ed)
- [ ] Fallback chains work
- [ ] Tests verify font loading and querying
- [ ] Handles missing fonts gracefully

## Implementation Guide

### Step 1: Add fontdb Dependency (Estimated: 15min)

**Cargo.toml:**
```toml
[dependencies]
fontdb = "0.16"
```

### Step 2: Create Font Database Wrapper (Estimated: 2-3 hours)

**`src/text/font_db.rs`:**
```rust
//! Font database - font discovery and loading

use fontdb::{Database as FontDbDatabase, ID, Query, Family};
use std::sync::{Arc, RwLock};
use std::collections::HashMap;

/// Font weight (100-900)
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub struct FontWeight(pub u16);

impl FontWeight {
    pub const THIN: Self = Self(100);
    pub const EXTRA_LIGHT: Self = Self(200);
    pub const LIGHT: Self = Self(300);
    pub const NORMAL: Self = Self(400);
    pub const MEDIUM: Self = Self(500);
    pub const SEMI_BOLD: Self = Self(600);
    pub const BOLD: Self = Self(700);
    pub const EXTRA_BOLD: Self = Self(800);
    pub const BLACK: Self = Self(900);
}

/// Font style
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum FontStyle {
    Normal,
    Italic,
    Oblique,
}

/// Font stretch (width variants)
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum FontStretch {
    Normal,
    Condensed,
    Expanded,
}

/// A loaded font
#[derive(Debug, Clone)]
pub struct LoadedFont {
    /// Font data (shared)
    pub data: Arc<Vec<u8>>,
    /// Font index in file (for TTC collections)
    pub index: u32,
    /// Font family name
    pub family: String,
    /// Weight
    pub weight: FontWeight,
    /// Style
    pub style: FontStyle,
}

/// Font database
///
/// Wraps fontdb and provides font loading and querying.
pub struct FontDatabase {
    /// Underlying fontdb database
    db: FontDbDatabase,
    /// Cached font data
    cache: RwLock<HashMap<ID, Arc<Vec<u8>>>>,
}

impl FontDatabase {
    /// Creates a new font database and loads system fonts
    pub fn new() -> Self {
        let mut db = FontDbDatabase::new();
        db.load_system_fonts();
        
        Self {
            db,
            cache: RwLock::new(HashMap::new()),
        }
    }
    
    /// Queries for a font matching the given criteria
    ///
    /// Returns the best match, or None if no fonts found.
    pub fn query(
        &self,
        family: &str,
        weight: FontWeight,
        style: FontStyle,
    ) -> Option<ID> {
        let query = Query {
            families: &[Family::Name(family)],
            weight: fontdb::Weight(weight.0),
            style: match style {
                FontStyle::Normal => fontdb::Style::Normal,
                FontStyle::Italic => fontdb::Style::Italic,
                FontStyle::Oblique => fontdb::Style::Oblique,
            },
            stretch: fontdb::Stretch::Normal,
        };
        
        self.db.query(&query)
    }
    
    /// Loads font data for a given font ID
    ///
    /// Caches the data for reuse.
    pub fn load_font(&self, id: ID) -> Option<LoadedFont> {
        // Check cache first
        {
            let cache = self.cache.read().unwrap();
            if let Some(data) = cache.get(&id) {
                return Some(self.create_loaded_font(id, data.clone()));
            }
        }
        
        // Load from file
        let face = self.db.face(id)?;
        let data = std::fs::read(&face.source.path).ok()?;
        let data = Arc::new(data);
        
        // Cache it
        {
            let mut cache = self.cache.write().unwrap();
            cache.insert(id, data.clone());
        }
        
        Some(self.create_loaded_font(id, data))
    }
    
    fn create_loaded_font(&self, id: ID, data: Arc<Vec<u8>>) -> LoadedFont {
        let face = self.db.face(id).unwrap();
        
        LoadedFont {
            data,
            index: face.index,
            family: face.families[0].0.clone(),
            weight: FontWeight(face.weight.0),
            style: match face.style {
                fontdb::Style::Normal => FontStyle::Normal,
                fontdb::Style::Italic => FontStyle::Italic,
                fontdb::Style::Oblique => FontStyle::Oblique,
            },
        }
    }
    
    /// Resolves a font family list with fallbacks
    ///
    /// Returns the first available font in the list.
    pub fn resolve_family_list(
        &self,
        families: &[String],
        weight: FontWeight,
        style: FontStyle,
    ) -> Option<ID> {
        for family in families {
            if let Some(id) = self.query(family, weight, style) {
                return Some(id);
            }
        }
        
        // Fallback to default
        self.query("sans-serif", weight, style)
    }
}

impl Default for FontDatabase {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_load_system_fonts() {
        let db = FontDatabase::new();
        // Should have loaded at least one font
        // (Exact count varies by system)
    }
    
    #[test]
    fn test_query_common_font() {
        let db = FontDatabase::new();
        
        // Try to find a common font (Arial on Windows, Helvetica on Mac, etc.)
        let id = db.query("Arial", FontWeight::NORMAL, FontStyle::Normal)
            .or_else(|| db.query("Helvetica", FontWeight::NORMAL, FontStyle::Normal))
            .or_else(|| db.query("sans-serif", FontWeight::NORMAL, FontStyle::Normal));
        
        assert!(id.is_some(), "Should find at least one sans-serif font");
    }
    
    #[test]
    fn test_load_font_data() {
        let db = FontDatabase::new();
        
        let id = db.query("sans-serif", FontWeight::NORMAL, FontStyle::Normal)
            .expect("Should have sans-serif font");
        
        let font = db.load_font(id).expect("Should load font");
        assert!(!font.data.is_empty());
    }
    
    #[test]
    fn test_fallback_chain() {
        let db = FontDatabase::new();
        
        let families = vec![
            "NonexistentFont".to_string(),
            "AnotherFakeFont".to_string(),
            "sans-serif".to_string(),
        ];
        
        let id = db.resolve_family_list(&families, FontWeight::NORMAL, FontStyle::Normal);
        assert!(id.is_some(), "Should fall back to sans-serif");
    }
}
```

### Step 3: Create Font Loader Module (Estimated: 1-2 hours)

**`src/text/font_loader.rs`:**
```rust
//! Font loading utilities

use crate::text::font_db::{FontDatabase, LoadedFont};
use std::sync::Arc;

/// Font context for text operations
///
/// Holds the font database and provides convenient access.
pub struct FontContext {
    db: Arc<FontDatabase>,
}

impl FontContext {
    /// Creates a new font context
    pub fn new() -> Self {
        Self {
            db: Arc::new(FontDatabase::new()),
        }
    }
    
    /// Gets a reference to the font database
    pub fn database(&self) -> &FontDatabase {
        &self.db
    }
}

impl Default for FontContext {
    fn default() -> Self {
        Self::new()
    }
}
```

### Step 4: Module Organization (Estimated: 30min)

**`src/text/mod.rs`:**
```rust
//! Text system

pub mod font_db;
pub mod font_loader;

pub use font_db::{FontDatabase, LoadedFont, FontWeight, FontStyle};
pub use font_loader::FontContext;
```

## Testing Requirements

Run: `cargo test text::font_db`

Tests should verify:
- System fonts load
- Can query fonts
- Can load font data
- Fallback chains work

## Output Artifacts

### Code Files

1. **`src/text/font_db.rs`** (~300 lines)
2. **`src/text/font_loader.rs`** (~50 lines)
3. **Tests**: Inline

### Notes File

Create: **`outputs/notes/W3.T14-notes.md`**

Must document:
- API for querying fonts
- How caching works
- Font matching algorithm
- Platform differences
- Integration with W4.T03 (text shaping)

## Common Pitfalls

### Pitfall 1: Not Caching Font Data

**Wrong:** Loading font file every time
**Right:** Cache in HashMap with Arc

### Pitfall 2: Exact Matching Only

**Wrong:** Return None if exact match not found
**Right:** Use fontdb's fuzzy matching (weight/style nearby)

## Verification Checklist

- [ ] System fonts load
- [ ] Can query and load fonts
- [ ] Tests pass
- [ ] Notes document API

## Time Tracking

- **fontdb wrapping:** 2-3hrs
- **Caching:** 1hr
- **Testing:** 2hrs
- **Integration:** 2hrs
- **Total:** 8-10 hours
