---
task_id: "W3.T06"
title: "Implement Table Layout Algorithm"
wave: 3
estimated_hours: 12-16
depends_on:
  - "W2.T07"
  - "W1.R02"
inputs:
  - "docs/tasks/notes/W2.T07-notes.md"
  - "docs/tasks/notes/W1.R02-notes.md"
  - "src/layout/contexts/mod.rs"
outputs:
  - "src/layout/contexts/table.rs"
  - "src/layout/contexts/table/structure.rs"
  - "src/layout/contexts/table/width.rs"
  - "tests/layout/test_table_layout.rs"
  - "docs/tasks/notes/W3.T06-notes.md"
skills_required:
  - "Rust"
  - "CSS table layout"
  - "Complex algorithm implementation"
context_files:
  - "docs/layout/table.md"
  - "docs/tasks/notes/W1.R02-notes.md"
verification:
  - "cargo test layout::table"
  - "cargo clippy -- -D warnings"
---

# Implement Table Layout Algorithm

## Context

Table layout is THE most complex layout algorithm in CSS. It requires analyzing the entire table structure (rows, columns, cells) before computing any dimensions, with bidirectional constraints between width and height.

This is a **critical Wave 3 task** - one of the hardest layout implementations.

### Background

**CSS Table Algorithm:**

From CSS 2.1 Chapter 17 and CSS Tables Module Level 3:

**Three-phase algorithm:**
1. **Structure analysis**: Build internal table representation (rows, columns, cells with spans)
2. **Width computation**: Distribute table width to columns (fixed or auto algorithm)
3. **Height computation**: Distribute heights to rows, position cells

**Fixed Table Layout** (CSS 2.1 Section 17.5.2.1):
- Fast, predictable
- Uses first row to determine column widths
- Width = specified width or intrinsic content width

**Auto Table Layout** (CSS 2.1 Section 17.5.2.2):
- More complex but flexible
- Considers all cells in each column
- Distributes extra space proportionally

**Complexity Factors:**
- **Colspan/rowspan**: Cells can span multiple rows/columns
- **Percentage widths**: Relative to table width (circular dependency)
- **Min/max widths**: Cells have minimum and maximum content widths
- **Border collapse**: Complex border resolution between cells

### Why This Matters

Table layout is consumed by:
- **W2.T10**: LayoutEngine (dispatches table boxes)
- **W3.T07**: Table column algorithm (column width distribution)
- **All tables in HTML**: Almost every website uses tables

Without table layout:
- Tables render incorrectly
- Column widths wrong
- Cells overflow
- Major WPT failures

## Prerequisites

### Required Knowledge
- **CSS 2.1 Chapter 17**: Complete table specification
- **CSS Tables Module Level 3**: Modern table features
- **Bidirectional constraints**: Width affects height and vice versa

### Required Reading
1. **docs/tasks/notes/W1.R02-notes.md**: Table layout research
2. **docs/tasks/notes/W2.T07-notes.md**: FormattingContext trait
3. **docs/layout/table.md**: Complete implementation guide

## Inputs

### From Dependencies

1. **W2.T07-notes.md** (FC Trait)
   - Look for: Trait implementation requirements
   - Key insight: Tables implement FormattingContext

2. **W1.R02-notes.md** (Table Research)
   - Look for: Fixed vs auto layout algorithms
   - Look for: Pseudocode for width distribution
   - **Critical**: Follow spec algorithms exactly

## Objectives

### Primary Goals

1. **Implement TableFormattingContext**: Implements FormattingContext trait
2. **Implement table structure analysis**: Build TableStructure from box tree
3. **Implement fixed table layout**: Fast algorithm using first row
4. **Implement auto table layout**: Full algorithm analyzing all cells
5. **Implement column width distribution**: Allocate table width to columns
6. **Implement row height distribution**: Allocate heights to rows
7. **Position table cells**: Create cell fragments with correct bounds
8. **Comprehensive tests**: Both fixed and auto layout

### Success Criteria

- [ ] TableFormattingContext implements FormattingContext
- [ ] Fixed layout algorithm works correctly
- [ ] Auto layout algorithm distributes widths properly
- [ ] Colspan/rowspan handled correctly
- [ ] Percentage widths resolved
- [ ] Row heights computed from cell contents
- [ ] Cells positioned correctly
- [ ] At least 25 tests covering both algorithms
- [ ] Major table layouts render correctly
- [ ] Tests pass
- [ ] Clippy clean

## Implementation Guide

### Step 1: Create Table Module Structure (Estimated: 1 hour)

**Create module files:**
```bash
mkdir -p src/layout/contexts/table
touch src/layout/contexts/table.rs
touch src/layout/contexts/table/structure.rs
touch src/layout/contexts/table/width.rs
```

**`src/layout/contexts/table.rs`:**

```rust
//! Table Formatting Context
//!
//! Implements CSS table layout algorithm.
//!
//! Reference:
//! - CSS 2.1 Chapter 17 (Tables)
//! - CSS Tables Module Level 3

use crate::layout::contexts::FormattingContext;
use crate::tree::{BoxNode, FragmentNode};
use crate::layout::LayoutConstraints;
use crate::geometry::{Rect, Point, Size};
use crate::error::Result;

mod structure;
mod width;

pub use structure::TableStructure;
use width::{compute_fixed_widths, compute_auto_widths};

/// Table Formatting Context
#[derive(Debug)]
pub struct TableFormattingContext;

impl TableFormattingContext {
    pub fn new() -> Self {
        Self
    }
}

impl FormattingContext for TableFormattingContext {
    fn layout(
        &self,
        box_node: &BoxNode,
        constraints: &LayoutConstraints,
    ) -> Result<FragmentNode> {
        // Three-phase table layout algorithm:
        //
        // Phase 1: Analyze structure (rows, columns, cells)
        // Phase 2: Compute column widths
        // Phase 3: Compute row heights and create fragments

        // Phase 1: Build table structure
        let structure = TableStructure::from_box_tree(box_node)?;

        // Phase 2: Compute column widths
        let table_width = self.compute_table_width(box_node, constraints)?;
        let column_widths = if self.uses_fixed_layout(box_node) {
            compute_fixed_widths(&structure, table_width)?
        } else {
            compute_auto_widths(&structure, table_width, constraints)?
        };

        // Phase 3: Compute row heights and layout cells
        let (row_heights, cell_fragments) = self.layout_cells(
            &structure,
            &column_widths,
            constraints,
        )?;

        // Create table fragment
        let table_height: f32 = row_heights.iter().sum();
        let rect = Rect::from_xywh(0.0, 0.0, table_width, table_height);

        Ok(FragmentNode {
            rect,
            style: box_node.style.clone(),
            children: cell_fragments,
            debug_info: box_node.debug_info.clone(),
        })
    }
}
```

### Step 2: Implement Table Structure Analysis (Estimated: 3 hours)

**`src/layout/contexts/table/structure.rs`:**

```rust
//! Table structure representation

use crate::tree::BoxNode;
use crate::error::{Result, Error};

/// Represents a table's structure (rows, columns, cells)
#[derive(Debug)]
pub struct TableStructure {
    /// Number of columns
    pub column_count: usize,

    /// Rows (each row contains cells)
    pub rows: Vec<TableRow>,

    /// Column specifications (from <col> elements)
    pub columns: Vec<TableColumn>,
}

#[derive(Debug)]
pub struct TableRow {
    /// Row index
    pub index: usize,

    /// Cells in this row
    pub cells: Vec<TableCell>,

    /// Row box node
    pub box_node: BoxNode,
}

#[derive(Debug)]
pub struct TableCell {
    /// Column index (starting column)
    pub column: usize,

    /// Row index (starting row)
    pub row: usize,

    /// Column span (default 1)
    pub colspan: usize,

    /// Row span (default 1)
    pub rowspan: usize,

    /// Cell box node
    pub box_node: BoxNode,
}

#[derive(Debug)]
pub struct TableColumn {
    /// Column index
    pub index: usize,

    /// Specified width (if any)
    pub width: Option<f32>,
}

impl TableStructure {
    /// Builds table structure from box tree
    ///
    /// Analyzes the box tree to extract rows, columns, and cells
    /// with their positions and spans.
    pub fn from_box_tree(table_box: &BoxNode) -> Result<Self> {
        let mut rows = Vec::new();
        let mut columns = Vec::new();
        let mut column_count = 0;

        // Extract row groups (tbody, thead, tfoot)
        for row_group in &table_box.children {
            if !Self::is_row_group(row_group) {
                continue;
            }

            // Extract rows from row group
            for (row_index, row_box) in row_group.children.iter().enumerate() {
                if !Self::is_row(row_box) {
                    continue;
                }

                let mut cells = Vec::new();
                let mut col_index = 0;

                // Extract cells from row
                for cell_box in &row_box.children {
                    if !Self::is_cell(cell_box) {
                        continue;
                    }

                    let colspan = Self::get_colspan(cell_box);
                    let rowspan = Self::get_rowspan(cell_box);

                    cells.push(TableCell {
                        column: col_index,
                        row: row_index,
                        colspan,
                        rowspan,
                        box_node: cell_box.clone(),
                    });

                    col_index += colspan;
                }

                // Update column count
                column_count = column_count.max(col_index);

                rows.push(TableRow {
                    index: row_index,
                    cells,
                    box_node: row_box.clone(),
                });
            }
        }

        // Initialize columns
        for i in 0..column_count {
            columns.push(TableColumn {
                index: i,
                width: None,
            });
        }

        Ok(Self {
            column_count,
            rows,
            columns,
        })
    }

    fn is_row_group(box_node: &BoxNode) -> bool {
        // Check if box is a table row group
        // TODO: Check display property
        true
    }

    fn is_row(box_node: &BoxNode) -> bool {
        // Check if box is a table row
        true
    }

    fn is_cell(box_node: &BoxNode) -> bool {
        // Check if box is a table cell
        true
    }

    fn get_colspan(cell_box: &BoxNode) -> usize {
        // TODO: Get from style or attributes
        1
    }

    fn get_rowspan(cell_box: &BoxNode) -> usize {
        // TODO: Get from style or attributes
        1
    }

    /// Returns the number of rows
    pub fn row_count(&self) -> usize {
        self.rows.len()
    }
}
```

### Step 3: Implement Fixed Layout Algorithm (Estimated: 2 hours)

**`src/layout/contexts/table/width.rs`:**

```rust
//! Table width algorithms

use super::TableStructure;
use crate::error::Result;

/// Computes column widths using fixed table layout algorithm
///
/// CSS 2.1 Section 17.5.2.1: Fixed table layout
///
/// Algorithm:
/// 1. Use widths from first row cells
/// 2. If cell has specified width, use it
/// 3. Otherwise, distribute remaining width equally
pub fn compute_fixed_widths(
    structure: &TableStructure,
    table_width: f32,
) -> Result<Vec<f32>> {
    let col_count = structure.column_count;
    let mut widths = vec![0.0; col_count];
    let mut specified_width = 0.0;
    let mut unspecified_count = 0;

    // Get first row
    if let Some(first_row) = structure.rows.first() {
        for cell in &first_row.cells {
            // Get specified width from cell
            if let Some(width) = get_cell_width(&cell.box_node) {
                let width_per_col = width / cell.colspan as f32;
                for i in 0..cell.colspan {
                    widths[cell.column + i] = width_per_col;
                    specified_width += width_per_col;
                }
            } else {
                unspecified_count += cell.colspan;
            }
        }
    }

    // Distribute remaining width to unspecified columns
    if unspecified_count > 0 {
        let remaining = (table_width - specified_width).max(0.0);
        let width_per_col = remaining / unspecified_count as f32;

        for width in &mut widths {
            if *width == 0.0 {
                *width = width_per_col;
            }
        }
    }

    Ok(widths)
}

/// Computes column widths using auto table layout algorithm
///
/// CSS 2.1 Section 17.5.2.2: Automatic table layout
///
/// This is more complex - needs to analyze all cells,
/// compute min/max widths, then distribute.
pub fn compute_auto_widths(
    structure: &TableStructure,
    table_width: f32,
    constraints: &LayoutConstraints,
) -> Result<Vec<f32>> {
    let col_count = structure.column_count;

    // Step 1: Compute min and max widths for each column
    let mut min_widths = vec![0.0; col_count];
    let mut max_widths = vec![0.0; col_count];

    for row in &structure.rows {
        for cell in &row.cells {
            if cell.colspan == 1 {
                // Single column cell - update that column's min/max
                let (min, max) = compute_cell_intrinsic_widths(&cell.box_node)?;

                min_widths[cell.column] = min_widths[cell.column].max(min);
                max_widths[cell.column] = max_widths[cell.column].max(max);
            } else {
                // Multi-column cell - distribute across spanned columns
                // (Simplified for now)
            }
        }
    }

    // Step 2: Distribute table width to columns
    let total_min: f32 = min_widths.iter().sum();
    let total_max: f32 = max_widths.iter().sum();

    let widths = if table_width >= total_max {
        // Use max widths
        max_widths
    } else if table_width >= total_min {
        // Interpolate between min and max
        distribute_proportional(&min_widths, &max_widths, table_width)
    } else {
        // Use min widths (table will overflow)
        min_widths
    };

    Ok(widths)
}

fn get_cell_width(cell_box: &BoxNode) -> Option<f32> {
    // TODO: Get from cell style
    None
}

fn compute_cell_intrinsic_widths(cell_box: &BoxNode) -> Result<(f32, f32)> {
    // TODO: Layout cell content to get min/max widths
    Ok((50.0, 200.0))
}

fn distribute_proportional(
    min_widths: &[f32],
    max_widths: &[f32],
    target_width: f32,
) -> Vec<f32> {
    // Distribute target_width proportionally between min and max
    let total_min: f32 = min_widths.iter().sum();
    let total_max: f32 = max_widths.iter().sum();

    let ratio = (target_width - total_min) / (total_max - total_min);

    min_widths.iter().zip(max_widths.iter())
        .map(|(min, max)| min + (max - min) * ratio)
        .collect()
}
```

### Step 4: Implement Cell Layout (Estimated: 3 hours)

**Add to `src/layout/contexts/table.rs`:**

```rust
impl TableFormattingContext {
    /// Layouts cells and computes row heights
    fn layout_cells(
        &self,
        structure: &TableStructure,
        column_widths: &[f32],
        constraints: &LayoutConstraints,
    ) -> Result<(Vec<f32>, Vec<FragmentNode>)> {
        let mut row_heights = vec![0.0; structure.rows.len()];
        let mut cell_fragments = Vec::new();

        let mut current_y = 0.0;

        for (row_index, row) in structure.rows.iter().enumerate() {
            let mut row_height = 0.0;

            for cell in &row.cells {
                // Compute cell width (sum of spanned columns)
                let cell_width: f32 = (0..cell.colspan)
                    .map(|i| column_widths[cell.column + i])
                    .sum();

                // Layout cell contents
                let cell_constraints = LayoutConstraints {
                    available_width: cell_width,
                    available_height: None,
                };

                let cell_fragment = self.layout_cell_contents(
                    &cell.box_node,
                    &cell_constraints,
                )?;

                row_height = row_height.max(cell_fragment.rect.height());

                // Position cell
                let x: f32 = (0..cell.column)
                    .map(|i| column_widths[i])
                    .sum();

                let positioned = cell_fragment.with_position(Point::new(x, current_y));
                cell_fragments.push(positioned);
            }

            row_heights[row_index] = row_height;
            current_y += row_height;
        }

        Ok((row_heights, cell_fragments))
    }

    fn layout_cell_contents(
        &self,
        cell_box: &BoxNode,
        constraints: &LayoutConstraints,
    ) -> Result<FragmentNode> {
        // Layout cell's children using block layout
        // TODO: Delegate to block FC
        Ok(FragmentNode {
            rect: Rect::from_xywh(0.0, 0.0, constraints.available_width, 50.0),
            style: cell_box.style.clone(),
            children: vec![],
            debug_info: None,
        })
    }

    fn compute_table_width(
        &self,
        table_box: &BoxNode,
        constraints: &LayoutConstraints,
    ) -> Result<f32> {
        // Get specified width or use available width
        Ok(constraints.available_width)
    }

    fn uses_fixed_layout(&self, table_box: &BoxNode) -> bool {
        // Check table-layout property
        // TODO: Get from style
        false // Default to auto layout
    }
}
```

### Step 5: Write Tests (Estimated: 3 hours)

**Create `tests/layout/test_table_layout.rs`:**

```rust
use fastrender::layout::contexts::table::*;

#[test]
fn test_simple_table_structure() {
    // Build a simple 2x2 table
    // Test structure analysis
}

#[test]
fn test_fixed_layout_equal_widths() {
    // Table with 3 columns, no specified widths
    // Should distribute equally
}

#[test]
fn test_fixed_layout_specified_widths() {
    // First row specifies widths: 100px, 200px
    // Should use those widths
}

#[test]
fn test_auto_layout_min_widths() {
    // Cells with long content
    // Should not shrink below min width
}

#[test]
fn test_colspan() {
    // Cell spanning 2 columns
    // Width should be sum of both columns
}

// Add 20+ more tests
```

Run verification:
```bash
cargo test layout::table
cargo clippy -- -D warnings
cargo fmt
```

## Testing Requirements

**Required tests** (25+ tests):
1. Fixed layout - equal distribution
2. Fixed layout - specified widths
3. Auto layout - min/max widths
4. Colspan/rowspan
5. Multiple rows
6. Empty cells
7. Complex tables

## Output Artifacts

### Code Files

1. **`src/layout/contexts/table.rs`** (~300 lines)
2. **`src/layout/contexts/table/structure.rs`** (~200 lines)
3. **`src/layout/contexts/table/width.rs`** (~200 lines)
4. **`tests/layout/test_table_layout.rs`** (~400 lines)

### Notes File

Create: **`docs/tasks/notes/W3.T06-notes.md`**

## Verification Checklist

- [ ] All objectives met
- [ ] Fixed layout works
- [ ] Auto layout works
- [ ] Cells positioned correctly
- [ ] Tests pass (25+)

## Time Tracking

- Module setup: 1hr
- Structure analysis: 3hrs
- Fixed layout: 2hrs
- Auto layout: 3hrs
- Cell layout: 3hrs
- Tests: 3hrs
- Total: 12-16 hours

## Getting Help

- CSS 2.1 Chapter 17
- CSS Tables Module Level 3
- W1.R02 notes for research

Tables are the hardest layout mode - take your time!
