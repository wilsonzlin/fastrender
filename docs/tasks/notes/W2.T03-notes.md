# Task W2.T03 Output Notes

## Implementation Summary

Implemented the fragment tree for representing layout results with positioned and sized boxes:
- **FragmentContent enum**: 5 variants (Block, Inline, Text, Line, Replaced) representing different content types
- **ReplacedType**: Uses `box_tree::ReplacedType` (shared, not duplicated)
- **FragmentNode struct**: Positioned boxes with bounds (Rect), content, and children
- **FragmentTree wrapper**: Container for root fragment with tree-level operations
- **Geometric methods**: bounding_box(), translate(), contains_point() for spatial operations
- **Hit testing**: fragments_at_point() returning fragments in reverse paint order (topmost first)
- **Tree traversal**: FragmentIterator providing depth-first, pre-order traversal
- **Helper constructors**: new_block(), new_text(), new_line(), new_inline(), new_replaced()

Fragments are the output of layout with definite positions and sizes. Unlike boxes (which represent what to layout), fragments represent where things ended up after layout has been performed.

## API Contracts

### Public Types

```rust
#[derive(Debug, Clone)]
pub enum FragmentContent {
    Block { box_id: Option<usize> },
    Inline { box_id: Option<usize>, fragment_index: usize },
    Text { text: String, box_id: Option<usize>, baseline_offset: f32 },
    Line { baseline: f32 },
    Replaced { replaced_type: ReplacedType, box_id: Option<usize> },
}

// ReplacedType is imported from box_tree (shared type)
// See box_tree::ReplacedType for Image, Video, Canvas, Svg, Iframe variants

#[derive(Debug, Clone)]
pub struct FragmentNode {
    pub bounds: Rect,
    pub content: FragmentContent,
    pub children: Vec<FragmentNode>,
}

#[derive(Debug, Clone)]
pub struct FragmentTree {
    pub root: FragmentNode,
}
```

### Key Methods

```rust
impl FragmentContent {
    pub fn is_block(&self) -> bool;
    pub fn is_inline(&self) -> bool;
    pub fn is_text(&self) -> bool;
    pub fn is_line(&self) -> bool;
    pub fn is_replaced(&self) -> bool;
    pub fn text(&self) -> Option<&str>;
}

impl FragmentNode {
    // Constructors
    pub fn new(bounds: Rect, content: FragmentContent, children: Vec<FragmentNode>) -> Self;
    pub fn new_block(bounds: Rect, children: Vec<FragmentNode>) -> Self;
    pub fn new_block_with_id(bounds: Rect, box_id: usize, children: Vec<FragmentNode>) -> Self;
    pub fn new_inline(bounds: Rect, fragment_index: usize, children: Vec<FragmentNode>) -> Self;
    pub fn new_text(bounds: Rect, text: String, baseline_offset: f32) -> Self;
    pub fn new_line(bounds: Rect, baseline: f32, children: Vec<FragmentNode>) -> Self;
    pub fn new_replaced(bounds: Rect, replaced_type: ReplacedType) -> Self;

    // Queries
    pub fn child_count(&self) -> usize;
    pub fn is_leaf(&self) -> bool;

    // Geometric operations
    pub fn bounding_box(&self) -> Rect;
    pub fn translate(&self, offset: Point) -> Self;
    pub fn contains_point(&self, point: Point) -> bool;
    pub fn fragments_at_point(&self, point: Point) -> Vec<&FragmentNode>;

    // Tree operations
    pub fn iter_fragments(&self) -> FragmentIterator<'_>;
    pub fn children(&self) -> impl Iterator<Item = &FragmentNode>;
}

impl FragmentTree {
    pub fn new(root: FragmentNode) -> Self;
    pub fn viewport_size(&self) -> Size;
    pub fn content_size(&self) -> Rect;
    pub fn hit_test(&self, point: Point) -> Vec<&FragmentNode>;
    pub fn iter_fragments(&self) -> FragmentIterator<'_>;
    pub fn fragment_count(&self) -> usize;
}
```

## Decisions Made

### Decision 1: Fragments Store Rect Directly

**Choice:** FragmentNode has `bounds: Rect` field (not Option<Rect>)
**Rationale:**
- Fragments always have position and size after layout
- Rect is the natural representation for positioned boxes
- Avoids Option<Rect> complexity and unwrap() calls
- Rect is Copy, so very efficient (16 bytes, no heap allocation)
- Matches the semantic meaning: fragments ARE positioned rectangles

**Impact:** All fragments must be positioned when created. Layout algorithms must compute final bounds before creating fragments.

### Decision 2: Clone-Based Tree Modification

**Choice:** translate() returns new tree (clones entire subtree)
**Rationale:**
- Fragments are typically created once per layout pass
- Cloning is conceptually simpler than mutation
- Enables immutable API design
- Fragment trees are not huge (typically < 10k nodes)
- Simplifies reasoning about ownership and lifetimes

**Alternatives Considered:**
- Mutable translate_mut() → rejected because it complicates ownership
- Arc-based sharing → rejected as premature optimization

**Performance Note:** For very large trees (>50k fragments), could revisit this decision.

### Decision 3: box_id as Optional usize

**Choice:** box_id: Option<usize> for linking back to source BoxNode
**Rationale:**
- Not all fragments come directly from boxes (e.g., anonymous boxes, line boxes)
- usize is a simple placeholder ID type
- Optional allows for generated/synthetic fragments
- Provides traceability from fragment back to source box

**Future Work:** Replace with Arc<BoxNode> or proper ID type (NodeId) when box tree is implemented.

### Decision 4: Hit Testing Returns Reverse Paint Order

**Choice:** fragments_at_point() returns topmost (last painted) fragment first
**Rationale:**
- Event handling wants topmost element first
- Matches browser behavior for hit testing
- Makes common case (click on top element) fast
- Paint order is forward (depth-first), hit test is reverse

**Implementation:** Iterate children in reverse, accumulate results, then add self.

### Decision 5: fragment_index for Inline Splitting

**Choice:** Inline fragments store which split they are (0, 1, 2, ...)
**Rationale:**
- One inline box can generate multiple fragments when wrapping
- Need to track which piece this is for paint/decoration logic
- First fragment (index 0) gets left border/padding
- Last fragment gets right border/padding
- Middle fragments get neither

**Future Use:** Inline layout (W4.T12) will use this for correct border/decoration rendering.

## Spec Interpretations

### Fragment Splitting

**CSS Spec says:** "When an inline box is split, margins, borders, and padding have no visual effect where the split occurs."
**Interpretation:** One inline BoxNode → multiple inline FragmentNodes when wrapping across lines
**Implementation:**
- fragment_index tracks which fragment (0 = first, 1 = second, etc.)
- Layout code must decide where to split based on line breaking
**Test coverage:** Not tested yet (requires inline layout implementation)

### Hit Testing Order

**CSS Spec says:** Elements later in DOM tree paint on top of earlier elements (when z-index is equal)
**Interpretation:** Hit testing should check later (topmost) elements first
**Implementation:**
- fragments_at_point() checks children in reverse order
- Returns results with topmost first
**Test coverage:** ✅ test_fragments_at_point_overlapping verifies this

## Discoveries & Gotchas

### Discovery 1: Hit Testing Order Matters

**What:** fragments_at_point returns in reverse paint order (topmost first)
**Why it matters:** Event handling expects topmost element first
**Implementation detail:** We iterate children in reverse, then add parent
**Recommendation for W6.T02 (Hit Testing):** Use tree.hit_test() and check first element

### Gotcha 1: Bounding Box vs Bounds

**Problem:** bounding_box() includes children, bounds doesn't
**Impact:** Can be confusing which to use
**Solution:**
- Use `bounds` for this fragment's rectangle only
- Use `bounding_box()` for minimal rect containing entire subtree
**Warning:** Don't confuse these when computing overflow or scrollable areas
**Example:**
```rust
// bounds: just this fragment
let fragment_rect = fragment.bounds;

// bounding_box: includes all descendants
let overflow_rect = fragment.bounding_box();
```

### Gotcha 2: Relative Coordinates

**Problem:** Child bounds are relative to parent's coordinate space
**Impact:** Need translation to get absolute positions
**Solution:** Use translate() to convert to absolute coordinates
**Example:**
```rust
// Child at (10, 10) in parent at (100, 100)
// Child's absolute position is (110, 110)
let absolute_child = child.translate(parent.bounds.origin);
```
**Recommendation for W5.T01 (Paint):** Maintain current transform while traversing tree

### Gotcha 3: Iterator Lifetime Syntax

**Problem:** FragmentIterator<'_> must use explicit lifetime in return type
**Why:** Compiler warning about mismatched lifetime syntaxes
**Solution:** Use `FragmentIterator<'_>` not just `FragmentIterator` in return types
**Fixed in implementation:** Both iter_fragments() methods use explicit lifetime

## Performance Notes

### Performance Characteristics

- **Clone:** O(n) for tree size n (recursive clone of all children)
- **Hit testing:** O(depth × overlapping_fragments) - worst case O(n)
- **Tree traversal:** O(n) - visits each fragment once
- **bounding_box:** O(n) - must visit all descendants
- **translate:** O(n) - must translate all descendants
- **contains_point:** O(1) - just rect check

### Optimization Opportunities

**For future optimization (not needed yet):**

1. **Cache bounding boxes:**
   - If fragments are immutable after creation, cache bounding_box() result
   - Save as additional field: `cached_bbox: Option<Rect>`
   - Compute on first call, reuse thereafter
   - Saves O(n) computation on repeated calls

2. **Spatial index for hit testing:**
   - For large trees (>10k fragments), use quadtree or R-tree
   - Reduces hit testing from O(n) to O(log n)
   - Only beneficial for complex UIs with many fragments

3. **Arena allocation:**
   - Store fragments in arena instead of nested Vec
   - Reduces allocation overhead
   - Improves cache locality
   - Better for very large trees

4. **SIMD for bounding box union:**
   - Rect::union could use SIMD for batch operations
   - Not significant until profiling shows it's a bottleneck

**Current status:** No optimization needed. Fragment trees are typically small (< 10k nodes) and created infrequently (once per layout).

## Recommendations for Downstream Tasks

### For W3.T04 (Block Layout):

**Use these constructors:**
- `FragmentNode::new_block(bounds, children)` - standard block fragment
- `FragmentNode::new_block_with_id(bounds, box_id, children)` - if tracking source box

**Follow these patterns:**
- Create FragmentNode AFTER computing final position and size
- Set bounds to the computed content box rectangle
- Add children in document order (not reverse)
- Use Rect::from_xywh(x, y, width, height) for convenience

**Example:**
```rust
// After computing layout
let fragment = FragmentNode::new_block(
    Rect::from_xywh(x_pos, y_pos, final_width, final_height),
    child_fragments,
);
```

### For W4.T12 (Inline Layout):

**Use these constructors:**
- `FragmentNode::new_line(bounds, baseline, children)` - for line boxes
- `FragmentNode::new_text(bounds, text, baseline_offset)` - for text runs
- `FragmentNode::new_inline(bounds, fragment_index, children)` - for split inline boxes

**Follow these patterns:**
- Set baseline correctly for text alignment
- Set baseline_offset for text fragments (distance from top to baseline)
- Use fragment_index when splitting inline boxes across lines (0, 1, 2, ...)
- First fragment (index 0) gets left decorations
- Last fragment gets right decorations
- Middle fragments get neither

**Example:**
```rust
// Line box with baseline at 16px from top
let line = FragmentNode::new_line(
    Rect::from_xywh(0.0, y_pos, line_width, line_height),
    16.0, // baseline
    vec![text_fragment1, text_fragment2],
);

// Text fragment
let text = FragmentNode::new_text(
    Rect::from_xywh(x_pos, y_pos, text_width, text_height),
    "Hello".to_string(),
    14.0, // baseline offset from fragment top
);

// Split inline box across lines
let first_part = FragmentNode::new_inline(
    Rect::from_xywh(x1, y1, w1, h1),
    0, // first fragment
    vec![],
);
let second_part = FragmentNode::new_inline(
    Rect::from_xywh(x2, y2, w2, h2),
    1, // second fragment
    vec![],
);
```

### For W5.T01 (Paint):

**Use these methods:**
- `tree.iter_fragments()` - iterate in paint order (depth-first, pre-order)
- `fragment.bounds` - the rectangle to paint
- `fragment.content` - dispatch to correct paint method

**Follow these patterns:**
- Paint in forward order (iter_fragments gives this)
- Use bounds for clipping
- Maintain transform stack while traversing tree
- Use content type to dispatch: block paint, text paint, etc.

**Example:**
```rust
fn paint(tree: &FragmentTree, canvas: &mut Canvas) {
    for fragment in tree.iter_fragments() {
        match &fragment.content {
            FragmentContent::Block { .. } => paint_block(fragment, canvas),
            FragmentContent::Text { text, .. } => paint_text(fragment, text, canvas),
            FragmentContent::Line { .. } => {/* lines don't paint themselves */},
            FragmentContent::Inline { .. } => paint_inline(fragment, canvas),
            FragmentContent::Replaced { .. } => paint_replaced(fragment, canvas),
        }
    }
}
```

**Gotcha:** Remember to translate child coordinates to parent space when painting.

### For W6.T02 (Hit Testing):

**Use these methods:**
- `tree.hit_test(point)` - returns all fragments at point
- First element in returned vec is topmost (for click handling)

**Follow these patterns:**
- Check topmost fragment first (index 0)
- Use box_id to link back to DOM element
- Handle cases where multiple fragments overlap

**Example:**
```rust
fn handle_click(tree: &FragmentTree, point: Point) -> Option<usize> {
    let hits = tree.hit_test(point);
    if let Some(topmost) = hits.first() {
        // Handle click on topmost fragment
        match &topmost.content {
            FragmentContent::Block { box_id, .. } => *box_id,
            // ...
        }
    } else {
        None // Clicked outside content
    }
}
```

## Open Questions

None - fragment design is straightforward and follows well-established browser patterns.

## Test Coverage

### What's Tested

- ✅ All constructors (new_block, new_text, new_line, new_inline, new_replaced)
- ✅ Constructor variants (with_id)
- ✅ Content type checks (is_block, is_text, etc.)
- ✅ Bounding box computation (single, with children, nested)
- ✅ Translation (single fragment, with children)
- ✅ Hit testing (single, with children, overlapping)
- ✅ Tree traversal (single, with children)
- ✅ FragmentTree operations (creation, hit test, count, viewport size)
- ✅ Edge cases (empty trees, leaf nodes)
- ✅ Helper methods (child_count, is_leaf, children iterator)

### Test Statistics

- **Unit tests:** 25 tests
- **All tests pass:** ✅
- **Coverage:** All public methods tested
- **Edge cases:** Empty trees, single nodes, deeply nested trees

### What's Not Tested (Gaps)

- ❌ Inline box splitting behavior (requires inline layout to test properly)
- ❌ Baseline alignment (requires text shaping to test properly)
- ❌ Very large trees (>10k fragments) - performance testing not needed yet
- ❌ Replaced element specifics (will be tested when paint system exists)

These gaps are expected and will be covered by integration tests in later waves.

## Code Quality

- ✅ Clippy passes with no warnings
- ✅ Rustfmt applied
- ✅ All public APIs documented with rustdoc
- ✅ Examples in all major public API documentation
- ✅ Lifetime syntax warnings fixed (FragmentIterator<'_>)
- ✅ All types derive Debug and Clone
- ✅ No unwrap() or expect() in production code

## References Used

1. **W1.T01-notes.md** - Geometry types API and recommendations
2. **CSS 2.1 Section 9** - Visual formatting model and fragments
3. **CSS Fragmentation Module Level 3** - Fragment splitting behavior
4. **WebRender fragments** - Reference implementation for fragment tree design

## Files Created

1. **src/tree/fragment_tree.rs** (970 lines)
   - Complete implementation with all types and methods
   - 25 comprehensive unit tests
   - Full documentation with examples

2. **src/tree/mod.rs** (updated)
   - Added fragment_tree module declaration
   - Added re-exports for public types

3. **docs/tasks/notes/W2.T03-notes.md** (this file)
   - Comprehensive documentation for downstream tasks

## Verification Results

```
Task: W2.T03 - Implement FragmentNode Type and Fragment Tree
Status: ✅ COMPLETE

Verification:
✅ cargo build - SUCCESS
✅ cargo test tree::fragment_tree - 25/25 tests passed
✅ cargo clippy -- -D warnings - PASS (0 warnings)
✅ cargo fmt --check - PASS (already formatted)

Files Created:
✅ src/tree/fragment_tree.rs (970 lines)
✅ src/tree/mod.rs (updated)
✅ docs/tasks/notes/W2.T03-notes.md (this file)

Time Taken: ~5 hours (estimate was 4-6 hours)

Notes: All objectives achieved. Fragment tree is complete, well-tested, and
documented. Comprehensive recommendations written for all downstream tasks
(W3.T04, W4.T12, W5.T01, W6.T02). No blockers. Ready for dependent tasks to begin.
```

---

**Task completed:** 2025-01-21
**Time taken:** 5 hours
**Tests passing:** 25/25
**Total lines of code:** 970 (including tests and documentation)
