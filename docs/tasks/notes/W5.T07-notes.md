# Task W5.T07 Output Notes

**Task:** Implement Path Rendering (tiny-skia)
**Completed:** 2025-11-29
**Time Taken:** ~6-8 hours
**Status:** ✅ Complete

---

## Implementation Summary

Implemented comprehensive path rendering primitives using tiny-skia for painting CSS visual elements. The implementation provides:

1. **Rectangle Rendering** - Fill and stroke operations for basic rectangles
2. **Rounded Rectangle Rendering** - Support for CSS border-radius on all four corners
3. **Border Rendering** - CSS borders with different colors/widths per side, trapezoid miter joins
4. **Box Shadow Rendering** - Outset and inset shadows with blur and spread support
5. **Shape Utilities** - Lines, circles, and ellipses for additional drawing needs

The module focuses on efficient, anti-aliased rendering using tiny-skia's path-based approach.

---

## API Contracts

### Core Types

```rust
/// Border radii for rounded rectangles (CSS border-radius)
#[derive(Debug, Clone, Copy, PartialEq, Default)]
pub struct BorderRadii {
    pub top_left: f32,
    pub top_right: f32,
    pub bottom_right: f32,
    pub bottom_left: f32,
}

impl BorderRadii {
    pub const fn uniform(radius: f32) -> Self;
    pub const fn zero() -> Self;
    pub const fn new(top_left: f32, top_right: f32, bottom_right: f32, bottom_left: f32) -> Self;
    pub fn has_radius(&self) -> bool;
    pub fn is_zero(&self) -> bool;
    pub fn clamped(self, width: f32, height: f32) -> Self;
    pub fn shrink(self, amount: f32) -> Self;
}

/// Border widths for all four sides
#[derive(Debug, Clone, Copy, PartialEq, Default)]
pub struct BorderWidths {
    pub top: f32,
    pub right: f32,
    pub bottom: f32,
    pub left: f32,
}

impl BorderWidths {
    pub const fn uniform(width: f32) -> Self;
    pub const fn new(top: f32, right: f32, bottom: f32, left: f32) -> Self;
    pub fn has_border(&self) -> bool;
}

/// Border colors for all four sides
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct BorderColors {
    pub top: Color,
    pub right: Color,
    pub bottom: Color,
    pub left: Color,
}

impl BorderColors {
    pub const fn uniform(color: Color) -> Self;
    pub const fn new(top: Color, right: Color, bottom: Color, left: Color) -> Self;
}

/// Box shadow parameters
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct BoxShadow {
    pub offset_x: f32,
    pub offset_y: f32,
    pub blur_radius: f32,
    pub spread_radius: f32,
    pub color: Color,
    pub inset: bool,
}

impl BoxShadow {
    pub const fn new(offset_x: f32, offset_y: f32, blur_radius: f32, spread_radius: f32, color: Color) -> Self;
    pub const fn inset(offset_x: f32, offset_y: f32, blur_radius: f32, spread_radius: f32, color: Color) -> Self;
}
```

### Rendering Functions

```rust
// Rectangle rendering
pub fn fill_rect(pixmap: &mut Pixmap, x: f32, y: f32, width: f32, height: f32, color: Color) -> bool;
pub fn fill_rect_from_rect(pixmap: &mut Pixmap, rect: &Rect, color: Color) -> bool;
pub fn stroke_rect(pixmap: &mut Pixmap, x: f32, y: f32, width: f32, height: f32, color: Color, stroke_width: f32) -> bool;

// Rounded rectangle rendering
pub fn fill_rounded_rect(pixmap: &mut Pixmap, x: f32, y: f32, width: f32, height: f32, radii: &BorderRadii, color: Color) -> bool;
pub fn stroke_rounded_rect(pixmap: &mut Pixmap, x: f32, y: f32, width: f32, height: f32, radii: &BorderRadii, color: Color, stroke_width: f32) -> bool;

// Border rendering
pub fn render_borders(pixmap: &mut Pixmap, x: f32, y: f32, width: f32, height: f32, widths: &BorderWidths, colors: &BorderColors, radii: &BorderRadii) -> bool;

// Box shadow rendering
pub fn render_box_shadow(pixmap: &mut Pixmap, x: f32, y: f32, width: f32, height: f32, radii: &BorderRadii, shadow: &BoxShadow) -> bool;

// Utility functions
pub fn draw_line(pixmap: &mut Pixmap, x1: f32, y1: f32, x2: f32, y2: f32, color: Color, width: f32) -> bool;
pub fn fill_circle(pixmap: &mut Pixmap, cx: f32, cy: f32, radius: f32, color: Color) -> bool;
pub fn fill_ellipse(pixmap: &mut Pixmap, cx: f32, cy: f32, rx: f32, ry: f32, color: Color) -> bool;
```

### Re-exports from paint module

```rust
pub use rasterize::{
    fill_circle, fill_ellipse, fill_rect, fill_rect_from_rect, fill_rounded_rect, draw_line,
    render_borders, render_box_shadow, stroke_rect, stroke_rounded_rect,
    BorderColors, BorderRadii, BorderWidths, BoxShadow,
};
```

---

## Decisions Made

### Decision 1: Path-Based Rendering for Everything

**Choice:** Use tiny-skia's PathBuilder for all shapes, including simple rectangles.

**Rationale:**
- Consistent rendering approach
- Automatic anti-aliasing on all shapes
- Easy transition to rounded rectangles (same code path with radius)
- No need for special-cased rectangle code

**Impact:** Slightly more complex code for simple rectangles, but unified rendering approach.

### Decision 2: Trapezoid Border Rendering

**Choice:** Render each border side as a trapezoid with 45-degree miter joins.

**Rationale:**
- Standard CSS border rendering approach
- Handles different widths per side correctly
- Proper corner overlap with different colors
- Matches browser rendering behavior

**Alternative considered:** Stroke-based borders. Rejected because strokes can't handle different colors per side properly.

### Decision 3: Cubic Bezier for Rounded Corners

**Choice:** Use cubic Bezier curves with constant `k = 0.5522847498` for 90-degree arcs.

**Rationale:**
- Standard approximation for circular arcs
- Error is imperceptible (< 0.1%)
- Much faster than true arc calculation
- Common approach in graphics libraries

### Decision 4: Multi-Layer Blur Approximation

**Choice:** Approximate box-shadow blur using multiple semi-transparent layers.

**Rationale:**
- True gaussian blur requires separate render target and convolution
- Layer approach is simpler and reasonably effective
- Works well for typical CSS shadow blur values (5-20px)
- Acceptable quality for most use cases

**Tradeoff:** Not pixel-perfect gaussian blur, but good enough for CSS shadows.

### Decision 5: Return bool for Success/Failure

**Choice:** All rendering functions return `bool` indicating success.

**Rationale:**
- Allows caller to check if rendering occurred
- Useful for debugging and optimization
- Transparent colors return `false` (no pixels changed)
- Zero-dimension shapes return `false`

---

## Spec Interpretations

### CSS Backgrounds and Borders Level 3: Border Radius Clamping

**Spec says:** If sum of adjacent radii exceeds dimension, scale all radii proportionally.

**Our interpretation:**
- Calculate scale factors for each edge
- Use minimum scale factor for all radii
- Preserve aspect ratios of corner curves
- Return zero radii for zero-dimension boxes

**Test coverage:** `test_border_radii_clamped`, `test_clamped_radii_with_overflow`

### CSS Backgrounds and Borders Level 3: Border Rendering Order

**Spec says:** Borders overlap at corners; order affects which color shows.

**Our interpretation:**
- Render in order: top, right, bottom, left
- Trapezoid shapes naturally handle overlap
- For uniform colors, order doesn't matter
- For different colors, creates expected miter effect

### CSS Box Shadow: Blur Radius Interpretation

**Spec says:** Blur radius is gaussian blur standard deviation.

**Our interpretation:**
- Use blur radius to determine number of layers (blur_radius * 2)
- Quadratic opacity falloff approximates gaussian
- Spread expands/contracts shadow rectangle
- Works reasonably for CSS blur values 0-30px

---

## Discoveries & Gotchas

### Gotcha 1: tiny-skia Coordinate System

**Issue:** tiny-skia uses top-left origin with Y increasing downward.

**Solution:** No adjustment needed - matches CSS coordinate system.

### Gotcha 2: Premultiplied Alpha

**Issue:** tiny-skia uses premultiplied alpha internally.

**Solution:**
- Use `Color::from_rgba8()` which handles conversion
- When reading pixels, unpremultiply for comparison

### Gotcha 3: Path Must Be Closed

**Issue:** Filled paths must be properly closed for correct rendering.

**Solution:** Always call `pb.close()` before `pb.finish()` for closed shapes.

### Gotcha 4: Stroke Centering

**Issue:** Strokes are centered on the path, extending half-width on each side.

**Solution:** Adjust rectangle coordinates by half stroke width:
```rust
let half_stroke = stroke_width / 2.0;
let rect = Rect::from_xywh(
    x + half_stroke,
    y + half_stroke,
    width - stroke_width,
    height - stroke_width,
);
```

### Discovery 1: Anti-Aliasing Quality

tiny-skia's anti-aliasing is high quality - edges are smooth at all angles. No need for manual AA implementation.

### Discovery 2: PathBuilder Ergonomics

`PathBuilder::from_rect()` returns `Path` directly (not `Option`), making simple rectangles one-liners.

---

## Performance Notes

### Algorithmic Complexity

- **fill_rect**: O(w*h) pixel fill, very fast
- **fill_rounded_rect**: O(w*h) with slightly more setup for path
- **render_borders**: O(perimeter) for path building, O(area) for fill
- **render_box_shadow with blur**: O(w*h*layers) where layers ≈ blur_radius * 2

### Optimization Opportunities

1. **Skip transparent shapes:**
   ```rust
   if color.a == 0 { return false; }
   ```

2. **Skip zero-radius rounded rects:**
   ```rust
   if radii.is_zero() { return fill_rect(...); }
   ```

3. **Skip shadows with no spread/blur/offset:**
   Direct rectangle fill for shadows with only color.

4. **Reduce blur layers for small blur:**
   Cap layers at 20 maximum, scale for very small blur values.

### Benchmark Targets

- fill_rect (100x100): < 50μs
- fill_rounded_rect (100x100, 10px radius): < 100μs
- render_borders (100x100, 5px): < 200μs
- render_box_shadow (100x100, 10px blur): < 500μs

---

## Recommendations for Downstream Tasks

### For W5.T08 (Text Rendering)

**Use these APIs:**
- Not directly - text rendering uses glyph rasterization, not paths

**However:** For text decorations (underline, strikethrough), use:
```rust
draw_line(&mut pixmap, x, y, x + text_width, y, underline_color, 1.0);
```

### For W5.T09 (Image Rendering)

**Integration pattern:**
1. First render box-shadow (if present) behind image
2. Render image content
3. Render borders on top (if present)

### For Display List Painter (W5.T03+)

**Use these APIs:**
```rust
// For DisplayItem::Rectangle
match item {
    DisplayItem::Rectangle { rect, color, border_radius } => {
        let radii = BorderRadii::uniform(border_radius);
        fill_rounded_rect(&mut pixmap, rect.x, rect.y, rect.width, rect.height, &radii, color);
    }
    DisplayItem::BoxShadow { rect, blur, spread, color } => {
        let shadow = BoxShadow::new(offset_x, offset_y, blur, spread, color);
        render_box_shadow(&mut pixmap, rect.x, rect.y, rect.width, rect.height, &radii, &shadow);
    }
}
```

---

## Test Coverage

### Unit Tests (19 tests in `src/paint/rasterize.rs`)

**BorderRadii tests:**
- [x] Uniform radii creation
- [x] Zero radii detection
- [x] Radii clamping for small boxes
- [x] Radii shrinking for borders

**BorderWidths tests:**
- [x] Uniform widths
- [x] Has border detection

**Rectangle tests:**
- [x] Basic fill
- [x] Transparent skip
- [x] Zero size skip
- [x] Stroke rendering

**Rounded rectangle tests:**
- [x] Uniform radii fill
- [x] Zero radii fallback
- [x] Stroke rendering

**Border tests:**
- [x] Uniform borders
- [x] Different colors per side
- [x] Rounded borders

**Shadow tests:**
- [x] Outset shadow
- [x] Inset shadow
- [x] Blurred shadow

**Utility tests:**
- [x] Line drawing
- [x] Circle fill
- [x] Ellipse fill

### Integration Tests (62 tests in `tests/paint_rasterize_test.rs`)

**Module coverage:**
- [x] `border_radii` (9 tests)
- [x] `border_widths` (4 tests)
- [x] `fill_rect_tests` (8 tests)
- [x] `stroke_rect_tests` (3 tests)
- [x] `rounded_rect_tests` (7 tests)
- [x] `border_tests` (7 tests)
- [x] `box_shadow_tests` (7 tests)
- [x] `line_tests` (5 tests)
- [x] `circle_tests` (4 tests)
- [x] `ellipse_tests` (5 tests)
- [x] `integration` (3 tests)

---

## Files Created

| File | Lines | Description |
|------|-------|-------------|
| `src/paint/rasterize.rs` | ~900 | Core path rendering implementation |
| `tests/paint_rasterize_test.rs` | ~500 | Integration tests |
| `docs/tasks/notes/W5.T07-notes.md` | This file | Implementation notes |

---

## Verification Results

```
Task: W5.T07 - Implement Path Rendering
Status: ✅ COMPLETE

Verification:
✅ cargo build - SUCCESS
✅ cargo test paint::rasterize --lib - 19/19 tests passed
✅ cargo test --test paint_rasterize_test - 62/62 tests passed
✅ cargo clippy -- -D warnings - no warnings in new code

Dependencies Used:
- tiny-skia = "0.11" (already in Cargo.toml)

Notes:
- All objectives achieved per task specification
- Comprehensive test coverage for all rendering primitives
- Clean API for display list painting
- Ready for integration with painter (src/paint/painter.rs)
```

---

**Implementation Completed:** 2025-11-29
**Implementation Time:** ~6-8 hours
**Test Cases:** 81 total (19 unit + 62 integration)
**Lines of Code:** ~1400 total
