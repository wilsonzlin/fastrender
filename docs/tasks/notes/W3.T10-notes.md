# W3.T10: Float Context Implementation Notes

## Task Summary

Implemented the `FloatContext` structure that manages floating boxes within a block formatting context (BFC). This is a foundational component for CSS float layout support.

## Files Created/Modified

### New Files

1. **`src/style/float.rs`** - CSS float and clear property types
   - `Float` enum: `None`, `Left`, `Right`
   - `Clear` enum: `None`, `Left`, `Right`, `Both`
   - Full parsing support with case-insensitive string parsing
   - Display trait implementations
   - Error types: `FloatParseError`, `ClearParseError`
   - Helper methods: `is_floating()`, `clears_left()`, `clears_right()`, `is_clearing()`

2. **`src/layout/float_context.rs`** - Float context for BFC float management
   - `FloatSide` enum: `Left`, `Right`
   - `FloatInfo` struct: stores float position/dimensions with `Rect`
   - `FloatContext` struct: manages float lists and provides query methods

### Modified Files

1. **`src/style/mod.rs`** - Added float module and re-exports
2. **`src/layout/mod.rs`** - Added float_context module and re-exports

## Implementation Details

### FloatContext Architecture

The `FloatContext` maintains two separate lists for left and right floats, sorted by their top edge for efficient querying. Key design decisions:

1. **Coordinate System**: All coordinates are relative to the BFC's content box origin. Y increases downward, X increases rightward.

2. **Float Storage**: Floats are stored as `FloatInfo` structs containing:
   - `side`: Which side (left/right)
   - `rect`: Margin box as a `Rect`

3. **Query Methods**:
   - `left_edge_at_y(y)` - Returns X where content can start
   - `right_edge_at_y(y)` - Returns X where content must end
   - `available_width_at_y(y)` - Returns (left_edge, available_width)
   - `available_width_in_range(y_start, y_end)` - For multi-line elements

4. **Clearance Computation**:
   - `compute_clearance(y, clear)` - Returns Y position after clearing
   - `clearance_amount(y, clear)` - Returns delta Y needed

5. **Float Positioning**:
   - `compute_float_position(side, width, height, min_y)` - Computes (x, y) position
   - Implements CSS 2.1 §9.5.1 float placement rules:
     - Float as high as possible
     - Left floats as far left as possible
     - Right floats as far right as possible
     - Floats don't overlap horizontally

### CSS 2.1 Float Rules Implemented

Per CSS 2.1 Section 9.5:

1. Float's top ≤ containing block top (enforced by `min_y`)
2. Float's top ≤ earlier float's top (naturally follows from placement algorithm)
3. Float's outer edge doesn't exceed containing block edge
4. Left floats go as far left as possible
5. Right floats go as far right as possible
6. Floats placed as high as possible
7. Floats that don't fit drop down to next available position

### API Design

The API follows the task specification closely:

```rust
// Create context for BFC with given width
let mut ctx = FloatContext::new(800.0);

// Add floats
ctx.add_float_at(FloatSide::Left, 0.0, 0.0, 200.0, 100.0);

// Query available space
let (left_edge, width) = ctx.available_width_at_y(50.0);

// Compute clearance
let cleared_y = ctx.compute_clearance(50.0, Clear::Left);

// Position new float
let (x, y) = ctx.compute_float_position(FloatSide::Left, 200.0, 100.0, 0.0);
```

## Testing

Created 36+ tests covering:

### FloatInfo Tests
- Constructor variants (`new`, `new_left`, `new_right`)
- Edge accessors (`top`, `bottom`, `left_edge`, `right_edge`)
- Y-range overlap detection
- Point containment

### FloatContext Tests
- Creation and defaults
- Current Y position tracking
- Adding single and multiple floats
- Available width with no floats
- Available width with left/right/both floats
- Available width in range
- Edge calculations
- Clearance with no floats
- Clear left/right/both scenarios
- Clearance amount delta
- Float position computation (empty, stacking, drops down)
- `floats_bottom()`, `fits_at()`, `find_fit()`
- Clear all floats
- Width modification
- Complex scenarios (staggered, overlapping, nested BFC)

### Style Tests
- Float parsing (all values, case-insensitive, with whitespace)
- Float error handling
- Float helper methods
- Clear parsing (all values)
- Clear helper methods
- Round-trip parsing

## Integration Points

### For Block Layout (W3.T04)
```rust
// Create float context for BFC
let mut float_ctx = FloatContext::new(containing_block_width);

// When laying out a float
if element.style.float.is_floating() {
    let (x, y) = float_ctx.compute_float_position(side, width, height, current_y);
    float_ctx.add_float_at(side, x, y, width, height);
}

// When laying out block-level content
let (left_edge, available_width) = float_ctx.available_width_at_y(current_y);

// When element has clear property
let new_y = float_ctx.compute_clearance(current_y, element.style.clear);
```

### For Inline Layout (W4.T12)
```rust
// When wrapping lines around floats
let (left_edge, line_width) = float_ctx.available_width_at_y(line_y);
```

## CSS Specification References

- CSS 2.1 Section 9.5: https://www.w3.org/TR/CSS21/visuren.html#floats
- CSS 2.1 Section 9.5.1: https://www.w3.org/TR/CSS21/visuren.html#float-position
- CSS 2.1 Section 9.5.2: https://www.w3.org/TR/CSS21/visuren.html#propdef-clear

## Future Considerations

1. **Performance**: For documents with many floats, the linear search through floats could be optimized with an interval tree or segment tree for O(log n) queries.

2. **Shape Support**: CSS Shapes Level 1 allows non-rectangular exclusion areas. This would require extending `FloatInfo` to support shape data.

3. **Writing Modes**: Current implementation assumes horizontal-tb writing mode. Vertical writing modes would need axis swapping.

4. **Nested BFCs**: The `with_width()` method creates child contexts but doesn't inherit floats. This is correct per CSS spec as each BFC contains its own floats.

## Verification

All verification steps pass:
- `cargo fmt` - Code formatted
- `cargo build` - Builds without errors
- `cargo test float` - All 61 float-related tests pass
- `cargo clippy` - No warnings on our code
