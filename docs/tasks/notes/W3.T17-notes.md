# W3.T17 Font Fallback Chain - Implementation Notes

## Summary

Implemented a complete font fallback chain system that follows CSS Fonts Module Level 4, Section 5 for font matching and fallback resolution.

## Files Created

### Source Files

1. **`src/text/font/mod.rs`** - Font module root
   - `FontId` - Wrapper around fontdb ID for stable font references
   - `FontStyle` - Normal, Italic, Oblique enum with fontdb conversion
   - `FontStretch` - Ultra-condensed to ultra-expanded enum with percentage values
   - `FontDatabase` - Wrapper around fontdb with glyph checking and emoji detection

2. **`src/text/font/fallback.rs`** - Fallback chain implementation
   - `GenericFamily` - All CSS generic families (serif, sans-serif, monospace, etc.)
   - `FamilyEntry` - Named or Generic font family entry
   - `FallbackChain` - Ordered list of font families with resolution logic
   - `FallbackChainBuilder` - Fluent builder API for constructing chains

### Test Files

3. **`tests/text/test_font_fallback.rs`** - 46+ comprehensive tests
   - Generic family parsing tests
   - FallbackChain construction tests
   - Configuration tests (weight, style, stretch)
   - Builder pattern tests
   - FontDatabase tests
   - Resolution tests with empty/system fonts
   - Edge case tests (Unicode, emoji, rare characters)

4. **`tests/text/mod.rs`** - Test module declaration

## Key Types and APIs

### FallbackChain

```rust
let chain = FallbackChain::new()
    .add_family("Roboto")
    .add_family("Arial")
    .add_generic(GenericFamily::SansSerif)
    .with_weight(700)
    .with_style(FontStyle::Italic);

// Resolve font for specific character
if let Some(font_id) = chain.resolve('A', &db) {
    // Found font with glyph
}

// Get default font (first available)
if let Some(font_id) = chain.resolve_default(&db) {
    // Found matching font
}
```

### FallbackChainBuilder

```rust
let chain = FallbackChainBuilder::new()
    .family("Roboto")
    .family("Arial")
    .generic(GenericFamily::SansSerif)
    .bold()
    .italic()
    .build();
```

### GenericFamily

Supports all CSS generic families:
- `Serif`, `SansSerif`, `Monospace`
- `Cursive`, `Fantasy`
- `SystemUi`, `UiSerif`, `UiSansSerif`, `UiMonospace`, `UiRounded`
- `Emoji`, `Math`, `Fangsong`

Each generic family has:
- `to_fontdb()` - Convert to fontdb Family type
- `fallback_names()` - Platform-specific fallback font names
- `parse()` / `FromStr` - Parse from CSS string

### FontDatabase

```rust
let db = FontDatabase::new();          // Load system fonts
let db = FontDatabase::empty();        // Empty for testing

// Check if font has glyph
db.has_glyph(font_id, 'A')

// Detect emoji characters
FontDatabase::is_emoji('ðŸ˜€')           // true
FontDatabase::is_emoji('A')            // false

// Find emoji fonts
let emoji_fonts = db.find_emoji_fonts();
```

## Design Decisions

1. **Glyph-based Resolution**: The `resolve()` method checks each font for the specific character's glyph, not just font availability. This ensures correct rendering of mixed-script text.

2. **Emoji Priority**: When resolving emoji characters, the chain first tries explicit Emoji fonts in the chain, then system emoji fonts, before falling back to regular fonts.

3. **Generic Family Fallbacks**: Each generic family has a list of platform-specific fallback names (e.g., SansSerif tries Arial, Helvetica, DejaVu Sans, etc.).

4. **Last Resort Fallback**: If no family in the chain has the glyph, `resolve()` tries any font in the database as a last resort.

5. **Implements FromStr**: `GenericFamily` implements `std::str::FromStr` for idiomatic Rust string parsing.

## Downstream Dependencies

### For W3.T18 (Text Shaper):
- Use `FallbackChain::resolve()` to get fonts for each character/run
- Use `FontDatabase::has_glyph()` to check glyph coverage
- Use `FontId` as stable font reference for shaping

### For W3.T19 (Text Layout):
- Use `FallbackChain::from_families()` to convert CSS `font-family` list
- Pass weight/style/stretch from computed styles via builder methods

### For W3.T20+ (Rendering):
- `FontId::inner()` returns `fontdb::ID` for direct fontdb access
- `FontDatabase::inner()` returns `&fontdb::Database` for advanced queries

## Integration with Computed Styles

```rust
// Convert CSS font-family to FallbackChain
let chain = FallbackChain::from_families(&computed_styles.font_family);

// Or with full styling
let weight = match computed_styles.font_weight {
    FontWeight::Normal => 400,
    FontWeight::Bold => 700,
    FontWeight::Number(n) => n,
    _ => 400,
};

let chain = chain
    .with_weight(weight)
    .with_style(font_style_from_computed(computed_styles.font_style));
```

## Test Coverage

- 17 unit tests in `src/text/font/` modules
- 46+ integration tests in `tests/text/test_font_fallback.rs`
- Tests cover: construction, configuration, parsing, resolution, edge cases
- Tests handle both empty databases and system fonts

## Performance Considerations

1. **Font Database**: `FontDatabase::new()` loads all system fonts once; cache it
2. **Glyph Checks**: `has_glyph()` parses font data; consider caching results
3. **Chain Resolution**: O(n) where n is number of families in chain
4. **Emoji Detection**: O(1) lookup based on Unicode ranges

## Future Improvements

- Add font metrics caching for resolved fonts
- Support CSS `@font-face` loaded fonts
- Add font feature queries (OpenType features)
- Implement variable font axis support
