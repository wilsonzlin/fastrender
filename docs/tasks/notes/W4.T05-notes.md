# W4.T05: Text Shaping Pipeline - Implementation Notes

## Summary

This task implements the core text shaping pipeline that coordinates bidi analysis, script itemization, and text shaping into a unified process. The implementation integrates with the existing font system (W3.T16-T18) and provides a clean API for downstream tasks.

## Files Created

### Core Implementation
- `src/text/pipeline.rs` - Main shaping pipeline module (~1200 lines)

### Tests
- `tests/text_pipeline.rs` - Comprehensive integration tests (48 tests)

### Module Updates
- `src/text/mod.rs` - Added pipeline module export and re-exports

## API Overview

### Key Types

#### Direction
```rust
pub enum Direction {
    LeftToRight,
    RightToLeft,
}
```
Text direction for layout and rendering. Supports conversion to/from bidi levels and rustybuzz directions.

#### Script
```rust
pub enum Script {
    Common, Inherited, Unknown,
    Latin, Arabic, Hebrew, Greek, Cyrillic,
    Devanagari, Bengali, Tamil, Thai,
    Han, Hiragana, Katakana, Hangul,
}
```
Unicode script categories based on UAX #24. Includes:
- `detect(char) -> Script` - Detects script from character
- `is_neutral()` - Returns true for Common/Inherited/Unknown
- `to_harfbuzz()` - Converts to rustybuzz Script (ISO 15924 tags)

#### BidiAnalysis
```rust
pub struct BidiAnalysis {
    text: String,
    levels: Vec<Level>,
    base_level: Level,
    needs_reordering: bool,
}
```
Result of bidirectional text analysis. Methods:
- `analyze(text, style) -> Self` - Analyze text for bidi properties
- `needs_reordering()` - Whether RTL content requires reordering
- `level_at(idx)` / `direction_at(idx)` - Get level/direction at position
- `base_direction()` - Get base paragraph direction

#### ItemizedRun
```rust
pub struct ItemizedRun {
    pub start: usize,
    pub end: usize,
    pub text: String,
    pub script: Script,
    pub direction: Direction,
    pub level: u8,
}
```
A run of text with uniform script, direction, and bidi level.

#### FontRun
```rust
pub struct FontRun {
    pub text: String,
    pub start: usize,
    pub end: usize,
    pub font: Arc<LoadedFont>,
    pub script: Script,
    pub direction: Direction,
    pub level: u8,
    pub font_size: f32,
}
```
A run of text with an assigned font, ready for shaping.

#### GlyphPosition
```rust
pub struct GlyphPosition {
    pub glyph_id: u32,
    pub cluster: u32,
    pub x_offset: f32,
    pub y_offset: f32,
    pub x_advance: f32,
    pub y_advance: f32,
}
```
Information about a single positioned glyph.

#### ShapedRun
```rust
pub struct ShapedRun {
    pub text: String,
    pub start: usize,
    pub end: usize,
    pub glyphs: Vec<GlyphPosition>,
    pub direction: Direction,
    pub level: u8,
    pub advance: f32,
    pub font: Arc<LoadedFont>,
    pub font_size: f32,
}
```
A shaped run of text, ready for rendering.

#### ShapingPipeline
```rust
pub struct ShapingPipeline { ... }

impl ShapingPipeline {
    pub fn new() -> Self;
    pub fn shape(&self, text: &str, style: &ComputedStyle, font_context: &FontContext) -> Result<Vec<ShapedRun>>;
    pub fn shape_with_direction(&self, text: &str, style: &ComputedStyle, font_context: &FontContext, direction: Direction) -> Result<Vec<ShapedRun>>;
    pub fn measure_width(&self, text: &str, style: &ComputedStyle, font_context: &FontContext) -> Result<f32>;
}
```
Main entry point for text shaping. Coordinates all stages of the pipeline.

### Helper Functions
- `itemize_text(text, bidi) -> Vec<ItemizedRun>` - Itemize text into runs
- `assign_fonts(runs, style, font_context) -> Result<Vec<FontRun>>` - Assign fonts to runs

### ClusterMap
```rust
pub struct ClusterMap { ... }

impl ClusterMap {
    pub fn from_shaped_run(run: &ShapedRun) -> Self;
    pub fn glyph_for_char(char_idx: usize) -> Option<usize>;
    pub fn char_for_glyph(glyph_idx: usize) -> Option<usize>;
}
```
Maps between character and glyph positions. Useful for hit testing and cursor positioning.

## Usage Example

```rust
use fastrender::text::{ShapingPipeline, FontContext};
use fastrender::style::ComputedStyle;

let pipeline = ShapingPipeline::new();
let font_context = FontContext::new();
let style = ComputedStyle::default();

// Shape text
let runs = pipeline.shape("Hello, world!", &style, &font_context)?;
for run in runs {
    println!("Run: {} glyphs, {}px advance", run.glyphs.len(), run.advance);
}

// Measure width
let width = pipeline.measure_width("Hello", &style, &font_context)?;
```

## Pipeline Stages

1. **Bidi Analysis** - Uses `unicode-bidi` crate to implement UAX #9
   - Determines text direction at each position
   - Identifies RTL content requiring reordering

2. **Script Itemization** - Splits text into runs by:
   - Script changes (Latin â†’ Arabic, etc.)
   - Direction changes
   - Bidi level changes
   - Neutral scripts (Common, Inherited) merge with context

3. **Font Matching** - Assigns fonts using FontContext:
   - Tries font family list from ComputedStyle
   - Falls back through generic families
   - Verifies font has glyphs for run content

4. **Text Shaping** - Uses rustybuzz (HarfBuzz port):
   - Creates Face from font data
   - Sets direction, script on Unicode buffer
   - Shapes text to get glyph IDs and positions
   - Scales positions to font size

5. **Bidi Reordering** - Reorders runs for visual display:
   - Only if `bidi.needs_reordering()` is true
   - Reverses runs at each bidi level, highest to lowest

## Script Detection

The `Script::detect(char)` function uses Unicode character ranges:

| Script | Primary Ranges |
|--------|----------------|
| Latin | 0x0041-007A, 0x0080-024F, 0x1E00-1EFF |
| Arabic | 0x0600-06FF, 0x0750-077F, 0x08A0-08FF, 0xFB50-FDFF |
| Hebrew | 0x0590-05FF, 0xFB1D-FB4F |
| Greek | 0x0370-03FF, 0x1F00-1FFF |
| Cyrillic | 0x0400-04FF, 0x0500-052F |
| Han (CJK) | 0x4E00-9FFF, 0x3400-4DBF, 0x20000-2A6DF |
| Hiragana | 0x3040-309F |
| Katakana | 0x30A0-30FF, 0x31F0-31FF |
| Hangul | 0x1100-11FF, 0xAC00-D7AF |

## Dependencies

- `unicode-bidi` - UAX #9 bidi algorithm
- `rustybuzz` - Text shaping (HarfBuzz port)
- Uses existing `font_db`, `font_loader` from Wave 3

## Integration Points

### ComputedStyle Fields Used
- `font_family: Vec<String>` - Font family list
- `font_size: f32` - Font size in pixels
- `font_weight: u16` - Font weight (100-900)
- `font_style: FontStyle` - Normal/Italic/Oblique

### FontContext Methods Used
- `get_font(families, weight, italic, oblique) -> Option<LoadedFont>`
- `get_sans_serif() -> Option<LoadedFont>`
- `has_fonts() -> bool`

### LoadedFont Fields Used
- `data: Arc<Vec<u8>>` - Font binary data
- `index: u32` - Font face index
- `as_ttf_face() -> Result<Face>` - Get ttf-parser face

## Downstream Task Integration

### W4.T06: Line Breaking Algorithm
- Use `ShapedRun::advance` for calculating line widths
- Use `ClusterMap` for mapping break opportunities to glyph positions
- Use `ShapedRun::text` with `GlyphPosition::cluster` for break mapping

### W4.T07: Line Layout and Alignment
- Use `ShapedRun::glyphs` for positioning glyphs on lines
- Use `ShapedRun::direction` for RTL handling
- Use `ShapedRun::advance` for alignment calculations

### W4.T08: Text Fragment Generation
- Use `ShapedRun` data to create TextFragments
- Use `GlyphPosition` for fragment positioning
- Use `ShapedRun::font` for rendering

## Test Coverage

48 integration tests covering:
- Direction handling (3 tests)
- Script detection (12 tests) - All major scripts
- Bidi analysis (6 tests) - Empty, LTR, RTL, mixed
- Script itemization (10 tests) - Single/mixed scripts
- Shaping pipeline (17 tests) - Full pipeline, edge cases

## Future Improvements

1. **CSS direction property** - Currently defaults to LTR, should respect CSS direction
2. **Language support** - Set buffer language from style for better shaping
3. **Font fallback during shaping** - Fall back per-glyph when font lacks characters
4. **Complex script support** - Additional scripts (Thai, Myanmar, etc.)
5. **Ligature control** - Respect CSS font-variant-ligatures
6. **Kerning control** - Respect CSS font-kerning property

## Performance Considerations

- `Arc<LoadedFont>` for efficient font data sharing
- Runs are processed independently (parallelizable)
- No heap allocation for GlyphPosition (Copy)
- Scale factor computed once per run
