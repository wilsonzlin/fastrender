# Task W5.T03 Output Notes

## Implementation Summary

Implemented the stacking context tree for CSS paint ordering according to CSS 2.1 Appendix E:

- **StackingContext struct**: Represents a stacking context with z_index, children, fragments, and layer classifications
- **StackingContextReason enum**: 19 variants documenting why a stacking context was created
- **Layer classification**: Fragments organized into layers 3-6 (blocks, floats, inlines, positioned)
- **Tree building**: `build_stacking_tree()` and `build_stacking_tree_with_styles()` for constructing the tree
- **Z-index sorting**: Automatic sorting of child stacking contexts by z-index with tree-order tiebreaking
- **Paint order iteration**: `PaintOrderIterator` yields fragments in correct 7-layer paint order
- **StyledFragmentRef**: Wrapper associating fragments with computed styles for stacking context operations

The stacking context tree is built from the fragment tree and determines the correct paint order for CSS rendering.

## API Contracts

### Public Types

```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum StackingContextReason {
    Root,                    // Root element
    PositionedWithZIndex,    // position: relative/absolute + z-index != auto
    FixedPositioning,        // position: fixed
    StickyPositioning,       // position: sticky
    Opacity,                 // opacity < 1
    Transform,               // transform != none
    Filter,                  // filter != none (future)
    ClipPath,                // clip-path != none (future)
    Mask,                    // mask properties (future)
    MixBlendMode,            // mix-blend-mode != normal (future)
    Isolation,               // isolation: isolate (future)
    Perspective,             // perspective != none (future)
    BackdropFilter,          // backdrop-filter != none (future)
    Containment,             // contain: layout/paint/strict/content (future)
    FlexItemWithZIndex,      // flex item with z-index
    GridItemWithZIndex,      // grid item with z-index
    WillChange,              // will-change (future)
    ContainerType,           // container-type (future)
    TopLayer,                // top layer elements (future)
    OverflowClip,            // positioned + overflow hidden/scroll/auto
}

#[derive(Debug, Clone)]
pub struct StackingContext {
    pub z_index: i32,
    pub children: Vec<StackingContext>,
    pub fragments: Vec<FragmentNode>,
    pub layer3_blocks: Vec<FragmentNode>,
    pub layer4_floats: Vec<FragmentNode>,
    pub layer5_inlines: Vec<FragmentNode>,
    pub layer6_positioned: Vec<FragmentNode>,
    pub bounds: Rect,
    pub reason: StackingContextReason,
    pub tree_order: usize,
}

pub struct StyledFragmentRef<'a> {
    pub fragment: &'a FragmentNode,
    pub style: Option<Arc<ComputedStyles>>,
    pub tree_order: usize,
}
```

### Key Functions

```rust
// Check if an element creates a stacking context
pub fn creates_stacking_context(
    style: &ComputedStyles,
    parent_style: Option<&ComputedStyles>,
    is_root: bool,
) -> bool;

// Get the reason why an element creates a stacking context
pub fn get_stacking_context_reason(
    style: &ComputedStyles,
    parent_style: Option<&ComputedStyles>,
    is_root: bool,
) -> Option<StackingContextReason>;

// Build stacking tree from fragment tree
pub fn build_stacking_tree(
    root: &FragmentNode,
    root_style: Option<&ComputedStyles>,
    is_root_context: bool,
) -> StackingContext;

// Build stacking tree with style lookup function
pub fn build_stacking_tree_with_styles<F>(
    root: &FragmentNode,
    get_style: F,
) -> StackingContext
where
    F: Fn(&FragmentNode) -> Option<Arc<ComputedStyles>> + Clone;
```

### StackingContext Methods

```rust
impl StackingContext {
    pub fn new(z_index: i32) -> Self;
    pub fn with_reason(z_index: i32, reason: StackingContextReason, tree_order: usize) -> Self;
    pub fn root() -> Self;
    pub fn add_child(&mut self, child: StackingContext);
    pub fn add_fragment_to_layer(&mut self, fragment: FragmentNode, style: Option<&ComputedStyles>);
    pub fn negative_z_children(&self) -> Vec<&StackingContext>;
    pub fn zero_z_children(&self) -> Vec<&StackingContext>;
    pub fn positive_z_children(&self) -> Vec<&StackingContext>;
    pub fn sort_children(&mut self);
    pub fn compute_bounds(&mut self);
    pub fn fragment_count(&self) -> usize;
    pub fn total_fragment_count(&self) -> usize;
    pub fn iter_paint_order(&self) -> PaintOrderIterator<'_>;
}
```

## The 7-Layer Paint Order Algorithm

Within each stacking context, elements are painted in this order (CSS 2.1 Appendix E):

1. **Layer 1**: Background and borders of the stacking context root
2. **Layer 2**: Child stacking contexts with negative z-index (most negative first)
3. **Layer 3**: In-flow, non-inline-level descendants (block boxes in tree order)
4. **Layer 4**: Non-positioned floats (tree order)
5. **Layer 5**: In-flow, inline-level descendants (inline boxes and text in tree order)
6. **Layer 6**: Positioned descendants with z-index 0 or auto (tree order)
7. **Layer 7**: Child stacking contexts with positive z-index (least positive first)

## Stacking Context Creation Conditions

An element creates a stacking context if ANY of these conditions is met:

1. Root element (`<html>`)
2. Positioned element with z-index â‰  auto
3. Fixed positioning
4. Sticky positioning
5. Opacity < 1
6. Any transform (except none)
7. Filter property (except none) - future
8. Clip-path property (except none) - future
9. Mask properties - future
10. Mix-blend-mode (except normal) - future
11. Isolation: isolate - future
12. Perspective property (except none) - future
13. Backdrop-filter property (except none) - future
14. Containment properties - future
15. Flex items with z-index (child of flex container)
16. Grid items with z-index (child of grid container)
17. Will-change for stacking-triggering properties - future
18. Container-type (size or inline-size) - future
19. Top layer elements (fullscreen, popover, dialog) - future

Currently implemented: 1-6, 15-16, and positioned with overflow clip.

## Decisions Made

### Decision 1: Layer Classification Based on Style + Content

**Choice:** Fragments are classified into layers using both computed style and fragment content type
**Rationale:**
- ComputedStyles provides display and position information
- FragmentContent provides fallback classification for unstyled fragments
- Allows accurate layer assignment even with partial style information

### Decision 2: Tree Order for Stable Sorting

**Choice:** Each stacking context tracks its tree_order index
**Rationale:**
- CSS spec requires tree order as tiebreaker for equal z-index
- Ensures deterministic paint order
- Maintains correct document order when z-index values are equal

### Decision 3: Style Lookup Function Pattern

**Choice:** `build_stacking_tree_with_styles()` takes a closure for style lookup
**Rationale:**
- FragmentNode doesn't store style information directly
- Allows flexible integration with various style storage strategies
- Avoids coupling stacking context logic to specific style storage

### Decision 4: Separate Layer Vectors

**Choice:** StackingContext has separate vectors for each layer (3, 4, 5, 6)
**Rationale:**
- Clearer representation of CSS paint order layers
- Enables efficient iteration in paint order
- Makes debugging and inspection easier

### Decision 5: Float Detection Placeholder

**Choice:** `is_float()` currently returns false with TODO
**Rationale:**
- Float property not yet in ComputedStyles
- Easy to integrate when Float support is added
- Doesn't block current implementation

## Test Coverage

### Unit Tests (37 tests in src/paint/stacking.rs)

- Stacking context creation conditions (root, positioned, fixed, sticky, opacity, transform, flex/grid items)
- Z-index sorting (negative, zero, positive children)
- Tree order tiebreaking
- Layer classification (blocks, inlines, positioned)
- Bounds computation
- Fragment counting
- Paint order iteration

### Integration Tests (34 tests in tests/test_stacking.rs)

- All stacking context creation scenarios
- Tree building with and without styles
- Paint order verification
- Layer classification correctness
- Comprehensive z-index ordering

## Future Work

1. **Add remaining stacking context triggers**: filter, clip-path, mask, mix-blend-mode, isolation, perspective, backdrop-filter, contain, will-change, container-type, top layer
2. **Float support**: Implement Float in ComputedStyles and update `is_float()`
3. **Integration with painter**: Use stacking tree to drive paint order in Painter
4. **Performance optimization**: Consider lazy layer classification or caching
5. **Hit testing integration**: Use reverse paint order for correct hit testing

## File Outputs

- `src/paint/stacking.rs` - Main implementation (1387 lines)
- `src/paint/mod.rs` - Updated to export stacking module
- `tests/test_stacking.rs` - Integration tests (545 lines)
- `docs/tasks/notes/W5.T03-notes.md` - This file

## Verification

```bash
# Run unit tests
cargo test --lib paint::stacking
# Result: 37 passed

# Run integration tests
cargo test --test test_stacking
# Result: 34 passed

# Run clippy
cargo clippy --lib -- -D warnings
# Result: No warnings in stacking module

# Run full test suite
cargo test --lib
# Result: 1170 passed
```
