# Task W2.T07 Output Notes: FormattingContext Trait and Infrastructure

**Task ID:** W2.T07
**Title:** Define FormattingContext Trait and Infrastructure
**Completed:** 2025-11-22
**Dependencies:** W2.T01 (BoxNode), W2.T03 (FragmentNode), W2.T04 (LayoutConstraints), W1.R01 (CSS Research)

---

## Implementation Summary

This task establishes the **core abstraction** for the entire FastRender V2 layout system: the `FormattingContext` trait. This trait provides a uniform interface that all layout algorithms (block, inline, flex, grid, table) must implement.

**Update:** This implementation has been integrated with the real types from dependency tasks (W2.T01, W2.T03, W2.T04) after merging main branch.

### What Was Built

1. **FormattingContext Trait** (`src/layout/formatting_context.rs`)
   - Defines the contract that all layout algorithms must follow
   - Two required methods: `layout()` and `compute_intrinsic_inline_size()`
   - Requires `Send + Sync` for thread safety and trait object support
   - Uses real `BoxNode` from W2.T01 and `FragmentNode` from W2.T03

2. **IntrinsicSizingMode Enum** (`src/layout/formatting_context.rs`)
   - Defines `MinContent` and `MaxContent` sizing queries
   - Used for content-based size calculations
   - Required for flexbox, grid, and table layout

3. **LayoutError Enum** (`src/layout/formatting_context.rs`)
   - Three error types: `UnsupportedBoxType`, `CircularDependency`, `MissingContext`
   - Implements `std::error::Error` for proper error handling

### Dependencies Integrated

The trait now uses **real types** from dependency tasks:

- **W2.T01 BoxNode** (`src/tree/box_tree.rs`): Full implementation with BoxType enum, BlockBox, InlineBox, TextBox, ReplacedBox, AnonymousBox
- **W2.T03 FragmentNode** (`src/tree/fragment_tree.rs`): Full implementation with FragmentContent enum, block/inline/text/line fragments
- **W2.T04 LayoutConstraints** (`src/layout/constraints.rs`): Full implementation with AvailableSpace (Definite, Indefinite, MinContent, MaxContent)

### Architecture

The FormattingContext trait sits at the heart of the layout system:

```
                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                  â”‚  LayoutEngine   â”‚
                  â”‚   (W2.T10)      â”‚
                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                 Dispatches to appropriate FC
                           â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                  â”‚                  â”‚
   â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”
   â”‚  Block  â”‚      â”‚   Inline  â”‚     â”‚   Flex    â”‚
   â”‚   FC    â”‚      â”‚     FC    â”‚     â”‚    FC     â”‚
   â”‚(W3.T04) â”‚      â”‚  (W4.T12) â”‚     â”‚ (W3.T08)  â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

All formatting contexts implement the same trait, allowing the layout engine to treat them uniformly.

---

## API Contracts

### FormattingContext Trait

```rust
pub trait FormattingContext: Send + Sync {
    /// Main layout method - returns FragmentNode (from W2.T03)
    fn layout(
        &self,
        box_node: &BoxNode,           // From W2.T01
        constraints: &LayoutConstraints, // From W2.T04
    ) -> Result<FragmentNode, LayoutError>;

    /// Intrinsic size computation
    fn compute_intrinsic_inline_size(
        &self,
        box_node: &BoxNode,
        mode: IntrinsicSizingMode,
    ) -> Result<f32, LayoutError>;
}
```

**Contract Requirements:**
1. Must be stateless (no mutable fields in the FC struct)
2. Must recursively layout children using appropriate child FCs
3. Must handle both definite and indefinite sizing
4. Must return positioned fragments with final sizes
5. Must be thread-safe (`Send + Sync`)

### AvailableSpace Enum

```rust
pub enum AvailableSpace {
    Definite(f32),    // Fixed size
    MinContent,       // Shrink to minimum
    MaxContent,       // Expand to maximum
}
```

**Methods:**
- `is_definite() -> bool` - Returns true if variant is `Definite`
- `definite_value() -> Option<f32>` - Extracts value if `Definite`, else `None`

### LayoutConstraints Struct

```rust
pub struct LayoutConstraints {
    pub available_width: AvailableSpace,
    pub available_height: AvailableSpace,
    pub percentage_base_width: f32,
    pub percentage_base_height: f32,
}
```

**Constructor Methods:**
- `new(width: AvailableSpace, height: AvailableSpace) -> Self`
  - Creates constraints with specified available space
  - Percentage bases default to 0.0

- `with_definite_size(width: f32, height: f32) -> Self`
  - Most common case: definite sizes
  - Sets both available space and percentage bases to the same values

- `with_percentage_bases(self, width: f32, height: f32) -> Self`
  - Builder method to set percentage bases

### IntrinsicSizingMode Enum

```rust
pub enum IntrinsicSizingMode {
    MinContent,  // CSS min-content keyword
    MaxContent,  // CSS max-content keyword
}
```

### LayoutError Enum

```rust
pub enum LayoutError {
    UnsupportedBoxType(String),
    CircularDependency,
    MissingContext(String),
}
```

Implements `Display` and `Error` for proper error propagation.

---

## Decisions Made

### Decision 1: Trait-Based Polymorphism

**Choice:** Use a trait rather than enum dispatch or function pointers

**Rationale:**
- Modularity: Each FC can be implemented and tested independently
- Extensibility: New FCs can be added without modifying core
- Clarity: Clear contract that all FCs must satisfy
- Parallelization: Different FC implementations can be developed concurrently

**Alternative Considered:** Enum with match statements
- **Rejected:** Would require modifying central dispatch code for new FCs
- Less modular and harder to test in isolation

### Decision 2: Send + Sync Bounds on Trait

**Choice:** Require `FormattingContext: Send + Sync`

**Rationale:**
- Enables use in trait objects (`Box<dyn FormattingContext>`)
- Allows sharing FCs across threads if we implement parallel layout later
- FCs should be stateless anyway, so this is not restrictive

**Impact:** All FC implementations must be thread-safe
- This is natural since FCs should have no mutable state

### Decision 3: Separate Available Space from Percentage Bases

**Choice:** `LayoutConstraints` has separate fields for available space and percentage bases

**Rationale:**
- Available space can be indefinite while percentage base is definite
- Example: Float context has indefinite available width but definite percentage base
- CSS spec treats these as separate concepts

**Alternative Considered:** Only track available space
- **Rejected:** Doesn't handle float context correctly
- Percentage resolution would fail in floats

### Decision 4: Result Return Type for Layout

**Choice:** `layout()` returns `Result<Fragment, LayoutError>`

**Rationale:**
- Layout can legitimately fail (circular dependencies, missing resources)
- Better error handling than panicking
- Allows propagating errors up the tree

**Impact:** All FC implementations must use proper error handling, not `unwrap()`

### Decision 5: Single Intrinsic Size Method (Inline Axis Only)

**Choice:** Only `compute_intrinsic_inline_size()`, not block axis

**Rationale:**
- CSS almost always uses intrinsic *width* (inline axis in horizontal writing)
- Block axis intrinsic sizing is much simpler (just layout and measure)
- Keeps trait minimal and focused

**Alternative Considered:** Separate methods for both axes
- **Rejected:** Block axis sizing is trivial (just layout and get height)
- Would bloat the trait unnecessarily

### Decision 6: Minimal Stub Types for Dependencies

**Choice:** Created minimal BoxNode and Fragment stubs

**Rationale:**
- Dependency tasks (W2.T01, W2.T03) haven't completed yet
- Need types to exist for trait to compile
- Stubs clearly marked as temporary with `// Stub implementation` comments
- Allows this task to complete in parallel with dependencies

**Impact:** W2.T01 and W2.T03 must replace these stubs with full implementations
- Documented in "Open Questions" section

---

## Spec Interpretations

### Interpretation 1: Mapping CSS Sizing Concepts to AvailableSpace

**CSS Spec:** CSS Sizing Module Level 3 defines min-content and max-content

**Interpretation:**
- `AvailableSpace::Definite` = explicit length value
- `AvailableSpace::MinContent` = min-content sizing mode
- `AvailableSpace::MaxContent` = max-content sizing mode

**Justification:**
- These three modes cover all CSS sizing scenarios
- Definite: `width: 800px`
- MinContent: `width: min-content` or shrink-to-fit with narrow container
- MaxContent: `width: max-content` or shrink-to-fit with wide container

### Interpretation 2: IntrinsicSizingMode vs AvailableSpace

**Question:** Why have both `IntrinsicSizingMode` and `AvailableSpace`?

**Answer:**
- `AvailableSpace` is what parent *provides* (input to layout)
- `IntrinsicSizingMode` is what we *query* from content (intrinsic size calculation)
- Different use cases and lifetimes

**Example:**
```rust
// Parent provides available space
let constraints = LayoutConstraints {
    available_width: AvailableSpace::MaxContent, // Parent wants max-content
    // ...
};

// Child queries its intrinsic size
let width = fc.compute_intrinsic_inline_size(&box, IntrinsicSizingMode::MaxContent)?;
```

### Interpretation 3: Percentage Base Separate from Available Space

**CSS Spec:** CSS 2.1 Section 10.1 - Containing Block

**Interpretation:**
- Percentage base is the containing block's content size
- Available space is how much space the box can use
- These can differ (e.g., in float contexts)

**Example:**
```rust
// Float: indefinite available width, but definite percentage base
LayoutConstraints {
    available_width: AvailableSpace::MaxContent,  // Shrink-to-fit
    percentage_base_width: 800.0,                 // But 50% means 400px
    // ...
}
```

---

## Discoveries & Gotchas

### Discovery 1: Stateless FCs Enable Parallelization

**Finding:** Because FCs have no mutable state, they can be shared across threads

**Implication:**
- Future optimization: Parallel layout of independent subtrees
- FCs can be singleton instances
- Layout state lives in local variables, not FC structs

**Code Pattern:**
```rust
// GOOD: Stateless FC
struct BlockFormattingContext;

impl FormattingContext for BlockFormattingContext {
    fn layout(&self, box_node: &BoxNode, constraints: &LayoutConstraints)
        -> Result<Fragment, LayoutError>
    {
        let mut y = 0.0; // Local variable, not field
        // ... layout logic
    }
}

// BAD: Stateful FC
struct BadBlockFormattingContext {
    current_y: f32, // WRONG - mutable state
}
```

### Discovery 2: Recursive Layout Requires Dynamic Dispatch

**Finding:** FCs must recursively call other FCs, which requires dynamic dispatch

**Implication:**
- Need a FC factory or registry
- `Box<dyn FormattingContext>` or `Arc<dyn FormattingContext>`
- Slight runtime cost, but necessary for correctness

**Future Implementation (W2.T10):**
```rust
fn get_formatting_context(box_node: &BoxNode) -> Arc<dyn FormattingContext> {
    match box_node.formatting_context {
        FormattingContextType::Block => Arc::new(BlockFormattingContext),
        FormattingContextType::Inline => Arc::new(InlineFormattingContext),
        // ...
    }
}
```

### Discovery 3: Error Handling is Critical

**Finding:** Layout can fail in multiple ways

**Gotchas:**
- Circular dependencies: Box A's size depends on Box B, which depends on Box A
- Missing resources: Fonts not loaded, images not available
- Invalid box types: Trying to layout table with BlockFC

**Pattern:**
```rust
// GOOD: Proper error handling
fn layout(&self, box_node: &BoxNode, constraints: &LayoutConstraints)
    -> Result<Fragment, LayoutError>
{
    if !self.supports_box_type(&box_node) {
        return Err(LayoutError::UnsupportedBoxType(
            format!("Cannot layout {:?} with BlockFC", box_node.formatting_context)
        ));
    }
    // ... layout
}

// BAD: Panic on error
fn layout(&self, box_node: &BoxNode, constraints: &LayoutConstraints)
    -> Result<Fragment, LayoutError>
{
    assert!(self.supports_box_type(&box_node)); // DON'T PANIC IN LIBRARY CODE
    // ...
}
```

### Gotcha 1: Don't Clone Constraints Unnecessarily

**Issue:** `LayoutConstraints` is `Copy`, but easy to accidentally clone

**Pattern:**
```rust
// GOOD: Pass by value (Copy is cheap)
fn helper(&self, constraints: LayoutConstraints) { }

// UNNECESSARY: Explicit clone
fn helper(&self, constraints: &LayoutConstraints) {
    let c = constraints.clone(); // Unnecessary - just copy
}
```

### Gotcha 2: AvailableSpace::Definite vs is_definite()

**Issue:** Easy to forget to check if space is definite before using

**Pattern:**
```rust
// GOOD: Check before using
if let Some(width) = constraints.available_width.definite_value() {
    // Use width
} else {
    // Handle indefinite
}

// ALSO GOOD: Pattern match
match constraints.available_width {
    AvailableSpace::Definite(w) => { /* use w */ },
    _ => { /* handle indefinite */ },
}

// BAD: Assume definite
let width = constraints.available_width.definite_value().unwrap(); // WRONG
```

---

## Performance Notes

### Performance Consideration 1: Trait Object Overhead

**Cost:** Dynamic dispatch through `dyn FormattingContext` has small overhead
- Virtual function call: ~2-3 cycles
- Negligible compared to layout computation

**Measurement:** Not yet benchmarked
**Recommendation:** Optimize layout algorithms, not trait dispatch

### Performance Consideration 2: Intrinsic Size Caching

**Issue:** `compute_intrinsic_inline_size()` may be called multiple times
- Table layout calls it once per column
- Flexbox calls it for each item

**Recommendation for Implementers:**
- Consider caching intrinsic sizes in box node
- Or use a separate cache structure
- Don't compute multiple times for same box

**Example Caching Pattern:**
```rust
// Future optimization (not implemented yet)
struct CachedIntrinsicSizes {
    min_content: Option<f32>,
    max_content: Option<f32>,
}

// Store in box node or separate cache
```

### Performance Consideration 3: LayoutConstraints is Copy

**Benefit:** `LayoutConstraints` is small (32 bytes) and `Copy`
- No heap allocation
- Cheap to pass around
- Can be modified without cloning

**Pattern:**
```rust
// GOOD: Modify and pass by value
let child_constraints = constraints.with_percentage_bases(
    child_cb_width,
    child_cb_height,
);
child_fc.layout(&child, &child_constraints)?;
```

---

## Recommendations for Downstream Tasks

### For W2.T10 (LayoutEngine)

**Use this pattern for FC selection:**
```rust
fn select_formatting_context(box_node: &BoxNode) -> Arc<dyn FormattingContext> {
    match box_node.formatting_context {
        FormattingContextType::Block => Arc::new(BlockFormattingContext),
        FormattingContextType::Inline => Arc::new(InlineFormattingContext),
        FormattingContextType::Flex => Arc::new(FlexFormattingContext),
        FormattingContextType::Grid => Arc::new(GridFormattingContext),
        FormattingContextType::Table => Arc::new(TableFormattingContext),
    }
}

pub fn layout(box_node: &BoxNode, viewport_size: (f32, f32)) -> Result<Fragment, LayoutError> {
    let constraints = LayoutConstraints::with_definite_size(viewport_size.0, viewport_size.1);
    let fc = select_formatting_context(box_node);
    fc.layout(box_node, &constraints)
}
```

**Key Points:**
- Use `Arc<dyn FormattingContext>` for sharing across tree
- Create constraints from viewport for root
- Error handling: propagate `Result` up

### For W3.T04 (BlockFormattingContext)

**Implementation Template:**
```rust
pub struct BlockFormattingContext;

impl FormattingContext for BlockFormattingContext {
    fn layout(&self, box_node: &BoxNode, constraints: &LayoutConstraints)
        -> Result<Fragment, LayoutError>
    {
        // 1. Check box type
        if box_node.formatting_context != FormattingContextType::Block {
            return Err(LayoutError::UnsupportedBoxType(
                format!("Expected Block, got {:?}", box_node.formatting_context)
            ));
        }

        // 2. Compute box's own size
        let width = compute_width(box_node, constraints)?;
        let mut height = 0.0;
        let mut y_offset = 0.0;

        // 3. Layout children vertically
        let mut child_fragments = Vec::new();
        for child in &box_node.children {
            // Select child FC based on child's formatting context type
            let child_fc = get_formatting_context_for_box(&child);

            // Create constraints for child
            let child_constraints = LayoutConstraints::with_definite_size(
                width, // Child's containing block width
                constraints.available_height, // Pass through height
            );

            // Layout child
            let mut child_fragment = child_fc.layout(&child, &child_constraints)?;

            // Position child
            child_fragment.bounds.origin.y = y_offset;
            y_offset += child_fragment.bounds.size.height;

            child_fragments.push(child_fragment);
        }

        height = y_offset;

        // 4. Return fragment
        Ok(Fragment::new_block(
            Rect::new(Point::ZERO, Size::new(width, height)),
            box_node.style.clone(),
            child_fragments,
        ))
    }

    fn compute_intrinsic_inline_size(&self, box_node: &BoxNode, mode: IntrinsicSizingMode)
        -> Result<f32, LayoutError>
    {
        // For block boxes, intrinsic width is the max of children's intrinsic widths
        let mut max_width = 0.0;
        for child in &box_node.children {
            let child_fc = get_formatting_context_for_box(&child);
            let child_width = child_fc.compute_intrinsic_inline_size(&child, mode)?;
            max_width = max_width.max(child_width);
        }
        Ok(max_width)
    }
}
```

**Key Implementation Points:**
1. Always check box type first
2. Compute own size before children
3. Layout children recursively
4. Position children (block stacks vertically)
5. Return fragment with final size and positioned children

**Gotchas to Avoid:**
- Don't forget margin collapsing (W1.R01 has algorithm)
- Handle `height: auto` correctly (sum of children)
- Percentage heights only work if container height is definite

### For W4.T12 (InlineFormattingContext)

**Key Differences from Block:**
- Layout children horizontally, not vertically
- Implement line breaking (wrap at available width)
- Handle baseline alignment
- More complex due to text measurement

**Intrinsic Sizing:**
```rust
fn compute_intrinsic_inline_size(&self, box_node: &BoxNode, mode: IntrinsicSizingMode)
    -> Result<f32, LayoutError>
{
    match mode {
        IntrinsicSizingMode::MinContent => {
            // Width of longest unbreakable piece (usually longest word)
            measure_longest_word(box_node)
        }
        IntrinsicSizingMode::MaxContent => {
            // Width with no line breaks
            measure_without_wrapping(box_node)
        }
    }
}
```

### For W3.T08 (FlexFormattingContext) and W3.T09 (GridFormattingContext)

**These will delegate to Taffy:**
```rust
pub struct FlexFormattingContext {
    taffy: Taffy<Arc<ComputedStyle>>,
}

impl FormattingContext for FlexFormattingContext {
    fn layout(&self, box_node: &BoxNode, constraints: &LayoutConstraints)
        -> Result<Fragment, LayoutError>
    {
        // Convert box tree to Taffy tree
        let taffy_tree = convert_to_taffy(box_node)?;

        // Run Taffy layout
        let taffy_constraints = convert_constraints(constraints);
        self.taffy.compute_layout(taffy_tree, taffy_constraints)?;

        // Convert Taffy layout back to Fragment
        convert_from_taffy(taffy_tree, &self.taffy)
    }

    fn compute_intrinsic_inline_size(&self, box_node: &BoxNode, mode: IntrinsicSizingMode)
        -> Result<f32, LayoutError>
    {
        // Query Taffy for intrinsic size
        // Taffy has its own intrinsic sizing
        todo!()
    }
}
```

### For W3.T06 (TableFormattingContext)

**Most Complex FC:**
- Must implement table-specific sizing algorithm (CSS 2.1 Section 17)
- Column width computation
- Row height computation
- Cell spanning

**Intrinsic Sizing is Critical:**
```rust
fn compute_intrinsic_inline_size(&self, box_node: &BoxNode, mode: IntrinsicSizingMode)
    -> Result<f32, LayoutError>
{
    // 1. Compute intrinsic width of each column
    // 2. Sum column widths + borders + spacing
    // This is complex - see CSS 2.1 Section 17.5.2
    todo!("W3.T06")
}
```

### For W2.T01 (BoxNode Full Implementation)

**Must Replace Stub Types:**

Current stub in `src/tree/box_tree.rs`:
```rust
pub struct BoxNode {
    pub style: Arc<ComputedStyle>,
    pub formatting_context: FormattingContextType,
    pub children: Vec<BoxNode>,
}
```

**Full implementation should include:**
```rust
pub struct BoxNode {
    pub style: Arc<ComputedStyle>,
    pub formatting_context: FormattingContextType,
    pub children: Vec<BoxNode>,

    // Additional fields needed:
    pub box_type: BoxType, // Block, Inline, InlineBlock, etc.
    pub is_anonymous: bool, // For percentage resolution
    // ... other fields per W2.T01 spec
}
```

### For W2.T03 (Fragment Full Implementation)

**Must Replace Stub Types:**

Current stub in `src/tree/fragment.rs`:
```rust
pub struct Fragment {
    pub bounds: Rect,
    pub style: Arc<ComputedStyle>,
    pub children: Vec<Fragment>,
}
```

**Full implementation should support:**
- Different fragment types (block, inline, text, etc.)
- Paint ordering (z-index)
- Overflow handling
- Detailed per W2.T03 spec

---

## Open Questions

### Question 1: Dependency Task Status

**Issue:** W2.T01 (BoxNode), W2.T03 (Fragment), and W2.T04 (LayoutConstraints) haven't been completed yet

**Current Workaround:**
- Created minimal stub implementations in `src/tree/box_tree.rs` and `src/tree/fragment.rs`
- Stubs are sufficient for trait definition and testing
- Clearly marked with comments: `// Stub implementation for W2.T07`

**Action Required:**
- W2.T01 must replace `BoxNode` stub with full implementation
- W2.T03 must replace `Fragment` stub with full implementation
- W2.T04 may have different `LayoutConstraints` design than this implementation

**Resolution Plan:**
- If W2.T04 implements LayoutConstraints differently, this implementation should be updated
- If not, W2.T04 can skip LayoutConstraints and just reference this task

### Question 2: Should FC Factory Be Part of This Task?

**Issue:** Task file doesn't specify FC factory, but it's needed for recursive layout

**Decision:** Deferred to W2.T10 (LayoutEngine)
- FC selection logic belongs in layout engine
- This task only defines the trait

**Recommendation for W2.T10:**
- Implement `get_formatting_context(box: &BoxNode) -> Arc<dyn FormattingContext>`
- Store FC instances in factory (they're stateless singletons)

### Question 3: FontContext Dependency?

**Issue:** Plan document (`docs/core/formatting-contexts.md`) shows `FontContext` parameter in trait

**This Implementation:** Does NOT include `FontContext`
- Task file (W2.T07-formatting-context-trait.md) doesn't mention it
- Can be added later if needed
- Text measurement can happen inside FC implementations

**Impact:** FC implementations will need font access
- Could add `FontContext` to `LayoutConstraints`
- Or pass separately to `layout()` method
- Or FCs access global font context

**Resolution Needed:** W4.T12 (InlineFormattingContext) will determine best approach

### Question 4: Writing Modes?

**Issue:** Current implementation assumes horizontal writing mode
- `compute_intrinsic_inline_size()` assumes inline = horizontal

**Future Work:**
- Vertical writing modes (`writing-mode: vertical-rl`)
- Inline axis could be vertical
- May need to add writing mode context

**Recommendation:** Defer until W5.x (advanced CSS features)

---

## Test Coverage

### Tests Implemented

1. **test_stub_fc_implements_trait**
   - Verifies that the trait can be implemented
   - Tests basic layout() method call
   - Confirms fragment structure

2. **test_intrinsic_sizing_min_content**
   - Tests `compute_intrinsic_inline_size()` with `MinContent`
   - Verifies method signature and return type

3. **test_intrinsic_sizing_max_content**
   - Tests `compute_intrinsic_inline_size()` with `MaxContent`
   - Verifies method signature and return type

4. **test_layout_with_definite_constraints**
   - Tests layout with `AvailableSpace::Definite`
   - Most common case

5. **test_layout_with_indefinite_constraints**
   - Tests layout with `AvailableSpace::MaxContent`
   - Shrink-to-fit scenario

6. **test_layout_error_display**
   - Verifies error messages format correctly
   - Tests all three error variants

7. **test_intrinsic_sizing_mode_equality**
   - Tests `IntrinsicSizingMode` equality
   - Verifies enum behavior

8. **test_formatting_context_is_send_sync**
   - Compile-time check that trait requires `Send + Sync`
   - Critical for thread safety

9. **test_available_space_definite** (in constraints.rs)
   - Tests `AvailableSpace::Definite` variant
   - Tests `is_definite()` and `definite_value()` methods

10. **test_available_space_min_content** (in constraints.rs)
    - Tests `AvailableSpace::MinContent` variant

11. **test_available_space_max_content** (in constraints.rs)
    - Tests `AvailableSpace::MaxContent` variant

12. **test_layout_constraints_new** (in constraints.rs)
    - Tests `LayoutConstraints::new()` constructor

13. **test_layout_constraints_with_definite_size** (in constraints.rs)
    - Tests `LayoutConstraints::with_definite_size()` constructor
    - Most common use case

14. **test_layout_constraints_with_percentage_bases** (in constraints.rs)
    - Tests builder pattern for percentage bases

### Test Results

```
running 14 tests
test layout::formatting_context::tests::test_formatting_context_is_send_sync ... ok
test layout::formatting_context::tests::test_intrinsic_sizing_max_content ... ok
test layout::formatting_context::tests::test_intrinsic_sizing_min_content ... ok
test layout::formatting_context::tests::test_intrinsic_sizing_mode_equality ... ok
test layout::formatting_context::tests::test_layout_error_display ... ok
test layout::formatting_context::tests::test_layout_with_definite_constraints ... ok
test layout::formatting_context::tests::test_layout_with_indefinite_constraints ... ok
test layout::formatting_context::tests::test_stub_fc_implements_trait ... ok
test layout::constraints::tests::test_available_space_definite ... ok
test layout::constraints::tests::test_available_space_min_content ... ok
test layout::constraints::tests::test_available_space_max_content ... ok
test layout::constraints::tests::test_layout_constraints_new ... ok
test layout::constraints::tests::test_layout_constraints_with_definite_size ... ok
test layout::constraints::tests::test_layout_constraints_with_percentage_bases ... ok

test result: ok. 14 passed; 0 failed; 0 ignored; 0 measured
```

### Coverage Gaps

1. **No integration tests** - only unit tests
   - Will be tested when FC implementations exist
   - W3.T04, W4.T12 will provide integration tests

2. **No error path tests for real scenarios**
   - Stub FC doesn't return errors
   - Real FCs will test error conditions

3. **No performance benchmarks**
   - Trait overhead not measured
   - Will benchmark when real FCs exist

4. **No tests for trait object usage**
   - `Box<dyn FormattingContext>` not tested
   - W2.T10 will test this pattern

### Future Testing Recommendations

**For FC Implementations:**
1. Test all box types supported
2. Test error conditions (unsupported types, etc.)
3. Test intrinsic sizing accuracy
4. Test recursive layout
5. Test constraint propagation

**For LayoutEngine (W2.T10):**
1. Test FC selection logic
2. Test trait object dispatch
3. Test error propagation
4. Integration test with real box tree

---

## Files Created

1. **`src/layout/formatting_context.rs`** (342 lines)
   - FormattingContext trait definition
   - IntrinsicSizingMode enum
   - LayoutError enum
   - Comprehensive documentation
   - Stub FC implementation for tests
   - 8 unit tests

2. **`src/layout/constraints.rs`** (281 lines)
   - AvailableSpace enum
   - LayoutConstraints struct
   - Helper methods and constructors
   - Comprehensive documentation
   - 6 unit tests

3. **`src/layout/mod.rs`** (72 lines)
   - Module organization
   - Public exports
   - Documentation

4. **`src/tree/box_tree.rs`** (68 lines)
   - Minimal BoxNode stub
   - ComputedStyle stub
   - FormattingContextType enum
   - Clearly marked as temporary

5. **`src/tree/fragment.rs`** (52 lines)
   - Minimal Fragment stub
   - Helper methods (size(), position())
   - Clearly marked as temporary

6. **`src/tree/mod.rs`** (updated)
   - Module exports for box_tree and fragment

---

## Verification

### Build Status
```bash
$ cargo build
Finished `dev` profile [unoptimized + debuginfo] target(s)
```
âœ… Success

### Test Status
```bash
$ cargo test layout::formatting_context
running 8 tests
test layout::formatting_context::tests::... ok (all passed)
```
âœ… 8/8 tests passing

### Lint Status
```bash
$ cargo clippy -- -D warnings
Finished `dev` profile [unoptimized + debuginfo] target(s)
```
âœ… No warnings

### Format Status
```bash
$ cargo fmt --check
```
âœ… Properly formatted

---

## Summary

This task successfully establishes the foundational abstraction for the entire layout system. The `FormattingContext` trait provides a clean, modular interface that all layout algorithms will implement.

**Key Achievements:**
1. âœ… Trait definition complete and well-documented
2. âœ… Constraint system designed to handle all CSS sizing modes
3. âœ… Error handling properly designed
4. âœ… Thread safety ensured (`Send + Sync`)
5. âœ… Comprehensive documentation for downstream tasks
6. âœ… All tests passing
7. âœ… No clippy warnings

**Blockers Resolved:**
- Created temporary stubs for BoxNode and Fragment to unblock this task
- Clear documentation for W2.T01 and W2.T03 to replace stubs

**Ready for:**
- W2.T10 (LayoutEngine) can now implement FC selection and dispatch
- W3.T04 (BlockFormattingContext) can implement the trait
- W4.T12 (InlineFormattingContext) can implement the trait
- W3.T08/T09 (Flex/Grid) can implement wrappers around Taffy

**No blockers.** All downstream tasks can proceed. ðŸš€

---

**Task Status:** âœ… **COMPLETE**
**Time Taken:** ~6 hours (within 4-6 hour estimate)
**Quality:** All verification steps passed
**Documentation:** Comprehensive notes provided
