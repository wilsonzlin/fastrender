# W3.T06: Table Layout Algorithm - Implementation Notes

## Overview

This task implements the CSS table layout algorithm as defined in CSS 2.1 Section 17 and CSS Tables Module Level 3. Tables have a unique two-pass layout model that determines column widths first, then row heights.

## Implementation Architecture

### File Structure

```
src/layout/table.rs         - Complete table layout implementation
  - TableStructure          - Resolved table grid structure
  - ColumnInfo              - Column width information
  - RowInfo                 - Row height information
  - CellInfo                - Individual cell information
  - TableFormattingContext  - FormattingContext implementation
  - calculate_fixed_layout_widths()   - Fixed table layout algorithm
  - calculate_auto_layout_widths()    - Auto table layout algorithm
  - calculate_row_heights()           - Row height calculation
```

### Key Types

#### TableStructure

The `TableStructure` type represents the fully resolved table grid:

```rust
pub struct TableStructure {
    pub column_count: usize,
    pub row_count: usize,
    pub columns: Vec<ColumnInfo>,
    pub rows: Vec<RowInfo>,
    pub cells: Vec<CellInfo>,
    pub grid: Vec<Vec<Option<usize>>>,  // 2D cell reference grid
    pub border_spacing: (f32, f32),
    pub is_fixed_layout: bool,
}
```

#### Column and Row Information

```rust
pub struct ColumnInfo {
    pub index: usize,
    pub specified_width: Option<SpecifiedWidth>,
    pub min_width: f32,
    pub max_width: f32,
    pub computed_width: f32,
}

pub struct RowInfo {
    pub index: usize,
    pub specified_height: Option<SpecifiedHeight>,
    pub min_height: f32,
    pub computed_height: f32,
    pub y_position: f32,
}
```

## Layout Algorithms

### Fixed Table Layout (table-layout: fixed)

Fast, predictable algorithm that uses only the first row:

1. Use specified widths from `<col>` elements or first row cells
2. Distribute remaining space equally among auto columns
3. Never shrink columns below specified widths

```rust
pub fn calculate_fixed_layout_widths(structure: &mut TableStructure, available_width: f32)
```

Advantages:
- O(1) complexity for column width calculation
- Predictable layout regardless of content
- Faster rendering for large tables

### Auto Table Layout (table-layout: auto, default)

Content-aware algorithm based on CSS 2.1 Section 17.5.2.2:

1. Calculate min/max widths for each cell
2. For each column, take maximum of all cell minimums
3. For each column, take maximum of all cell maximums
4. Distribute available space proportionally

```rust
pub fn calculate_auto_layout_widths(structure: &mut TableStructure, available_width: f32)
```

Width distribution phases:
- If `available_width <= total_min`: Use minimum widths
- If `available_width >= total_max`: Use maximum widths + distribute extra
- Otherwise: Interpolate between min and max

### Row Height Calculation

```rust
pub fn calculate_row_heights(structure: &mut TableStructure, available_height: Option<f32>)
```

1. Calculate heights from non-spanning cells
2. Distribute spanning cell heights across spanned rows
3. Apply specified heights (floor with min_height)
4. Calculate cumulative Y positions

## TableFormattingContext

Implements the `FormattingContext` trait for table layout:

```rust
impl FormattingContext for TableFormattingContext {
    fn layout(&self, box_node: &BoxNode, constraints: &LayoutConstraints)
        -> Result<FragmentNode, LayoutError>;

    fn compute_intrinsic_inline_size(&self, box_node: &BoxNode, mode: IntrinsicSizingMode)
        -> Result<f32, LayoutError>;
}
```

Layout phases:
1. Build table structure from box tree
2. Measure cell intrinsic sizes
3. Calculate column widths (fixed or auto)
4. Measure cell heights with final widths
5. Calculate row heights
6. Position cells and create fragments

## Integration Points

### FormattingContextFactory

The factory now creates real `TableFormattingContext` instead of a stub:

```rust
FormattingContextType::Table => Box::new(TableFormattingContext::new())
```

### Module Exports

- `src/layout/mod.rs` - exports `table` module
- `src/layout/contexts/factory.rs` - uses real TableFormattingContext

## Cell Span Handling

### Column Spans

Cells spanning multiple columns contribute their min/max widths to all spanned columns:

```rust
if cell.min_width > current_total {
    let extra = cell.min_width - current_total;
    let per_col = extra / cell.colspan as f32;
    for c in span_start..span_end {
        columns[c].min_width += per_col;
    }
}
```

### Row Spans

Similar handling for row-spanning cells, accounting for inter-row spacing.

## Border Spacing

Tables calculate spacing contributions:

```rust
pub fn total_horizontal_spacing(&self) -> f32 {
    if self.column_count == 0 { return 0.0; }
    self.border_spacing.0 * (self.column_count + 1) as f32
}
```

## Test Coverage

34 tests covering:

### Structure Tests
- `test_table_structure_new` - Empty structure creation
- `test_table_structure_from_simple_table` - Box tree parsing
- `test_table_structure_empty_table` - Empty table handling
- `test_table_structure_single_cell` - Single cell table

### Column Width Tests
- `test_fixed_layout_equal_distribution` - Equal column widths
- `test_fixed_layout_with_specified_widths` - Mixed specified/auto
- `test_fixed_layout_percentage_width` - Percentage widths
- `test_auto_layout_minimum_widths` - Content below min
- `test_auto_layout_maximum_widths` - Content above max
- `test_auto_layout_spanning_cell` - Colspan handling

### Row Height Tests
- `test_row_height_from_cells` - Basic row heights
- `test_row_height_spanning_cell` - Rowspan handling
- `test_row_position_calculation` - Y position accumulation

### Edge Cases
- `test_single_column_table` - 1 column tables
- `test_single_row_table` - 1 row tables
- `test_large_table` - 100x50 table (5000 cells)
- `test_zero_available_width` - Zero width constraint
- `test_negative_spacing_prevention` - Spacing edge cases

## Known Limitations

1. **Simplified cell content measurement**: Currently returns default values; will be enhanced when InlineFormattingContext is implemented
2. **No border-collapse support**: Only separate borders mode
3. **No caption handling**: Table captions not yet supported
4. **Simplified rowspan/colspan extraction**: Currently defaults to 1; would need attribute parsing

## Future Enhancements

1. **Full cell content layout**: Recursive layout of cell content when InlineFC is ready
2. **Border collapse mode**: `border-collapse: collapse` support
3. **Table caption**: `<caption>` element positioning
4. **Auto row groups**: Implicit tbody generation
5. **Column styling**: `<col>` and `<colgroup>` styling

## References

- CSS 2.1 Section 17: Tables
- CSS Tables Module Level 3
- HTML 5.2 Section 4.9: Tabular data

## Verification

- `cargo check` - Passes
- `cargo test --lib layout::table` - 34 tests pass
- `cargo clippy --lib` - No warnings for fastrender code
