# W5.T02: Display List Builder Implementation Notes

## Overview

This task implements the Display List Builder, which converts the Fragment Tree (positioned boxes) into a display list using the types defined in W5.T01. The builder walks the fragment tree depth-first and emits paint commands in correct CSS paint order.

## Implementation Structure

### Module Organization

```
src/paint/
  mod.rs                  - Paint module with exports
  display_list.rs         - Display list types (W5.T01)
  display_list_builder.rs - Fragment tree to display list conversion (W5.T02)
  painter.rs              - Direct fragment tree painter
```

### Integration with W5.T01

The builder uses display list types from `display_list.rs` (W5.T01):

- `DisplayItem` - Enum with FillRect, Text, Image, PushClip, PopClip, etc.
- `DisplayList` - Container with push(), items(), len(), optimize(), cull()
- `FillRectItem`, `TextItem`, `ImageItem`, `ClipItem`, `OpacityItem`, etc.

### DisplayListBuilder API

```rust
pub struct DisplayListBuilder {
    list: DisplayList,
}

impl DisplayListBuilder {
    pub fn new() -> Self;
    pub fn build(self, root: &FragmentNode) -> DisplayList;
    pub fn build_tree(self, tree: &FragmentTree) -> DisplayList;
    pub fn build_with_clips(self, root: &FragmentNode, clips: &HashSet<Option<usize>>) -> DisplayList;

    // Helper methods for explicit style emission
    pub fn emit_background(&mut self, rect: Rect, color: Rgba);
    pub fn emit_border(&mut self, rect: Rect, width: f32, color: Rgba);
    pub fn push_opacity(&mut self, opacity: f32);
    pub fn pop_opacity(&mut self);
    pub fn push_clip(&mut self, rect: Rect);
    pub fn pop_clip(&mut self);
}
```

## Algorithm Flow

### Pipeline

```
Fragment Tree → DisplayListBuilder → DisplayList → Rasterizer → Pixels
```

### Paint Order (CSS 2.1 Appendix E)

For each fragment, the builder processes in this order:
1. Background color (via emit_background if style available)
2. Border (via emit_border if style available)
3. Content (text → TextItem, images → ImageItem)
4. Children (recursive depth-first)

### Position Accumulation

Fragment positions are relative to their parent. The builder maintains a cumulative offset:

```rust
fn build_fragment(&mut self, fragment: &FragmentNode, offset: Point) {
    let absolute_rect = Rect::new(
        Point::new(
            fragment.bounds.origin.x + offset.x,
            fragment.bounds.origin.y + offset.y,
        ),
        fragment.bounds.size,
    );

    self.emit_content(fragment, absolute_rect);

    let child_offset = absolute_rect.origin;
    for child in &fragment.children {
        self.build_fragment(child, child_offset);
    }
}
```

### Clipping Support

For fragments with `overflow: hidden`, use `build_with_clips`:

```rust
let mut clips = HashSet::new();
clips.insert(Some(box_id_to_clip));
let list = builder.build_with_clips(&root, &clips);
```

This emits PushClip/PopClip around clipped content.

## Content Mapping

| FragmentContent | DisplayItem |
|-----------------|-------------|
| Text { text, baseline_offset } | DisplayItem::Text(TextItem { origin, glyphs, color, font_size, ... }) |
| Replaced { Image { src } } | DisplayItem::Image(ImageItem { dest_rect, image, ... }) |
| Block, Inline, Line | No direct content (children handle their own) |

### Text Handling

Currently creates simplified glyph instances (one per character with estimated advance). Full text shaping integration is planned for future work.

### Image Handling

Currently creates placeholder 1x1 gray pixel. Real image loading is handled elsewhere in the rendering pipeline.

## CSS Specification References

- CSS 2.1 Appendix E - Painting order
  https://www.w3.org/TR/CSS21/zindex.html

## Integration Points

### Dependencies

- **W5.T01 (Display List Types)**: DisplayItem, DisplayList, FillRectItem, TextItem, etc.
- **W2.T03 (Fragment Tree)**: FragmentNode, FragmentContent, FragmentTree

### Consumed By

- **W5.T07 (Rasterizer)**: Executes display list commands
- **W6.T02 (Rendering Pipeline)**: Full layout → paint → rasterize flow

## Test Coverage

17 tests in `paint::display_list_builder::tests`:

- `test_builder_empty_fragment` - Empty block produces no items
- `test_builder_text_fragment` - Text fragment produces TextItem
- `test_builder_text_position` - Text origin correctly positioned
- `test_builder_image_fragment` - Image fragment produces ImageItem
- `test_builder_nested_fragments` - Nested fragments all visited
- `test_builder_position_offset` - Child positions are absolute
- `test_builder_with_clips` - PushClip/PopClip emitted for clipped fragments
- `test_builder_no_clips` - No clips when not requested
- `test_emit_background` - Background emits FillRect
- `test_emit_background_transparent_skipped` - Transparent background skipped
- `test_emit_border` - Border emits StrokeRect
- `test_push_pop_opacity` - Opacity layers work
- `test_push_pop_clip` - Clip regions work
- `test_fragment_tree_wrapper` - Can build from FragmentTree
- `test_empty_text_skipped` - Empty text produces no items
- `test_deeply_nested` - Deep nesting position calculation correct
- `test_complex_tree` - Complex tree produces correct item types

## Design Decisions

### Single Builder Pattern

Unlike the original design with multiple builder variants (DisplayListBuilder, StyledDisplayListBuilder, ClippingDisplayListBuilder), we now have a single `DisplayListBuilder` with:
- Basic traversal via `build()` / `build_tree()`
- Clipping support via `build_with_clips()`
- Explicit style emission via helper methods (`emit_background`, `emit_border`, etc.)

This provides flexibility while keeping the API clean.

### Default Values

When style information is unavailable during traversal:
- Text color: BLACK
- Font size: 16.0px

The caller can use `emit_background()`, `emit_border()`, etc. when ComputedStyle is available.

## Files Created/Modified

- Created `src/paint/display_list_builder.rs` (~515 lines including tests)
- Modified `src/paint/mod.rs` - Added module export and re-exports
- Created `docs/tasks/notes/W5.T02-notes.md`
