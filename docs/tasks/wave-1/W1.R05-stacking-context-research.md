---
task_id: "W1.R05"
title: "CSS Stacking Context & Paint Order Research"
wave: 1
estimated_hours: 4-6
depends_on: []
inputs: []
outputs:
  - "outputs/notes/W1.R05-notes.md"
  - "docs/research/stacking-context-spec.md"
skills_required:
  - "Reading CSS specifications"
  - "Understanding 3D layering concepts"
  - "Algorithm analysis"
context_files:
  - "docs/plan/05-painting.md"
  - "docs/plan/00-foundation-research.md"
verification:
  - "Research notes document created"
  - "Appendix E paint order algorithm documented precisely"
  - "Stacking context creation conditions fully listed"
  - "Z-index behavior documented with examples"
---

# CSS Stacking Context & Paint Order Research

## Context

When browsers paint elements to the screen, they must determine the **correct layering order** - which elements appear in front of others. This is controlled by **stacking contexts** and **paint order rules**, specified precisely in CSS 2.1 Appendix E.

This research task requires deep study of:
- What creates a stacking context
- The 7-layer paint order algorithm within stacking contexts
- How z-index interacts with stacking contexts
- Negative z-index behavior
- Complex multi-level stacking scenarios

### Background

**What is a Stacking Context?**

A stacking context is a three-dimensional conceptualization of HTML elements along an imaginary z-axis relative to the user. Elements with higher stack levels appear in front of elements with lower stack levels.

**From CSS 2.1 Appendix E:**
> "Within each stacking context, the following layers are painted in back-to-front order:
> 1. the background and borders of the element forming the stacking context
> 2. the child stacking contexts with negative stack levels
> 3. the in-flow, non-inline-level descendants
> 4. the non-positioned floats
> 5. the in-flow, inline-level descendants
> 6. the positioned descendants with stack level 0 and positioned descendants with auto stack level
> 7. the child stacking contexts with positive stack levels"

This 7-layer ordering is **THE fundamental algorithm** for painting.

**Why Stacking Contexts Are Tricky:**

1. **Nested contexts are atomic**: Child stacking contexts paint as single units within parent context
2. **z-index only works within context**: `z-index: 9999` on child doesn't escape parent `z-index: 1`
3. **Many properties create contexts**: Not just `z-index`, but also `opacity`, `transform`, `filter`, etc.
4. **Negative z-index is special**: Paints behind parent's background

### Why This Matters

Without correct stacking context implementation:
- Elements paint in wrong order (visual bugs)
- z-index doesn't work as expected
- Opacity, transforms create wrong layering
- Overlays appear behind content
- Cannot pass WPT painting tests

**This is BLOCKING for:**
- W5.T03 (Stacking Context Tree) - Need to know what creates contexts
- W5.T04 (Paint Order Sorter) - Need the precise algorithm
- W5.T05 (Display List Builder) - Need to understand paint order

Getting this wrong means **all visual output is incorrect**.

## Prerequisites

### Required Knowledge

- **CSS box model**: Understanding of positioned elements (relative, absolute, fixed)
- **CSS properties**: z-index, opacity, transform, filter, position
- **Tree structures**: Understanding parent-child relationships
- **Sorting algorithms**: Understanding topological sort concepts

### Required Reading

1. **CSS 2.1 Appendix E** (CRITICAL - THIS IS THE SPEC):
   - https://www.w3.org/TR/CSS21/zindex.html
   - This is the ENTIRE specification for stacking contexts
   - Read it 2-3 times, it's dense but precise

2. **CSS 2.1 Section 9.9** (Layered Presentation):
   - https://www.w3.org/TR/CSS21/visuren.html#layered-presentation
   - z-index property definition
   - Positioned element stacking

3. **MDN Stacking Context Guide** (supplementary):
   - https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_positioned_layout/Understanding_z-index/Stacking_context
   - Good examples and visualizations

4. **CSS Transforms Module** (for context creation):
   - https://www.w3.org/TR/css-transforms-1/
   - Section on stacking context creation

5. **docs/plan/05-painting.md**: Our painting implementation strategy

## Inputs

### From Dependencies

**None** - This is a Wave 1 research task with no dependencies.

### Existing Resources

- CSS 2.1 Appendix E: https://www.w3.org/TR/CSS21/zindex.html
- CSS Transforms: https://www.w3.org/TR/css-transforms-1/
- Browser implementations (for reference):
  - Servo: `components/layout_2020/display_list.rs`
  - WebKit: `Source/WebCore/rendering/RenderLayer.cpp`

## Objectives

### Primary Goals

1. **Document what creates a stacking context**: Complete, exhaustive list
2. **Document the 7-layer paint order algorithm**: Precise, actionable pseudocode
3. **Understand z-index behavior**: How it works within contexts
4. **Document negative z-index handling**: Special case behavior
5. **Provide complex examples**: Multi-level nested contexts
6. **Extract edge cases**: Ambiguities and browser differences

### Success Criteria

- [ ] Complete list of stacking context creation conditions (15+ conditions)
- [ ] 7-layer paint order algorithm in precise pseudocode
- [ ] At least 10 concrete examples with diagrams
- [ ] At least 15 spec quotes from Appendix E
- [ ] Negative z-index behavior fully explained
- [ ] Complex nested context examples (3+ levels deep)
- [ ] Edge cases identified and documented
- [ ] Research document is 2500-3000 words
- [ ] Notes file created for W5.T03 and W5.T04

## Research Guide

### Phase 1: What Creates a Stacking Context (Estimated: 1-2 hours)

**Read:**
- CSS 2.1 Appendix E, first section (establishing stacking contexts)
- CSS 2.1 Section 9.9.1
- MDN stacking context page

**Extract COMPLETE list:**

Go through specs and find EVERY condition that creates a stacking context.

**Document in `docs/research/stacking-context-spec.md`:**

```markdown
# CSS Stacking Context Specification Research

## What Creates a Stacking Context

A stacking context is created by any element that satisfies **ANY** of the following conditions:

### From CSS 2.1

1. **Root element** (`<html>`)
   - Always creates a stacking context
   - Base of the stacking tree

2. **Positioned elements with z-index other than auto**
   - `position: absolute` or `position: relative` or `position: fixed` or `position: sticky`
   - AND `z-index` is an integer (not `auto`)
   - **Spec quote:** "Positioned elements with a z-index value other than auto create a stacking context" — CSS 2.1, Section 9.9.1

### From CSS Transforms Module

3. **Elements with transform property**
   - Any `transform` value other than `none`
   - Even `transform: translateZ(0)` creates context
   - **Spec quote:** "An element with a transform property other than none creates a stacking context" — CSS Transforms Level 1

### From CSS Compositing and Blending

4. **Elements with opacity less than 1**
   - `opacity` value < 1.0
   - Even `opacity: 0.99` creates context
   - **Spec quote:** "An element with opacity less than 1 creates a stacking context" — CSS Color Level 4

5. **Elements with mix-blend-mode other than normal**
   - `mix-blend-mode: multiply`, `overlay`, etc.

6. **Elements with isolation: isolate**
   - Explicitly creates isolated stacking context

### From CSS Filters

7. **Elements with filter property**
   - Any `filter` value other than `none`
   - `filter: blur(5px)`, `drop-shadow()`, etc.

### From CSS Masking

8. **Elements with mask or mask-image**
   - `mask` or `mask-image` property
   - `mask-border` also creates context

9. **Elements with clip-path**
   - Any `clip-path` value other than `none`

### From CSS Contain Module

10. **Elements with contain: layout or contain: paint**
    - `contain: layout`, `contain: paint`, or `contain: strict`

### From CSS Will-Change

11. **Elements with will-change**
    - `will-change` set to property that would create stacking context
    - `will-change: opacity`, `will-change: transform`, etc.

### From CSS Flexbox

12. **Flex items with z-index other than auto**
    - Children of `display: flex` or `display: inline-flex`
    - With `z-index` value (even without positioning!)
    - **This is different from normal flow!**

### From CSS Grid

13. **Grid items with z-index other than auto**
    - Children of `display: grid` or `display: inline-grid`
    - With `z-index` value (even without positioning!)

### From CSS Perspective

14. **Elements with perspective other than none**
    - `perspective` property

### From CSS Backdrop Filter

15. **Elements with backdrop-filter**
    - Any `backdrop-filter` value other than `none`

### Summary Table

| Condition | Example | Spec |
|-----------|---------|------|
| Root element | `<html>` | CSS 2.1 |
| Positioned + z-index | `position: absolute; z-index: 1` | CSS 2.1 |
| Transform | `transform: translateZ(0)` | Transforms |
| Opacity < 1 | `opacity: 0.9` | Color |
| Filter | `filter: blur(5px)` | Filters |
| Flex/grid item + z-index | flex item with `z-index: 1` | Flexbox/Grid |
| ... | ... | ... |

(Complete table with all 15+ conditions)

## Critical Insights

### Insight 1: Many Modern Properties Create Contexts

In CSS 2.1, only positioned + z-index created contexts. Now, 15+ different properties do!

**Implication:** Must check many properties when building stacking context tree.

### Insight 2: Flex/Grid Items Are Special

Flex and grid items with `z-index` create contexts **without positioning**!

```css
.flex-container { display: flex; }
.flex-item {
  z-index: 1;  /* Creates stacking context WITHOUT position! */
}
```

This is a departure from CSS 2.1 behavior.

### Insight 3: Will-Change Can Create Contexts

`will-change` is a hint that **may** create context:

```css
.element {
  will-change: transform;  /* Creates context before transform is applied! */
}
```

**Recommendation:** Treat `will-change` as creating context for simplicity.
```

### Phase 2: The 7-Layer Paint Order Algorithm (Estimated: 2-3 hours)

**Read:**
- CSS 2.1 Appendix E, section on painting order
- Read it multiple times - this is THE algorithm

**Extract:**

The precise 7-layer ordering within each stacking context.

**Document:**

```markdown
## The Paint Order Algorithm

### Appendix E: Seven Layers

Within each stacking context, elements are painted in **back-to-front** order in these layers:

#### Layer 1: Background and Borders of Stacking Context Root

**What:** The background and borders of the element that established the stacking context.

**Spec quote:**
> "the background and borders of the element forming the stacking context"
> — CSS 2.1, Appendix E

**Example:**
```html
<div style="position: relative; z-index: 0; background: red; border: 2px solid black">
  ...children...
</div>
```
The red background and black border paint first, before any children.

**Why this matters:** Background always behind children, even negative z-index children... wait, no! See Layer 2.

#### Layer 2: Child Stacking Contexts with Negative Stack Levels

**What:** Descendant stacking contexts with negative z-index values, in order from most negative to least negative.

**Spec quote:**
> "the child stacking contexts with negative stack levels (most negative first)"
> — CSS 2.1, Appendix E

**Example:**
```html
<div style="position: relative; z-index: 0">
  <div style="position: absolute; z-index: -2">I paint first!</div>
  <div style="position: absolute; z-index: -1">I paint second!</div>
</div>
```

**Critical insight:** Negative z-index children paint **AFTER parent background** but **BEFORE** normal flow content.

This is how you can position something "behind" siblings but "in front of" parent background.

**Sort order:** Most negative first (-999 before -1).

#### Layer 3: In-Flow, Non-Inline-Level Descendants

**What:** Block-level children in normal flow, in tree order.

**Spec quote:**
> "the in-flow, non-inline-level descendants"
> — CSS 2.1, Appendix E

**What qualifies:**
- Block boxes (divs, p, h1, etc. with no position)
- Table boxes
- Non-positioned elements

**Order:** Tree order (DOM order).

**Example:**
```html
<div style="position: relative; z-index: 0">
  <div>Block 1</div>  <!-- Paints in this order -->
  <div>Block 2</div>
  <div>Block 3</div>
</div>
```

#### Layer 4: Non-Positioned Floats

**What:** Floated elements that are not positioned.

**Spec quote:**
> "the non-positioned floats"
> — CSS 2.1, Appendix E

**Example:**
```html
<div style="position: relative; z-index: 0">
  <div style="float: left">Float 1</div>
  <div style="float: right">Float 2</div>
</div>
```

**Why separate layer:** Floats paint above normal blocks but below inline content.

**Order:** Tree order.

#### Layer 5: In-Flow, Inline-Level Descendants

**What:** Inline boxes, text, inline-blocks in normal flow.

**Spec quote:**
> "the in-flow, inline-level descendants, including inline tables and inline blocks"
> — CSS 2.1, Appendix E

**What qualifies:**
- Text nodes
- Inline elements (`<span>`, `<a>`, etc.)
- `display: inline-block`
- `display: inline-table`

**Order:** Tree order.

**Example:**
```html
<div style="position: relative; z-index: 0">
  <p>This text paints <span>in layer 5</span></p>
  <span style="display: inline-block">Inline-block too!</span>
</div>
```

**Why this layer:** Inline content (text) should appear above floats (text wraps around floats).

#### Layer 6: Positioned Descendants with Stack Level 0 or Auto

**What:** Positioned elements with `z-index: auto` or `z-index: 0`.

**Spec quote:**
> "the child stacking contexts with stack level 0 and the positioned descendants with stack level 0"
> — CSS 2.1, Appendix E

**Critical distinction:**
- `z-index: auto` on positioned element: Does NOT create stacking context
- `z-index: 0` on positioned element: DOES create stacking context

Both paint in this layer, but `z-index: 0` creates context for its children.

**Order:** Tree order.

**Example:**
```html
<div style="position: relative; z-index: 0">
  <div style="position: absolute; z-index: auto">Auto (no context)</div>
  <div style="position: absolute; z-index: 0">Zero (creates context)</div>
</div>
```

#### Layer 7: Child Stacking Contexts with Positive Stack Levels

**What:** Descendant stacking contexts with positive z-index values, in order from least positive to most positive.

**Spec quote:**
> "the child stacking contexts with positive stack levels (least positive first)"
> — CSS 2.1, Appendix E

**Example:**
```html
<div style="position: relative; z-index: 0">
  <div style="position: absolute; z-index: 1">I paint first!</div>
  <div style="position: absolute; z-index: 2">I paint second!</div>
  <div style="position: absolute; z-index: 999">I paint last!</div>
</div>
```

**Sort order:** Least positive first (1 before 999).

### Complete Algorithm in Pseudocode

```rust
fn paint_stacking_context(context: &StackingContext) {
    // Layer 1: Background and borders of root
    paint_background_and_border(context.root);

    // Layer 2: Negative z-index children (most negative first)
    let mut negative_z = context.children
        .filter(|c| c.z_index < 0)
        .collect();
    negative_z.sort_by_key(|c| c.z_index);  // -999, -2, -1
    for child in negative_z {
        paint_stacking_context(child);  // Recursive!
    }

    // Layer 3: In-flow non-inline descendants
    for element in context.in_flow_block_descendants() {
        paint_element(element);
        // If element has children, paint them recursively
        // But this is NOT a stacking context, so use normal tree order
    }

    // Layer 4: Non-positioned floats
    for float in context.floats() {
        paint_element(float);
    }

    // Layer 5: In-flow inline descendants
    for inline in context.in_flow_inline_descendants() {
        paint_element(inline);
    }

    // Layer 6: Positioned descendants with z-index 0 or auto (tree order)
    for element in context.positioned_zero_or_auto() {
        if element.z_index == 0 {
            // Creates stacking context
            paint_stacking_context(element.stacking_context);
        } else {
            // z-index: auto, no stacking context
            paint_element(element);
        }
    }

    // Layer 7: Positive z-index children (least positive first)
    let mut positive_z = context.children
        .filter(|c| c.z_index > 0)
        .collect();
    positive_z.sort_by_key(|c| c.z_index);  // 1, 2, 999
    for child in positive_z {
        paint_stacking_context(child);  // Recursive!
    }
}
```

### Key Algorithm Insights

1. **Layers 2 and 7 are sorted by z-index**: Negative z-index most-negative-first, positive z-index least-positive-first

2. **Layers 3-6 are in tree order**: DOM order, not z-index

3. **Stacking contexts are atomic**: Child context paints as single unit in parent's layer

4. **Recursion happens at layers 2, 6, 7**: When painting child stacking contexts

## Visual Example: The 7 Layers

```html
<div id="root" style="position: relative; z-index: 0; background: lightblue; border: 2px solid navy">
  <div id="neg2" style="position: absolute; z-index: -2; background: pink">z=-2</div>
  <div id="neg1" style="position: absolute; z-index: -1; background: lightpink">z=-1</div>
  <div id="block1" style="background: lightgreen">Block 1</div>
  <div id="float1" style="float: left; background: lightyellow">Float</div>
  <div id="block2" style="background: lightgreen">Block 2 <span>with inline text</span></div>
  <div id="pos-auto" style="position: absolute; z-index: auto; background: orange">z=auto</div>
  <div id="pos-zero" style="position: absolute; z-index: 0; background: darkorange">z=0</div>
  <div id="pos1" style="position: absolute; z-index: 1; background: lavender">z=1</div>
  <div id="pos2" style="position: absolute; z-index: 2; background: lightcoral">z=2</div>
</div>
```

**Paint order (back to front):**

1. `#root` background (lightblue) and border (navy) — **Layer 1**
2. `#neg2` (pink, z=-2) — **Layer 2**
3. `#neg1` (lightpink, z=-1) — **Layer 2**
4. `#block1` (lightgreen) — **Layer 3**
5. `#float1` (lightyellow) — **Layer 4**
6. `#block2` (lightgreen) and its inline text — **Layer 5**
7. `#pos-auto` (orange) — **Layer 6**
8. `#pos-zero` (darkorange) — **Layer 6**
9. `#pos1` (lavender, z=1) — **Layer 7**
10. `#pos2` (lightcoral, z=2) — **Layer 7**

**Final stacking:** Coral (z=2) is on top, pink (z=-2) is behind everything except root background.
```

### Phase 3: Z-Index Behavior and Edge Cases (Estimated: 1-2 hours)

**Study:**
- How z-index works within stacking contexts
- What happens with equal z-index values
- Z-index on non-positioned elements
- Negative z-index edge cases

**Document:**

```markdown
## Z-Index Behavior

### Z-Index Only Works Within Stacking Context

**Critical rule:** z-index only affects ordering **within the same stacking context**.

**Example of confinement:**

```html
<div id="parent1" style="position: relative; z-index: 1">
  <div id="child1" style="position: absolute; z-index: 9999">Very high z!</div>
</div>
<div id="parent2" style="position: relative; z-index: 2">
  <div id="child2" style="position: absolute; z-index: 1">Low z</div>
</div>
```

**Paint order:**
1. `parent1` (z=1) and all its children (including `child1` with z=9999)
2. `parent2` (z=2) and all its children (including `child2` with z=1)

**Result:** `child2` (z=1) paints **in front of** `child1` (z=9999) because parent2 > parent1!

**Insight:** You cannot "escape" parent stacking context with high z-index.

### Z-Index Values

**Valid values:**
- Integer: ..., -2, -1, 0, 1, 2, ...
- `auto` (default)

**Invalid values:**
- Decimals: `z-index: 1.5` is invalid
- Very large integers are valid: `z-index: 2147483647` works

### Z-Index on Non-Positioned Elements

**Rule:** z-index has no effect on non-positioned elements (except flex/grid items).

```css
.block {
  z-index: 999;  /* IGNORED - not positioned! */
}

.block-positioned {
  position: relative;
  z-index: 999;  /* WORKS */
}
```

**Exception:** Flex and grid items can use z-index without positioning.

### Equal Z-Index Values

**When multiple elements have same z-index, paint in tree order (later elements on top):**

```html
<div style="position: relative; z-index: 0">
  <div style="position: absolute; z-index: 1">First</div>
  <div style="position: absolute; z-index: 1">Second (on top!)</div>
  <div style="position: absolute; z-index: 1">Third (most on top!)</div>
</div>
```

**Paint order:** First, Second, Third (tree order).

### Negative Z-Index Special Behavior

**Negative z-index paints behind parent's background:**

Actually NO! Re-reading spec...

**Correction:** Negative z-index child stacking contexts paint **after** parent background (Layer 2) but **before** normal flow content (Layer 3).

```html
<div style="position: relative; z-index: 0; background: red">
  <div style="position: absolute; z-index: -1; background: blue">Behind content, in front of bg</div>
  <div>Normal content</div>
</div>
```

**Visual stacking:**
1. Red background (Layer 1)
2. Blue div with z=-1 (Layer 2) — **on top of red background**
3. Normal content (Layer 3)

**Use case:** Creating "underlay" effects without `::before` pseudo-elements.

### Edge Case: Auto vs 0

**Crucial difference:**

- `z-index: auto`: Does NOT create stacking context (children can "escape")
- `z-index: 0`: DOES create stacking context (children confined)

```html
<div style="position: relative; z-index: auto">
  <div style="position: absolute; z-index: -1">Can go behind parent!</div>
</div>

<div style="position: relative; z-index: 0">
  <div style="position: absolute; z-index: -1">Cannot escape context</div>
</div>
```

**Test case for W5.T03:** Verify auto vs 0 behavior.
```

### Phase 4: Complex Nested Examples (Estimated: 1 hour)

**Create:**
- 3-level nested stacking contexts
- Mixed negative and positive z-index
- Examples that demonstrate common mistakes

**Document:**

```markdown
## Complex Nested Examples

### Example 1: Three-Level Nesting

```html
<div id="A" style="position: relative; z-index: 1; background: red">
  A (z=1)
  <div id="B" style="position: absolute; z-index: 10; background: green">
    B (z=10 within A)
    <div id="C" style="position: absolute; z-index: 100; background: blue">
      C (z=100 within B)
    </div>
  </div>
</div>
<div id="D" style="position: relative; z-index: 2; background: yellow">
  D (z=2)
</div>
```

**Stacking context hierarchy:**
```
Root
├─ A (z=1)
│  └─ B (z=10)
│     └─ C (z=100)
└─ D (z=2)
```

**Paint order:**
1. A background (red) — A's Layer 1
2. B (green) with all children — A's Layer 7 (B has z=10)
   - B background — B's Layer 1
   - C (blue) — B's Layer 7 (C has z=100)
3. D (yellow) — Root's Layer 7 (D has z=2)

**Final result:** Yellow (D) on top, even though C has z=100!

**Why:** D is in root's stacking context with z=2, A is in root's stacking context with z=1. Everything in A (including deeply nested C) paints before D.

### Example 2: The Negative Z-Index Trap

```html
<div id="A" style="position: relative; z-index: 0; background: white">
  <div id="B" style="position: relative; z-index: -1; background: red">
    Negative z-index
  </div>
  <div id="C" style="background: blue">
    Normal flow content
  </div>
</div>
```

**Expected by beginner:** Red div behind blue div? Yes!
**Also happens:** Red div **on top of** white background!

**Paint order:**
1. A background (white) — Layer 1
2. B (red, z=-1) — Layer 2
3. C (blue) — Layer 3

Red is sandwiched between white background and blue content.

### Example 3: Opacity Creates Stacking Context

```html
<div id="A" style="opacity: 0.99">  <!-- Creates stacking context! -->
  <div id="B" style="position: absolute; z-index: 9999">
    High z-index but trapped!
  </div>
</div>
<div id="C" style="position: relative; z-index: 1">
  Low z-index but in root context
</div>
```

**Stacking context hierarchy:**
```
Root
├─ A (opacity creates context, effective z=0)
│  └─ B (z=9999 within A)
└─ C (z=1 in root)
```

**Paint order:**
1. A (opacity 0.99) with all children — Root's Layer 6 (no z-index on A)
   - B (z=9999) within A
2. C (z=1) — Root's Layer 7

**Result:** C paints on top of B, even though B has z=9999!

**Why:** A creates stacking context due to opacity, so B's z=9999 is confined to A's context.

### Example 4: Transform Creates Context

```html
<div id="modal" style="position: fixed; z-index: 1000; background: rgba(0,0,0,0.5)">
  Modal backdrop
</div>
<div id="content" style="transform: translateZ(0)">  <!-- Creates context! -->
  <div id="popup" style="position: absolute; z-index: 9999">
    Popup that should be above modal... but isn't!
  </div>
</div>
```

**Problem:** `transform: translateZ(0)` creates stacking context on `#content`, trapping `#popup`.

**Paint order:**
1. `#content` (transform creates context, tree order before modal)
   - `#popup` (z=9999 within content)
2. `#modal` (z=1000 in root context)

**Result:** Modal covers popup!

**Lesson:** Be careful with `transform`, `opacity`, `filter` - they create stacking contexts unexpectedly.

### Example 5: Flex Items and Z-Index

```html
<div style="display: flex">
  <div style="z-index: 2; background: red">  <!-- No position needed! -->
    Flex item with z-index
  </div>
  <div style="z-index: 1; background: blue">
    Another flex item
  </div>
</div>
```

**Special rule:** Flex items with z-index create stacking contexts **without position**.

**Paint order:**
1. Blue (z=1)
2. Red (z=2)

Red on top, even though neither has `position` property!
```

## Output Artifacts

### Research Document

Create: **`docs/research/stacking-context-spec.md`**

Comprehensive document (2500-3000 words) covering:

1. **What Creates Stacking Contexts** (600 words)
   - Complete list of 15+ conditions
   - Spec quotes for each
   - Summary table
   - Historical evolution (CSS 2.1 → modern)

2. **The 7-Layer Paint Order Algorithm** (1000 words)
   - Detailed explanation of each layer
   - Pseudocode algorithm
   - Visual examples
   - Spec quotes from Appendix E

3. **Z-Index Behavior** (400 words)
   - How z-index works within contexts
   - Auto vs 0 distinction
   - Equal z-index handling
   - Negative z-index behavior

4. **Complex Examples** (500 words)
   - 5+ multi-level nested examples
   - Common mistakes demonstrated
   - Edge cases visualized

5. **Implementation Guidance** (300 words)
   - Algorithm for building stacking context tree
   - Sort order for paint list
   - Testing strategy

### Notes File

Create: **`outputs/notes/W1.R05-notes.md`**

```markdown
# Task W1.R05 Output Notes

## Research Summary

Studied CSS 2.1 Appendix E (stacking context specification) and related specs to understand paint order algorithm. Documented the precise 7-layer ordering within stacking contexts and complete list of conditions that create stacking contexts.

**Key findings:**
1. **15+ properties create stacking contexts** - not just z-index!
2. **7-layer algorithm is absolute** - must be followed exactly for correct painting
3. **Negative z-index is special** - paints after parent background but before normal flow
4. **Stacking contexts are atomic** - children cannot escape parent context

## Complete Stacking Context Creation Conditions

An element creates a stacking context if it has ANY of:

1. ✅ Root element (`<html>`)
2. ✅ `position: absolute|relative|fixed|sticky` + `z-index: <integer>`
3. ✅ `transform: <any-value-except-none>`
4. ✅ `opacity: <less-than-1>`
5. ✅ `filter: <any-value-except-none>`
6. ✅ `clip-path: <any-value-except-none>`
7. ✅ `mask / mask-image / mask-border`
8. ✅ `mix-blend-mode: <any-value-except-normal>`
9. ✅ `isolation: isolate`
10. ✅ `perspective: <any-value-except-none>`
11. ✅ `contain: layout|paint|strict`
12. ✅ `backdrop-filter: <any-value-except-none>`
13. ✅ `will-change: <property-that-creates-context>`
14. ✅ Flex item with `z-index: <integer>` (no position needed!)
15. ✅ Grid item with `z-index: <integer>` (no position needed!)

### Critical Insights

**Insight 1:** In CSS 2.1, only #1 and #2 created contexts. Modern CSS added 13 more!

**Insight 2:** Flex/grid items are special - they can use z-index without positioning.

**Insight 3:** `opacity`, `transform`, `filter` create contexts as side effect, which can cause unexpected layering.

## The 7-Layer Paint Order Algorithm

Within each stacking context, paint in this order (back-to-front):

```
Layer 1: Background & borders of stacking context root
Layer 2: Child stacking contexts with negative z-index (most negative first)
Layer 3: In-flow, non-inline-level descendants (tree order)
Layer 4: Non-positioned floats (tree order)
Layer 5: In-flow, inline-level descendants (tree order)
Layer 6: Positioned descendants with z-index 0 or auto (tree order)
Layer 7: Child stacking contexts with positive z-index (least positive first)
```

### Pseudocode for W5.T04

```rust
fn paint_stacking_context(sc: &StackingContext, display_list: &mut DisplayList) {
    // Layer 1
    display_list.add(paint_background_and_border(sc.root));

    // Layer 2: Negative z-index children
    let mut negative: Vec<_> = sc.children.iter()
        .filter(|c| c.z_index.is_some() && c.z_index.unwrap() < 0)
        .collect();
    negative.sort_by_key(|c| c.z_index.unwrap());  // Most negative first
    for child in negative {
        paint_stacking_context(child, display_list);
    }

    // Layer 3: Block-level in-flow
    for element in sc.descendants_in_layer(Layer::BlockLevel) {
        display_list.add(paint_element(element));
    }

    // Layer 4: Floats
    for element in sc.descendants_in_layer(Layer::Floats) {
        display_list.add(paint_element(element));
    }

    // Layer 5: Inline-level in-flow
    for element in sc.descendants_in_layer(Layer::InlineLevel) {
        display_list.add(paint_element(element));
    }

    // Layer 6: Positioned with z=0 or auto
    for element in sc.descendants_in_layer(Layer::PositionedZeroOrAuto) {
        if element.creates_stacking_context() {
            paint_stacking_context(element.stacking_context, display_list);
        } else {
            display_list.add(paint_element(element));
        }
    }

    // Layer 7: Positive z-index children
    let mut positive: Vec<_> = sc.children.iter()
        .filter(|c| c.z_index.is_some() && c.z_index.unwrap() > 0)
        .collect();
    positive.sort_by_key(|c| c.z_index.unwrap());  // Least positive first
    for child in positive {
        paint_stacking_context(child, display_list);
    }
}
```

## Z-Index Behavior Insights

### Auto vs 0: The Critical Difference

```rust
// z-index: auto
position: relative;
z-index: auto;
// Does NOT create stacking context
// Children can interact with ancestors

// z-index: 0
position: relative;
z-index: 0;
// DOES create stacking context
// Children are confined
```

Both paint in Layer 6, but have different containment behavior!

### Z-Index Confinement

**Rule:** z-index only affects order within same stacking context.

**Example:**
```html
<div style="position: relative; z-index: 1">
  <div style="position: absolute; z-index: 999999">Trapped!</div>
</div>
<div style="position: relative; z-index: 2">
  <div style="position: absolute; z-index: 1">On top!</div>
</div>
```

Second child (z=1) paints on top of first child (z=999999) because parent z=2 > z=1.

### Negative Z-Index Use Case

Negative z-index paints **after parent background** but **before normal flow content**.

Use case: Creating underlay effects.

```html
<div style="position: relative; z-index: 0; background: white">
  <div style="position: absolute; z-index: -1; background: rgba(0,0,0,0.1)">
    Underlay effect - behind content, over background
  </div>
  <div>Content</div>
</div>
```

## Critical Implementation Notes

### For W5.T03 (Stacking Context Tree):

**Must check all 15+ conditions when building tree!**

```rust
fn creates_stacking_context(element: &Element) -> bool {
    // Check ALL conditions
    element.is_root_element()
    || (element.is_positioned() && element.z_index().is_some())
    || element.transform().is_some()
    || element.opacity() < 1.0
    || element.filter().is_some()
    || element.clip_path().is_some()
    || element.mask().is_some()
    || element.mix_blend_mode() != BlendMode::Normal
    || element.isolation() == Isolation::Isolate
    || element.perspective().is_some()
    || element.contain().intersects(Contain::LAYOUT | Contain::PAINT)
    || element.backdrop_filter().is_some()
    || creates_context_via_will_change(element)
    || is_flex_or_grid_item_with_z_index(element)
}
```

**Don't forget any conditions!** Missing even one causes incorrect layering.

### For W5.T04 (Paint Order Sorter):

**Implement 7-layer algorithm exactly as spec:**

1. Create data structure to hold elements by layer
2. Sort negative z-index (most negative first)
3. Sort positive z-index (least positive first)
4. Layers 3-6 in tree order (no sorting)
5. Recursively paint child stacking contexts

**Edge case:** Elements with same z-index paint in tree order (later on top).

### For W5.T05 (Display List Builder):

**Traverse stacking context tree and build flattened paint commands:**

```rust
fn build_display_list(root: &StackingContext) -> DisplayList {
    let mut dl = DisplayList::new();
    paint_stacking_context(root, &mut dl);
    dl
}
```

Display list is linear (flattened) but constructed by traversing stacking context tree.

## Spec Interpretations

### Ambiguity 1: Will-Change Behavior

**Spec says:** "will-change set to a property that would create a stacking context"

**Interpretation:** Treat `will-change: transform`, `will-change: opacity`, etc. as creating context.

**Reasoning:** Browser behavior shows context is created eagerly for performance.

### Ambiguity 2: Decimal Z-Index

**Question:** What about `z-index: 1.5`?

**Spec says:** z-index is `<integer>`

**Interpretation:** Invalid, should be treated as `auto`.

**Test:** Verify browser behavior.

## Recommendations for W5 Tasks

### For W5.T03 (Stacking Context Tree):

1. **Implement comprehensive check** - All 15+ conditions
2. **Store z-index value** - Needed for paint order sorting
3. **Tree structure** - Each context knows children and parent
4. **Traverse fragment tree** - Build stacking context tree from fragments

**Data structure:**
```rust
struct StackingContext {
    root_fragment: FragmentRef,
    z_index: Option<i32>,
    children: Vec<StackingContext>,  // Child stacking contexts
    descendants: Vec<FragmentRef>,    // Non-context descendants by layer
}
```

### For W5.T04 (Paint Order Sorter):

1. **Implement 7-layer algorithm** - Exactly as Appendix E
2. **Stable sort** - Preserve tree order for equal z-index
3. **Recursive traversal** - Paint child contexts at correct layer
4. **Optimize later** - Correctness first, performance in Wave 6

**Algorithm structure:**
```rust
fn sort_for_painting(sc: &StackingContext) -> Vec<PaintCommand> {
    let mut commands = vec![];

    // Layer 1
    commands.push(paint_bg_and_border(sc.root));

    // Layer 2
    for child in sc.children.iter().filter(|c| c.z_index < 0).sorted() {
        commands.extend(sort_for_painting(child));
    }

    // Layers 3-6
    commands.extend(paint_descendants_by_layer(sc));

    // Layer 7
    for child in sc.children.iter().filter(|c| c.z_index > 0).sorted() {
        commands.extend(sort_for_painting(child));
    }

    commands
}
```

### For W5.T05 (Display List Builder):

1. **Flatten stacking context tree** - To linear display list
2. **Include metadata** - Clip rects, opacity, transforms
3. **Optimize identical commands** - Merge adjacent same-type commands
4. **Test against complex examples** - Use examples from this research

## Discoveries & Gotchas

### Discovery 1: Many Properties Create Contexts

In CSS 2.1, only 2 conditions created stacking contexts. Modern CSS has 15+!

**Implication:** Must check many properties, not just z-index.

**Test case:** Element with `opacity: 0.99` should create context.

### Discovery 2: Flex/Grid Special Behavior

Flex and grid items can use z-index **without positioning**.

```css
.flex-item {
  /* NO position property! */
  z-index: 1;  /* Still works because parent is flex container */
}
```

**Implication:** Context creation check must handle flex/grid specially.

### Discovery 3: Transform Causes Unexpected Layering

Common bug: Using `transform: translateZ(0)` for GPU acceleration creates stacking context!

```css
.content {
  transform: translateZ(0);  /* GPU hack creates stacking context! */
}
```

Children with high z-index get trapped.

**Recommendation:** Document this gotcha for users.

### Gotcha 1: Negative Z-Index Doesn't Go "Behind Everything"

Common misconception: `z-index: -1` goes behind parent background.

**Reality:** It goes behind normal flow content, but **in front of** parent background.

**Test case:** Verify negative z-index paints after parent background.

### Gotcha 2: High Z-Index Doesn't Guarantee Top

`z-index: 9999` doesn't guarantee element is on top if trapped in stacking context.

**Test case:** Nested contexts with high z-index child under low z-index parent.

## Test Cases to Implement

1. **Basic 7-layer ordering**: All layers present, verify order
2. **Negative z-index**: Verify paints after parent bg, before normal flow
3. **Nested contexts**: 3+ levels deep, verify confinement
4. **Equal z-index**: Verify tree order for ties
5. **Opacity creates context**: Verify opacity < 1 creates context
6. **Transform creates context**: Verify transform creates context
7. **Flex item z-index**: Verify flex items can use z-index without position
8. **Auto vs 0**: Verify different behavior of auto vs 0
9. **All 15+ conditions**: Test each stacking context creation condition
10. **Complex real-world**: Modal over transformed content, etc.

## References Studied

1. CSS 2.1 Appendix E - Stacking Context Specification
   - https://www.w3.org/TR/CSS21/zindex.html
   - The definitive specification

2. CSS 2.1 Section 9.9 - Layered Presentation
   - https://www.w3.org/TR/CSS21/visuren.html#layers

3. CSS Transforms Level 1
   - https://www.w3.org/TR/css-transforms-1/
   - Stacking context creation

4. CSS Color Level 4
   - Opacity and stacking contexts

5. CSS Contain Module
   - Containment and stacking contexts

6. MDN Stacking Context Guide
   - https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_positioned_layout/Understanding_z-index/Stacking_context

---

**Research completed:** YYYY-MM-DD
**Time taken:** 4-6 hours
**Confidence level:** Very High - Appendix E studied thoroughly
**Recommendation:** Implement 7-layer algorithm exactly as specified, check all 15+ conditions
```

## Common Pitfalls to Avoid

### Pitfall 1: Skipping Appendix E

**Wrong:** Read summaries or MDN, skip the actual spec
**Right:** Read Appendix E 2-3 times, it's THE specification

Everything else is derivative. The spec is precise and complete.

### Pitfall 2: Forgetting Modern Context Creation Conditions

**Wrong:** Only check for positioned + z-index
**Right:** Check all 15+ conditions (opacity, transform, filter, etc.)

Missing even one causes incorrect layering.

### Pitfall 3: Implementing Wrong Sort Order

**Wrong:** Sort all z-index values together
**Right:** Negative values most-negative-first, positive values least-positive-first

Layers 2 and 7 have opposite sort directions!

### Pitfall 4: Confusing Auto and 0

**Wrong:** Treat `z-index: auto` and `z-index: 0` the same
**Right:** Auto doesn't create context, 0 does

They paint in same layer but have different containment.

### Pitfall 5: Not Testing Nested Contexts

**Wrong:** Test only flat z-index scenarios
**Right:** Test 3+ level nested contexts

Nested contexts are where confinement bugs appear.

## Verification Checklist

Before marking research complete:

- [ ] Read CSS 2.1 Appendix E completely (2-3 times)
- [ ] Complete list of 15+ stacking context conditions
- [ ] 7-layer algorithm documented with spec quotes
- [ ] Pseudocode for paint order algorithm
- [ ] At least 10 concrete examples
- [ ] At least 15 spec quotes from Appendix E
- [ ] Negative z-index behavior explained
- [ ] Auto vs 0 distinction documented
- [ ] 5+ complex nested examples (3+ levels)
- [ ] Edge cases identified and tested
- [ ] Research document is 2500-3000 words
- [ ] Notes file complete with all sections
- [ ] Ready for W5.T03 and W5.T04 implementation

## Time Tracking

Expected breakdown:
- **Stacking context creation conditions:** 1-2 hours
- **7-layer paint order algorithm:** 2-3 hours
- **Z-index behavior and edge cases:** 1-2 hours
- **Complex nested examples:** 1 hour
- **Documentation and synthesis:** 1 hour
- **Total:** 4-6 hours

## Getting Help

If confused by Appendix E:

1. **Read it slowly**: The spec is dense but precise
2. **Draw diagrams**: Visualize the 7 layers
3. **Test in browser**: Create HTML examples and inspect paint order
4. **Read MDN**: Good for intuition, but always verify with spec
5. **Look at browser code**: Servo's display list building shows implementation

Remember: Appendix E is short (a few pages) but critical. Read every word.
