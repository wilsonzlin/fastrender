---
task_id: "W1.R02"
title: "CSS Table Layout Specification Research"
wave: 1
estimated_hours: 6-8
depends_on: []
inputs: []
outputs:
  - "outputs/notes/W1.R02-notes.md"
  - "docs/research/table-layout-spec.md"
skills_required:
  - "Reading technical specifications"
  - "Algorithm analysis"
  - "Pseudocode writing"
context_files:
  - "docs/plan/02-table-layout.md"
  - "docs/plan/00-foundation-research.md"
verification:
  - "Research notes document created with all sections filled"
  - "Table layout algorithms documented in pseudocode"
  - "Critical spec sections quoted and explained"
---

# CSS Table Layout Specification Research

## Context

Table layout is the **most critical algorithm** to understand for FastRender V2. The current V1 codebase's fundamental flaw is attempting to fake table layout with flexbox, which cannot work correctly due to fundamentally different layout constraints.

This research task requires deep study of the CSS Tables specification to understand:
- How table structure is analyzed (rows, columns, cells)
- The two fundamentally different algorithms (fixed vs. auto)
- How column widths are computed from cell contents
- How row heights are computed from cell contents
- Border collapsing rules
- Anonymous box generation for incomplete table structures

### Background

**Why Tables Are Special:**

Tables are unique in CSS because they have **bidirectional constraints**:
- Cell content affects column width
- Column width affects cell content wrapping
- Cell content wrapping affects row height
- Row height affects vertical alignment of cell content

This creates a complex interdependency that cannot be modeled with simpler layout modes like flexbox or grid.

**From CSS Tables Module Level 3:**
> "Table layout differs from other layout modes in that it involves global analysis of the table structure before determining the final layout."

**Two Completely Different Algorithms:**

1. **Fixed Layout (`table-layout: fixed`)**: Fast, predictable, based on first row
2. **Auto Layout (`table-layout: auto`)**: Slow, complex, analyzes all cells

### Why This Matters

Without understanding table layout deeply:
- We cannot implement the W3.T06 table layout task correctly
- We will repeat V1's mistake of trying to fake it
- Real-world content (data tables, form layouts) will render incorrectly
- We cannot pass WPT table layout tests

**This is a BLOCKING task** for the entire table layout implementation.

## Prerequisites

### Required Knowledge

- **CSS box model basics**: Understanding of width, height, margin, padding, border
- **CSS display values**: Understanding display: table, table-row, table-cell hierarchy
- **Basic algorithms**: Understanding of multi-pass algorithms and constraint solving
- **Reading specs**: Ability to parse formal specification language

### Required Reading

1. **CSS Tables Module Level 3** (primary):
   - https://www.w3.org/TR/css-tables-3/
   - Focus on Sections 3-7 (structure, width, height, algorithms)

2. **CSS 2.1 Chapter 17** (Tables):
   - https://www.w3.org/TR/CSS21/tables.html
   - Historic but still referenced by browsers

3. **docs/plan/02-table-layout.md**:
   - Context on why V1's approach failed
   - Overview of what we need to implement

## Inputs

### From Dependencies

**None** - This is a Wave 1 research task with no dependencies.

### Existing Resources

Online specifications:
- CSS Tables Module Level 3: https://www.w3.org/TR/css-tables-3/
- CSS 2.1 Tables: https://www.w3.org/TR/CSS21/tables.html

Browser implementations (for reference):
- Servo: `components/layout_2020/table/`
- WebKit: `Source/WebCore/layout/tableformatting/`

## Objectives

### Primary Goals

1. **Understand table structure model**: How table/row/cell boxes relate
2. **Document fixed layout algorithm**: Complete pseudocode for table-layout: fixed
3. **Document auto layout algorithm**: Complete pseudocode for table-layout: auto
4. **Document anonymous box generation**: Rules for incomplete table structures
5. **Document border collapse**: Border conflict resolution rules
6. **Identify implementation challenges**: Edge cases, ambiguities, browser differences

### Success Criteria

- [ ] Research document covers all CSS table concepts
- [ ] Fixed layout algorithm in complete pseudocode
- [ ] Auto layout algorithm in complete pseudocode
- [ ] At least 20 spec quotes captured with section references
- [ ] Edge cases identified and documented
- [ ] Clear explanation of why flexbox cannot replace tables
- [ ] Anonymous box generation rules fully documented
- [ ] Notes file created for W3.T06 consumption

## Research Guide

### Phase 1: Table Structure (Estimated: 1-2 hours)

**Read:**
- CSS Tables Level 3, Section 3: "Table Structure"
- CSS 2.1, Section 17.2: "The CSS table model"

**Extract:**
- Hierarchy of table-related display values
- What creates what kind of box
- Parent-child constraints (what can contain what)
- Anonymous box generation rules

**Document:**
Create `docs/research/table-layout-spec.md` with section:

```markdown
## Table Structure Model

### Display Values Hierarchy

(Diagram showing table > table-row-group > table-row > table-cell)

### Anonymous Box Generation

(Rules for when anonymous boxes are created)

#### Example 1: Missing row
Input: table > table-cell
Generated: table > anonymous-row > table-cell

#### Example 2: Missing row group
...

### Spec Quotes

> "A table-row box participates in the row-group formatting context..."
> — CSS Tables Level 3, Section 3.1

(Continue with more quotes and explanations)
```

### Phase 2: Fixed Layout Algorithm (Estimated: 2-3 hours)

**Read:**
- CSS Tables Level 3, Section 6: "Fixed Table Layout"
- CSS 2.1, Section 17.5.2.1: "Fixed table layout"

**Extract:**
- Step-by-step algorithm for computing column widths
- How first row determines column widths
- Handling of colspan
- Overflow behavior

**Document:**

```markdown
## Fixed Layout Algorithm

### High-Level Flow

1. Compute table width (from style or containing block)
2. Analyze first row cells for column constraints
3. Distribute width to columns
4. Layout all cells with computed column widths

### Detailed Algorithm (Pseudocode)

```
function compute_fixed_layout(table, available_width):
    # Step 1: Determine column count
    column_count = analyze_first_row(table.first_row)

    # Step 2: Collect column widths from first row
    column_constraints = []
    for cell in table.first_row.cells:
        if cell.has_width():
            column_constraints[cell.column] = cell.width
        elif cell.has_min_width():
            column_constraints[cell.column] = cell.min_width
        else:
            column_constraints[cell.column] = auto

    # Step 3: Distribute remaining width to auto columns
    specified_width = sum(column_constraints.where(not auto))
    remaining = available_width - specified_width
    auto_columns = column_constraints.count(auto)

    for column in auto_columns:
        column_constraints[column] = remaining / auto_columns

    return column_constraints
```

### Edge Cases

1. **Colspan in first row**: How to handle?
   - Spec says: ...
   - Implementation: ...

2. **Table width < sum of column widths**: What happens?
   - Spec says: ...
   - Implementation: ...

(Continue documenting edge cases)
```

### Phase 3: Auto Layout Algorithm (Estimated: 2-3 hours)

**Read:**
- CSS Tables Level 3, Section 7: "Automatic Table Layout"
- CSS 2.1, Section 17.5.2.2: "Automatic table layout"

**THIS IS THE HARD PART** - Auto layout requires analyzing ALL cells.

**Extract:**
- Algorithm for computing minimum column width (min-content)
- Algorithm for computing maximum column width (max-content)
- Width distribution algorithm
- How percentages interact with auto widths
- Colspan handling

**Document:**

```markdown
## Auto Layout Algorithm

### Conceptual Model

Auto layout computes TWO widths for each column:
1. **min-content width**: Minimum width without overflow
2. **max-content width**: Width if no wrapping occurred

These widths constrain the final layout.

### Detailed Algorithm (Pseudocode)

```
function compute_auto_layout(table, available_width):
    # Step 1: Compute min and max widths for each column
    for column in table.columns:
        min_width[column] = compute_min_content_width(column)
        max_width[column] = compute_max_content_width(column)

    # Step 2: Distribute available width
    total_min = sum(min_width)
    total_max = sum(max_width)

    if available_width <= total_min:
        # Table is too small, use min widths
        return min_width
    elif available_width >= total_max:
        # Table has extra space, use max widths
        return max_width
    else:
        # Interpolate between min and max
        return distribute_proportionally(min_width, max_width, available_width)
```

### Computing Min-Content Width

For each cell in column:
- Measure content with no wrapping allowed
- Take maximum across all cells (considering rowspan)

```
function compute_min_content_width(column):
    max_width = 0
    for cell in column.cells:
        content_width = measure_without_wrapping(cell.content)
        if cell.colspan > 1:
            # Distribute across spanned columns
            content_width = content_width / cell.colspan
        max_width = max(max_width, content_width)
    return max_width
```

### Computing Max-Content Width

(Similar but allows wrapping at word boundaries)

### Edge Cases

1. **Percentage widths in auto layout**: How do they work?
2. **Colspan distribution**: How to split width across columns?
3. **Table wider than available space**: What happens?

(Document each edge case with spec quotes)
```

### Phase 4: Border Collapse (Estimated: 1-2 hours)

**Read:**
- CSS 2.1, Section 17.6.2: "The collapsing border model"

**Extract:**
- Border conflict resolution rules
- Precedence order (width, style, source)
- How to compute collapsed borders

**Document:**

```markdown
## Border Collapsing

When `border-collapse: collapse`:
- Adjacent cell borders merge into single border
- Conflicts resolved by precedence rules

### Conflict Resolution Algorithm

```
function resolve_border_conflict(border1, border2):
    # Rule 1: hidden wins
    if border1.style == 'hidden' or border2.style == 'hidden':
        return Border::hidden()

    # Rule 2: wider wins
    if border1.width > border2.width:
        return border1
    elif border2.width > border1.width:
        return border2

    # Rule 3: style precedence
    style_precedence = [double, solid, dashed, dotted, ridge, outset, groove, inset, none]
    if precedence(border1.style) > precedence(border2.style):
        return border1

    # Rule 4: source precedence
    # cell > row > row-group > column > column-group > table
    ...
```

(Continue with examples and edge cases)
```

### Phase 5: Why Flexbox Cannot Replace Tables (Estimated: 1 hour)

**This is critical context for understanding V1's failure.**

**Document:**

```markdown
## Why Flexbox Cannot Model Table Layout

### Fundamental Differences

1. **Constraint Direction**
   - Flexbox: Parent constrains children (top-down)
   - Tables: Children constrain columns, columns constrain cells (bottom-up + top-down)

2. **Global vs Local**
   - Flexbox: Each flex line is independent
   - Tables: All cells in a column share width constraint

3. **Content Introspection**
   - Flexbox: Uses flex-basis, doesn't analyze content deeply
   - Tables: Must measure all cell contents to compute column widths

### Concrete Example Where Flexbox Fails

HTML:
```html
<table>
  <tr><td>Short</td><td>Very long content here</td></tr>
  <tr><td>Also short</td><td>X</td></tr>
</table>
```

**Expected (table layout):**
- Column 1: Width of "Also short" (widest in column)
- Column 2: Width of "Very long content here" (widest in column)

**Actual (flexbox approximation):**
- Row 1: Distributes space independently
- Row 2: Distributes space independently
- **Columns do not align vertically!**

### Why V1's Hack Failed

V1 tried to fake tables with:
```rust
if element.tag == "table" {
    style.display = Display::Flex;
}
```

This cannot work because:
1. Flexbox doesn't analyze cell contents globally
2. Column widths vary per row instead of being consistent
3. No mechanism for colspan/rowspan
4. Border collapsing impossible

**Verdict: Tables must be implemented as tables, not approximated.**
```

## Output Artifacts

### Research Document

Create: **`docs/research/table-layout-spec.md`**

This should be a comprehensive reference document (2000-3000 words) covering:

1. **Table Structure** (500 words)
   - Display value hierarchy
   - Anonymous box generation
   - Structural constraints

2. **Fixed Layout** (600 words)
   - Algorithm in pseudocode
   - Edge cases
   - Spec quotes

3. **Auto Layout** (800 words)
   - Min/max width computation
   - Width distribution
   - Colspan handling
   - Edge cases

4. **Border Collapse** (400 words)
   - Conflict resolution
   - Precedence rules
   - Examples

5. **Why Not Flexbox** (300 words)
   - Fundamental differences
   - Concrete failure examples
   - V1 postmortem

### Notes File

Create: **`outputs/notes/W1.R02-notes.md`**

Using this template:

```markdown
# Task W1.R02 Output Notes

## Research Summary

[2-3 paragraph summary of table layout spec research]

## Key Findings

### Table Structure Model

- Display hierarchy: table > row-group > row > cell
- Anonymous boxes created when: ...
- Structural constraints: ...

### Fixed Layout Algorithm

High-level: [summary]
Complexity: O(n) where n = column count
Key insight: Only first row matters

### Auto Layout Algorithm

High-level: [summary]
Complexity: O(rows * columns) - must analyze all cells
Key insight: Bidirectional constraint problem

## Spec Interpretations

### Ambiguity 1: Colspan in fixed layout

**Spec says:** [quote]
**My interpretation:** ...
**Reasoning:** ...

(Continue for other ambiguities)

## Critical Implementation Notes

### For W3.T06 (Table Layout Implementation):

**Must implement TWO separate algorithms:**
1. Fixed layout (simpler, for table-layout: fixed)
2. Auto layout (complex, default)

**Cannot combine them** - they are fundamentally different.

**Anonymous box generation:**
- Implement structure fixup before layout
- Insert anonymous row/row-group/cell boxes
- Follow spec Section 3.2 rules precisely

**Border collapse:**
- Implement as separate pass after layout
- Use conflict resolution algorithm from Section 17.6.2
- Cache collapsed borders (expensive to compute)

### Algorithms in Pseudocode

[Include polished pseudocode for implementer to reference]

### Test Cases from Spec

[Extract specific test cases from spec examples]

## Discoveries & Gotchas

### Discovery 1: Table layout is a constraint solver

This is not a simple tree traversal. It's solving a system of constraints:
- Cell content → column min/max width
- Available width + column constraints → actual column widths
- Actual column widths → cell layout
- Cell layout → row heights

**Implication:** Must be multi-pass algorithm.

### Gotcha 1: Percentage widths are relative to table width

But table width may be auto, which depends on column widths, which depends on percentage widths!

**Spec resolution:** [How spec handles this circular dependency]

### Gotcha 2: Colspan distributes width non-uniformly

When distributing colspan width to columns, don't distribute evenly!
Use proportional distribution based on existing column widths.

## Recommendations for W3.T06

1. **Implement fixed layout first** - It's simpler, test it works
2. **Create table structure analyzer** - Before either algorithm
3. **Implement auto layout in phases**:
   - Phase 1: Min/max width computation
   - Phase 2: Width distribution
   - Phase 3: Cell layout with computed widths
4. **Test against WPT** - css-tables-3 tests
5. **Don't try to optimize prematurely** - Correctness first

## Open Questions

### Question 1: How do browsers handle deeply nested tables?

**Context:** Nested tables could have complex constraint interactions
**Needs:** Testing with browser implementations
**Assigned to:** W3.T06 during implementation

### Question 2: Exact percentage resolution in auto layout

**Context:** Spec is ambiguous on edge case...
**Needs:** Check Servo/WebKit implementations
**Assigned to:** W3.T06 during implementation

## References Studied

1. CSS Tables Module Level 3 - https://www.w3.org/TR/css-tables-3/
   - Sections 3, 4, 5, 6, 7 (all of them)
2. CSS 2.1 Chapter 17 - https://www.w3.org/TR/CSS21/tables.html
3. Servo table layout - `components/layout_2020/table/`
4. docs/plan/02-table-layout.md

---

**Research completed:** YYYY-MM-DD
**Time taken:** 6-8 hours
**Confidence level:** High - ready for implementation
```

## Common Pitfalls to Avoid

### Pitfall 1: Skimming the Spec

**Wrong:** Quickly read through and assume you understand
**Right:** Read every word of Sections 3-7, take notes, re-read confusing parts

The spec is dense but precise. Missing a detail will cause bugs.

### Pitfall 2: Not Writing Pseudocode

**Wrong:** Read spec, think you understand, move on
**Right:** Convert every algorithm to pseudocode

If you can't write it in pseudocode, you don't understand it well enough.

### Pitfall 3: Ignoring Edge Cases

**Wrong:** Focus on happy path examples
**Right:** Look for "undefined", "may", "implementation-dependent" in spec

These are where bugs hide.

### Pitfall 4: Not Comparing with Browser Code

**Wrong:** Rely only on spec
**Right:** Look at how Servo/WebKit actually implement it

Specs have ambiguities. Browsers have working code.

## Verification Checklist

Before marking research complete:

- [ ] Read CSS Tables Level 3, Sections 3-7 completely
- [ ] Read CSS 2.1 Chapter 17 completely
- [ ] Fixed layout algorithm in complete pseudocode
- [ ] Auto layout algorithm in complete pseudocode
- [ ] At least 20 spec quotes captured
- [ ] All major edge cases documented
- [ ] Concrete examples showing why flexbox fails
- [ ] Research document is 2000-3000 words
- [ ] Notes file complete with all sections
- [ ] Ready to implement W3.T06

## Time Tracking

Expected breakdown:
- **Table structure research:** 1-2 hours
- **Fixed layout research:** 2-3 hours
- **Auto layout research:** 2-3 hours
- **Border collapse research:** 1-2 hours
- **Writing documentation:** 1-2 hours
- **Total:** 6-8 hours

## Getting Help

If confused by spec language:

1. **Look at spec examples**: They clarify abstract text
2. **Check browser implementations**: Servo is written in Rust, easier to read
3. **Look for "Note" blocks in spec**: These explain rationale
4. **Compare CSS 2.1 vs Level 3**: Sometimes older spec is clearer

Remember: This is complex. Budget the full 6-8 hours. This research is CRITICAL for correct table implementation.
