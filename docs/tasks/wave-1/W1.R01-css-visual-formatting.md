---
task_id: "W1.R01"
title: "Research CSS 2.1 Visual Formatting Model (Chapters 9-10)"
wave: 1
estimated_hours: 8-12
depends_on: []
inputs:
  - "https://www.w3.org/TR/CSS21/visuren.html"
  - "https://www.w3.org/TR/CSS21/visudet.html"
outputs:
  - "docs/tasks/notes/W1.R01-notes.md"
skills_required:
  - "Technical reading"
  - "Specification analysis"
  - "Note-taking"
context_files:
  - "docs/architecture/foundation.md"
  - "docs/layout/block.md"
  - "docs/layout/inline.md"
verification:
  - "Notes file contains all required sections"
  - "Key algorithms documented with pseudocode"
  - "Ambiguities and questions documented"
---

# Research CSS 2.1 Visual Formatting Model (Chapters 9-10)

## Context

Before implementing any layout algorithms, we must thoroughly understand the CSS 2.1 Visual Formatting Model specification. This is THE authoritative source for how layout works in browsers.

CSS 2.1 is intentionally chosen over newer specs because:
1. It's stable and complete (unlike CSS3 which is modular and evolving)
2. It defines the foundation that all browsers implement
3. Modern layout modes (flex, grid) build on these fundamentals
4. It's the reference implementation for "normal flow" layout

This is a **research task**, not an implementation task. The output is comprehensive notes that will be consumed by multiple downstream implementation tasks (block layout, inline layout, float layout, positioned layout).

### Background

**What is the Visual Formatting Model?**

The Visual Formatting Model defines how user agents (browsers) process the document tree for visual media. It specifies:

- **Box Generation**: How elements generate boxes (Chapter 9.2)
- **Positioning Schemes**: Normal flow, floats, absolute positioning (Chapter 9.3)
- **Normal Flow**: Block formatting contexts, inline formatting contexts (Chapter 9.4)
- **Floats**: How floating elements work (Chapter 9.5)
- **Absolute Positioning**: How positioned elements are placed (Chapter 9.6)
- **Width Computation**: Algorithms for computing widths (Chapter 10.3)
- **Height Computation**: Algorithms for computing heights (Chapter 10.5)
- **Line Height**: How line boxes are sized (Chapter 10.8)

**Why Read the Actual Spec?**

Many developers learn CSS by experimentation, leading to incomplete mental models. The spec reveals:
- Edge cases that aren't obvious from simple examples
- Exact algorithms browsers must implement
- Ambiguities that need interpretation decisions
- Interaction between different features

### Why This Matters

Without deep spec knowledge, we'll make implementation mistakes:
- Wrong margin collapsing behavior → broken layouts
- Incorrect width computation → boxes don't fill containers
- Missing edge cases → bugs on complex pages
- Incompatible with browser behavior → can't render real websites

This research directly feeds into:
- **W2.T07**: FormattingContext trait design
- **W3.T04**: Block layout algorithm
- **W4.T12**: Inline layout algorithm
- **W3.T10**: Float layout
- **W3.T12**: Positioned layout

Every layout implementation task depends on these notes.

## Prerequisites

### Required Knowledge

- **HTML basics**: Understanding of document structure
- **CSS basics**: Selectors, properties, box model concepts
- **Reading comprehension**: Ability to parse technical specifications
- **Note-taking skills**: Organizing complex information

### Required Reading

1. **CSS 2.1 Chapter 9 (Visual Formatting Model)**: https://www.w3.org/TR/CSS21/visuren.html
   - Read EVERY section thoroughly
   - Take notes on each subsection
   - Pay special attention to definitions (they're precise for a reason)

2. **CSS 2.1 Chapter 10 (Visual Formatting Model Details)**: https://www.w3.org/TR/CSS21/visudet.html
   - Focus on sections 10.3 (width), 10.5 (height), 10.6 (block height), 10.8 (line height)
   - These contain the actual algorithms

3. **CSS 2.1 Chapter 8 (Box Model)**: https://www.w3.org/TR/CSS21/box.html
   - Section 8.3 (margin collapsing) is CRITICAL

## Inputs

### From Dependencies

**None** - This is a Wave 1 research task with no dependencies.

### External Resources

1. **Primary Source**: CSS 2.1 Specification
   - Chapter 9: https://www.w3.org/TR/CSS21/visuren.html
   - Chapter 10: https://www.w3.org/TR/CSS21/visudet.html
   - Chapter 8: https://www.w3.org/TR/CSS21/box.html

2. **Recommended Secondary Reading**:
   - MDN Visual Formatting Model: https://developer.mozilla.org/en-US/docs/Web/CSS/Visual_formatting_model
   - Servo's layout documentation (for implementation perspective)
   - WebKit's LayoutNG design docs (modern approach)

## Objectives

### Primary Goals

1. **Understand Box Generation**: How elements create boxes, anonymous box generation
2. **Understand Positioning Schemes**: Normal flow vs floats vs absolute positioning
3. **Understand Block Formatting**: How block boxes are laid out vertically
4. **Understand Inline Formatting**: How inline boxes are laid out horizontally
5. **Understand Width Computation**: All the different width calculation scenarios
6. **Understand Height Computation**: Auto height, percentage heights, etc.
7. **Understand Margin Collapsing**: The complete algorithm with all edge cases
8. **Document Ambiguities**: Places where the spec is unclear or underspecified

### Success Criteria

- [ ] Complete notes file with all sections filled out
- [ ] Box generation rules documented with examples
- [ ] Each formatting context type explained with pseudocode
- [ ] Width computation algorithms documented for all scenarios
- [ ] Height computation algorithms documented for all scenarios
- [ ] Margin collapsing algorithm documented with edge cases
- [ ] At least 10 ambiguities/questions identified and documented
- [ ] Key spec quotes captured (with section references)
- [ ] Cross-references to relevant implementation tasks
- [ ] Notes are structured for easy reference during implementation

## Research Guide

### Step 1: Read Chapter 9.1-9.2 (Box Generation) (Estimated: 2 hours)

**What to focus on:**
1. How elements generate principal boxes
2. Anonymous box generation rules
3. The difference between block-level and block container
4. Inline-level vs inline boxes

**Questions to answer:**
- When do anonymous boxes get generated?
- What CSS properties establish block formatting contexts?
- What is the difference between "block-level" and "block container"?
- How do display values map to box types?

**Take notes on:**
- Exact conditions for anonymous box creation
- Table showing display values and resulting box types
- Examples from the spec

**Template for notes:**

```markdown
## Box Generation (CSS 2.1 Section 9.2)

### Principal Boxes

[Explain what a principal box is]

### Block-Level Elements

**Definition** (from spec): [exact quote]

**Creates**: Block-level boxes

**Examples**: div, p, h1, ...

### Inline-Level Elements

**Definition** (from spec): [exact quote]

**Creates**: Inline-level boxes

**Examples**: span, a, em, ...

### Anonymous Boxes

**When generated**: [conditions]

**Rules**:
1. [Rule from spec]
2. [Rule from spec]

**Example**:
[Concrete example with HTML and box tree]
```

### Step 2: Read Chapter 9.3 (Positioning Schemes) (Estimated: 1.5 hours)

**What to focus on:**
1. Normal flow definition
2. Float positioning
3. Absolute positioning
4. The containing block concept

**Questions to answer:**
- What exactly is "normal flow"?
- How do floats differ from normal flow?
- What elements are taken "out of flow"?
- How is the containing block determined for different position values?

**Take notes on:**
- The three positioning schemes and their differences
- Containing block definition for each positioning type
- What "out of flow" means precisely

### Step 3: Read Chapter 9.4 (Normal Flow) (Estimated: 2-3 hours)

**This is the most important section.**

#### 9.4.1: Block Formatting Contexts

**What to focus on:**
1. What establishes a BFC?
2. How boxes are laid out in a BFC
3. How floats interact with BFCs

**Questions to answer:**
- Complete list: what establishes a BFC?
- In a BFC, where are block-level boxes positioned?
- How do margins collapse in a BFC?
- How do BFCs interact with floats?

**Template for notes:**

```markdown
## Block Formatting Context (CSS 2.1 Section 9.4.1)

### What Establishes a BFC

(From spec): "Floats, absolutely positioned elements, block containers..."

**Complete list**:
1. Root element
2. Floats (float: left or right)
3. Absolutely positioned elements (position: absolute or fixed)
4. Block containers that are not block boxes (inline-blocks, table-cells)
5. Block boxes with overflow other than visible
6. [etc]

### Layout Rules

**Vertical stacking** (from spec): "In a block formatting context, boxes are laid out one after the other, vertically, beginning at the top of a containing block."

**Algorithm** (pseudocode):
```
function layout_bfc(boxes, containing_width):
    current_y = 0
    for each box in boxes:
        1. Compute box width (see Section 10.3.3)
        2. Layout box contents (recursive)
        3. Compute box height
        4. Position box at (0, current_y)
        5. Apply margin collapsing
        6. current_y += box.height + collapsed_margin
```

### Margin Collapsing in BFC

**Key quote** (Section 8.3.1): "In CSS, the adjoining margins of two or more boxes..."

[Document the complete algorithm]

### BFC and Floats

**Key quote** (Section 9.5): "The border box of a block formatting context must not overlap..."

[Explain how BFCs contain floats]
```

#### 9.4.2: Inline Formatting Contexts

**What to focus on:**
1. How inline boxes are laid out horizontally
2. Line boxes concept
3. Baseline alignment
4. Bidi text handling

**Questions to answer:**
- What is a line box?
- How are inline boxes positioned within a line box?
- What happens when content doesn't fit on one line?
- How does text-align affect inline boxes?

#### 9.4.3: Relative Positioning

**What to focus on:**
- How relative positioning differs from static
- When offsets are applied

### Step 4: Read Chapter 9.5 (Floats) (Estimated: 1.5 hours)

**What to focus on:**
1. Float positioning algorithm
2. Float interaction with other boxes
3. Clear property behavior

**Questions to answer:**
- Exactly where are floats positioned?
- How does content flow around floats?
- What does "clear" do precisely?
- Can floats overlap?

**Template for notes:**

```markdown
## Floats (CSS 2.1 Section 9.5)

### Float Positioning Rules

**Key quote**: [quote the 8 rules from section 9.5.1]

**Algorithm** (pseudocode):
```
function place_float(float_box, containing_block, previous_floats):
    1. [Step by step algorithm derived from the 8 rules]
    2. ...
```

### Float Interaction

[How normal flow content wraps around floats]

### Clear Property

[How clear works with exact algorithm]
```

### Step 5: Read Chapter 9.6 (Absolute Positioning) (Estimated: 1 hour)

**What to focus on:**
1. Fixed vs absolute positioning
2. How containing block is determined
3. How offsets are applied

### Step 6: Read Chapter 10.3 (Width Computation) (Estimated: 2-3 hours)

**This section contains crucial algorithms.**

**What to focus on:**
1. Section 10.3.3: Block-level, non-replaced elements in normal flow
2. Section 10.3.4: Block-level, replaced elements in normal flow
3. Section 10.3.7: Absolutely positioned, non-replaced elements
4. The constraint equation: margin-left + border-left + padding-left + width + padding-right + border-right + margin-right = containing block width

**For EACH subsection, document:**
- The constraint equation
- Which values become 0 if auto
- What happens if over-constrained
- Pseudocode algorithm

**Template:**

```markdown
## Width Computation for Block-Level, Non-Replaced in Normal Flow (10.3.3)

### Constraint Equation

```
margin-left + border-left-width + padding-left + width +
padding-right + border-right-width + margin-right = containing block width
```

### Algorithm

**If width is not auto**:
- If margin-left and margin-right are both auto: [what happens]
- If only one margin is auto: [what happens]
- If neither is auto (over-constrained): [what happens]

**If width is auto**:
- [Algorithm]

### Pseudocode

```
function compute_block_width(style, containing_width):
    let ml = style.margin_left or 0
    let mr = style.margin_right or 0
    let pl = resolve(style.padding_left, containing_width)
    let pr = resolve(style.padding_right, containing_width)
    let bl = style.border_left_width
    let br = style.border_right_width

    if style.width is not auto:
        let w = resolve(style.width, containing_width)

        if ml is auto and mr is auto:
            // Center the box
            let available = containing_width - bl - pl - w - pr - br
            ml = available / 2
            mr = available / 2
        else if ml is auto:
            ml = containing_width - mr - bl - pl - w - pr - br
        else if mr is auto:
            mr = containing_width - ml - bl - pl - w - pr - br
        else:
            // Over-constrained
            mr = containing_width - ml - bl - pl - w - pr - br
    else:
        // width is auto
        if ml is auto: ml = 0
        if mr is auto: mr = 0
        w = containing_width - ml - bl - pl - pr - br - mr
        w = max(w, 0)

    return (ml, w, mr)
```

### Edge Cases

1. **Negative width**: If computed width is negative, use 0
2. **Auto margins with auto width**: Margins become 0, width uses remaining space
3. [Other edge cases]
```

### Step 7: Read Chapter 10.5-10.6 (Height Computation) (Estimated: 2 hours)

**What to focus on:**
1. Section 10.5: Content height
2. Section 10.6: Complicated cases (normal flow blocks)
3. Auto height computation
4. Percentage heights

**Key questions:**
- How is auto height computed for blocks?
- When do percentage heights work?
- How does height interact with margins?

### Step 8: Read Chapter 8.3.1 (Margin Collapsing) (Estimated: 2 hours)

**This is extremely complex and critical.**

**What to focus on:**
1. When margins collapse
2. When margins DON'T collapse
3. The collapsing algorithm (positive, negative, mixed)
4. All the edge cases

**Document:**
- Complete list of conditions when margins collapse
- Complete list of conditions when margins DON'T collapse
- The three scenarios: both positive, both negative, mixed
- Edge cases: empty boxes, first/last child, etc.

**Template:**

```markdown
## Margin Collapsing (CSS 2.1 Section 8.3.1)

### When Margins Collapse

**Adjacent vertical margins collapse if**:
1. [Condition from spec]
2. [Condition from spec]
...

### When Margins DON'T Collapse

**Margins do NOT collapse if**:
1. Between a box and its parent if the parent has border/padding
2. [Other conditions]
...

### Collapsing Algorithm

**For positive margins**: Take the maximum
**For negative margins**: Take the minimum (most negative)
**For mixed**: max(positive) + min(negative)

### Pseudocode

```
struct CollapsibleMargin {
    positive: f32,
    negative: f32,
}

function collapse(m1: CollapsibleMargin, m2: CollapsibleMargin) -> CollapsibleMargin {
    CollapsibleMargin {
        positive: max(m1.positive, m2.positive),
        negative: max(m1.negative, m2.negative),
    }
}

function resolve(m: CollapsibleMargin) -> f32 {
    m.positive - m.negative
}
```

### Edge Cases

1. **Empty boxes**: [How margins collapse through empty boxes]
2. **First child**: [Parent's top margin collapsing with first child]
3. **Last child**: [Parent's bottom margin collapsing with last child]
4. **Clearance**: [How clear affects margin collapsing]
```

### Step 9: Document Ambiguities and Questions (Estimated: 1 hour)

**As you read, maintain a list of:**
- Ambiguous wording in the spec
- Cases not explicitly covered
- Contradictions or unclear interactions
- Questions about implementation details

**Template:**

```markdown
## Ambiguities and Open Questions

### Ambiguity 1: Percentage Heights Without Explicit Containing Block Height

**Section**: 10.5

**Issue**: Spec says "If the height of the containing block is not specified explicitly... the value computes to 'auto'."

**Ambiguity**: What about implicit heights from content? Does this make ALL percentage heights on typical pages auto?

**Browser behavior**: [Research what browsers actually do]

**Recommended interpretation**: [Your suggestion]

**Needs testing**: Yes - create test cases

### Question 1: Margin Collapsing Through Nested Empty Boxes

**Section**: 8.3.1

**Issue**: If you have multiple nested empty divs, how do margins collapse?

**Example**:
```html
<div style="margin-bottom: 20px"></div>
<div style="margin-top: 10px">
  <div style="margin-top: 15px"></div>
</div>
```

**Spec says**: [Quote relevant part]

**Interpretation needed**: [What you think happens]

**Action item**: Test in browsers, document in W3.T05 (margin collapsing implementation)
```

### Step 10: Create Cross-References (Estimated: 30min)

**Link sections to implementation tasks:**

```markdown
## Implementation Task Mapping

### W2.T07: FormattingContext Trait
**Needs from this research**:
- Definition of formatting context (Section 9.4)
- Common operations all FCs perform
- Input/output contracts

### W3.T04: Block Layout
**Needs from this research**:
- Section 9.4.1: Block formatting contexts
- Section 10.3.3: Block width computation
- Section 10.6.3: Block height computation
- Section 8.3.1: Margin collapsing

### W4.T12: Inline Layout
**Needs from this research**:
- Section 9.4.2: Inline formatting contexts
- Section 10.8: Line height
- Line box algorithm

[Continue for all relevant tasks]
```

## Output Artifacts

### Notes File

Create: **`docs/tasks/notes/W1.R01-notes.md`**

**Required structure:**

```markdown
# Task W1.R01 Research Notes: CSS 2.1 Visual Formatting Model

## Executive Summary

[2-3 paragraph overview of the visual formatting model]

## Box Generation (Chapter 9.2)

[Complete notes as outlined above]

## Positioning Schemes (Chapter 9.3)

[Complete notes]

## Block Formatting Context (Chapter 9.4.1)

[Complete notes with algorithm pseudocode]

## Inline Formatting Context (Chapter 9.4.2)

[Complete notes with algorithm pseudocode]

## Floats (Chapter 9.5)

[Complete notes with float positioning algorithm]

## Absolute Positioning (Chapter 9.6)

[Complete notes]

## Width Computation (Chapter 10.3)

### 10.3.3: Block-level, non-replaced in normal flow
[Complete algorithm with pseudocode]

### 10.3.4: Block-level, replaced in normal flow
[Complete algorithm]

[etc for all subsections]

## Height Computation (Chapter 10.5-10.6)

[Complete notes with algorithms]

## Margin Collapsing (Chapter 8.3.1)

[Complete algorithm with all edge cases]

## Ambiguities and Questions

[List of at least 10 items]

## Key Spec Quotes

[Important quotes with section references]

## Implementation Task Mapping

[Cross-references to W2, W3, W4 tasks]

## Glossary

[Define all spec terms: containing block, block-level, block container, etc.]

## References

- CSS 2.1 Chapter 9: https://www.w3.org/TR/CSS21/visuren.html
- CSS 2.1 Chapter 10: https://www.w3.org/TR/CSS21/visudet.html
- CSS 2.1 Chapter 8: https://www.w3.org/TR/CSS21/box.html

---

**Research completed**: YYYY-MM-DD
**Time taken**: X hours
**Pages read**: ~150 pages of spec
**Ambiguities identified**: N
```

## Common Pitfalls to Avoid

### Pitfall 1: Skimming Instead of Deep Reading

**Wrong:** Quickly reading through, assuming you understand
**Right:** Read every sentence carefully, take notes on each paragraph, test your understanding with examples

The spec is dense. Every sentence matters.

### Pitfall 2: Not Documenting Ambiguities

**Wrong:** Glossing over unclear parts
**Right:** When something is ambiguous, document it explicitly. These become test cases later.

### Pitfall 3: Not Creating Pseudocode

**Wrong:** Just copying spec text
**Right:** Convert spec algorithms into pseudocode. This forces you to truly understand them.

### Pitfall 4: Missing Cross-References

**Wrong:** Creating isolated notes
**Right:** Link sections to the implementation tasks that will need them. Future you (or other agents) will thank you.

### Pitfall 5: Not Testing Understanding

**Wrong:** Reading without verification
**Right:** For each major algorithm, create a concrete example and work through it step by step.

## Verification Checklist

Before marking research complete:

- [ ] Entire Chapter 9 read and notes taken
- [ ] Entire Chapter 10 (at least sections 10.3, 10.5, 10.6, 10.8) read and notes taken
- [ ] Section 8.3.1 (margin collapsing) read and fully documented
- [ ] At least one algorithm converted to pseudocode for each major concept
- [ ] At least 10 ambiguities/questions documented
- [ ] Cross-references to implementation tasks created
- [ ] Notes file is well-organized and easy to navigate
- [ ] Key spec quotes captured with section numbers
- [ ] Concrete examples created for complex algorithms

## Time Tracking

Estimated breakdown:
- **Chapter 9.1-9.2 (Box generation):** 2 hours
- **Chapter 9.3 (Positioning schemes):** 1.5 hours
- **Chapter 9.4 (Normal flow):** 2-3 hours
- **Chapter 9.5 (Floats):** 1.5 hours
- **Chapter 9.6 (Absolute positioning):** 1 hour
- **Chapter 10.3 (Width):** 2-3 hours
- **Chapter 10.5-10.6 (Height):** 2 hours
- **Chapter 8.3.1 (Margin collapsing):** 2 hours
- **Documentation and organization:** 1 hour
- **Total:** 8-12 hours

Don't rush this. Thorough research now saves days of debugging later.

## Getting Help

If stuck:

1. **Re-read the spec section**: Often a second reading clarifies
2. **Check MDN**: Modern explanations can help understand spec text
3. **Look at browser code**: Servo/WebKit source can show how it's actually implemented
4. **Create test cases**: Write HTML and see what browsers do
5. **Document questions**: Put unclear items in "Ambiguities" section for later resolution

Remember: Research tasks are different from implementation tasks. Your output is knowledge, not code. Be thorough, organized, and precise. These notes will be referenced dozens of times during implementation.
