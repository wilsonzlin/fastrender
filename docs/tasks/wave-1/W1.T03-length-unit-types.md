---
task_id: "W1.T03"
title: "Implement Length, LengthUnit, and LengthOrAuto Types"
wave: 1
estimated_hours: 4-6
depends_on: []
inputs: []
outputs:
  - "src/style/values.rs"
  - "docs/tasks/notes/W1.T03-notes.md"
skills_required:
  - "Rust fundamentals"
  - "CSS value types knowledge"
  - "Enum design patterns"
context_files:
  - "docs/core/type-system.md"
verification:
  - "cargo test style::values"
  - "cargo clippy -- -D warnings"
---

# Implement Length, LengthUnit, and LengthOrAuto Types

## Context

CSS properties use various types of values: lengths (10px, 2em), percentages (50%), keywords (auto), colors, etc. Before we can represent computed styles or perform layout calculations, we need types to represent these CSS values.

This task implements the foundational value types for lengths and sizing, which are used everywhere in CSS layout:
- `width: 100px` → Length { value: 100.0, unit: Px }
- `margin: auto` → LengthOrAuto::Auto
- `padding: 2em` → Length { value: 2.0, unit: Em }
- `height: 50%` → Length { value: 50.0, unit: Percent }

These types bridge between CSS syntax and layout algorithms. They're Wave 1 foundation tasks because virtually every property in ComputedStyle will use them.

### Background

**CSS Length Values:**

CSS defines several types of length units:
1. **Absolute units**: px, pt, pc, in, cm, mm
2. **Font-relative units**: em, rem, ex, ch
3. **Viewport-relative units**: vw, vh, vmin, vmax
4. **Percentages**: Relative to containing block or font size

**CSS auto keyword:**

Many properties accept `auto` which means "compute automatically based on context":
- `width: auto` → Fill available space (for blocks)
- `margin: auto` → Center the box (for horizontal margins)
- `height: auto` → Size based on content

**Computed vs Specified Values:**

- **Specified**: What the CSS says (`width: 2em`)
- **Computed**: Partially resolved (`width: 32px` if font-size is 16px)
- **Used**: Final value after layout (`width: 320px` after resolving percentages)

We're implementing **computed value** types. Layout algorithms convert these to used values.

### Why This Matters

Without proper value types:
- Can't represent CSS properties in ComputedStyle (W2.T05)
- Can't resolve percentages during layout (all Wave 3-4 tasks)
- Can't handle relative units like em/rem (W3.T16, font metrics)
- Can't distinguish between `width: 0` and `width: auto` (different behaviors)

Every style-related task in Waves 2-6 depends on these types.

## Prerequisites

### Required Knowledge
- **Rust enums**: Variants, pattern matching, data-carrying enums
- **Rust Copy trait**: When to use Copy vs Clone
- **CSS units**: Difference between px, em, rem, %, etc.
- **CSS computed values**: Concept of value computation in CSS

### Required Reading
1. **CSS Values and Units Module Level 3**: https://www.w3.org/TR/css-values-3/
   - Section 5: Distance Units
   - Section 6: Percentages
2. **CSS 2.1 Section 4.3**: Values (length, percentage, auto)
3. **Rust Book Chapter 6**: Enums and Pattern Matching

## Inputs

### From Dependencies

**None** - This is a Wave 1 task with no dependencies.

### Existing Code

Check if there's an existing `src/style/` directory. If not, you'll need to create:
- `src/style/` directory
- `src/style/mod.rs` module file
- Add `pub mod style;` to `src/lib.rs`

## Objectives

### Primary Goals

1. **Implement LengthUnit enum**: All CSS length unit types
2. **Implement Length struct**: Value + unit pair with resolution methods
3. **Implement LengthOrAuto enum**: Discriminated union of Length | Auto
4. **Add percentage resolution**: Convert relative values to absolute
5. **Add unit conversion**: Convert between absolute units (px ↔ pt ↔ in)
6. **Write comprehensive tests**: All units, conversion edge cases

### Success Criteria

- [ ] LengthUnit enum with all common unit types
- [ ] Length struct with value and unit fields
- [ ] LengthOrAuto enum with Auto and Length variants
- [ ] `Length::resolve()` method for computing absolute values
- [ ] Unit conversion methods (pt_to_px, in_to_px, etc.)
- [ ] Convenience constructors (Length::px, Length::em, etc.)
- [ ] All types derive Copy, Debug, Clone, PartialEq
- [ ] All tests pass
- [ ] Clippy clean, rustfmt applied
- [ ] Full rustdoc documentation
- [ ] Notes file complete

## Implementation Guide

### Step 1: Setup Module Structure (Estimated: 30min)

**What to do:**
1. Create `src/style/` directory if it doesn't exist
2. Create `src/style/values.rs`
3. Create `src/style/mod.rs`
4. Update `src/lib.rs` to include style module

**Code:**

```bash
mkdir -p src/style
touch src/style/values.rs
touch src/style/mod.rs
```

**`src/style/mod.rs`:**
```rust
//! Style system types
//!
//! This module contains types related to CSS styling, including
//! computed styles, property values, and style resolution.

pub mod values;

// Re-export common types
pub use values::{Length, LengthUnit, LengthOrAuto};
```

**`src/lib.rs`** (add this):
```rust
pub mod style;

// Re-export common types
pub use style::{Length, LengthUnit, LengthOrAuto};
```

### Step 2: Implement LengthUnit Enum (Estimated: 1 hour)

**What to do:**
1. Define enum with variants for all CSS length units
2. Add methods: `is_absolute()`, `is_font_relative()`, `is_viewport_relative()`
3. Add convenience predicates

**Implementation:**

**`src/style/values.rs`:**
```rust
//! CSS value types
//!
//! This module provides types for representing CSS values in their computed form.
//! These types are used throughout the style and layout systems.
//!
//! # Units
//!
//! CSS supports various length units. We categorize them as:
//! - **Absolute**: px, pt, pc, in, cm, mm
//! - **Font-relative**: em, rem, ex, ch
//! - **Viewport-relative**: vw, vh, vmin, vmax
//! - **Percentages**: Relative to containing block or font size
//!
//! Reference: CSS Values and Units Module Level 3
//! https://www.w3.org/TR/css-values-3/

use std::fmt;

/// CSS length units
///
/// Represents the unit portion of a CSS length value.
///
/// # Examples
///
/// ```
/// use fastrender::style::LengthUnit;
///
/// let unit = LengthUnit::Px;
/// assert!(unit.is_absolute());
///
/// let font_unit = LengthUnit::Em;
/// assert!(font_unit.is_font_relative());
/// ```
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum LengthUnit {
    /// Pixels (px) - CSS reference unit, 1/96th of an inch
    Px,

    /// Points (pt) - 1/72nd of an inch
    Pt,

    /// Picas (pc) - 12 points
    Pc,

    /// Inches (in)
    In,

    /// Centimeters (cm)
    Cm,

    /// Millimeters (mm)
    Mm,

    /// Em units - relative to element's font size
    Em,

    /// Rem units - relative to root element's font size
    Rem,

    /// Ex units - relative to x-height of the font
    Ex,

    /// Ch units - relative to width of '0' character
    Ch,

    /// Viewport width percentage (vw) - 1% of viewport width
    Vw,

    /// Viewport height percentage (vh) - 1% of viewport height
    Vh,

    /// Viewport minimum (vmin) - 1% of smaller viewport dimension
    Vmin,

    /// Viewport maximum (vmax) - 1% of larger viewport dimension
    Vmax,

    /// Percentage (%) - relative to containing block or font size
    Percent,
}

impl LengthUnit {
    /// Returns true if this is an absolute unit (px, pt, pc, in, cm, mm)
    ///
    /// Absolute units have fixed physical sizes and can be converted
    /// between each other without context.
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::style::LengthUnit;
    ///
    /// assert!(LengthUnit::Px.is_absolute());
    /// assert!(LengthUnit::In.is_absolute());
    /// assert!(!LengthUnit::Em.is_absolute());
    /// ```
    pub fn is_absolute(self) -> bool {
        matches!(
            self,
            Self::Px | Self::Pt | Self::Pc | Self::In | Self::Cm | Self::Mm
        )
    }

    /// Returns true if this is a font-relative unit (em, rem, ex, ch)
    ///
    /// Font-relative units require font metrics to resolve.
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::style::LengthUnit;
    ///
    /// assert!(LengthUnit::Em.is_font_relative());
    /// assert!(LengthUnit::Rem.is_font_relative());
    /// assert!(!LengthUnit::Px.is_font_relative());
    /// ```
    pub fn is_font_relative(self) -> bool {
        matches!(self, Self::Em | Self::Rem | Self::Ex | Self::Ch)
    }

    /// Returns true if this is a viewport-relative unit (vw, vh, vmin, vmax)
    ///
    /// Viewport-relative units require viewport dimensions to resolve.
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::style::LengthUnit;
    ///
    /// assert!(LengthUnit::Vw.is_viewport_relative());
    /// assert!(LengthUnit::Vh.is_viewport_relative());
    /// assert!(!LengthUnit::Px.is_viewport_relative());
    /// ```
    pub fn is_viewport_relative(self) -> bool {
        matches!(self, Self::Vw | Self::Vh | Self::Vmin | Self::Vmax)
    }

    /// Returns true if this is a percentage
    pub fn is_percentage(self) -> bool {
        matches!(self, Self::Percent)
    }

    /// Returns the canonical string representation of this unit
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::style::LengthUnit;
    ///
    /// assert_eq!(LengthUnit::Px.as_str(), "px");
    /// assert_eq!(LengthUnit::Em.as_str(), "em");
    /// assert_eq!(LengthUnit::Percent.as_str(), "%");
    /// ```
    pub fn as_str(self) -> &'static str {
        match self {
            Self::Px => "px",
            Self::Pt => "pt",
            Self::Pc => "pc",
            Self::In => "in",
            Self::Cm => "cm",
            Self::Mm => "mm",
            Self::Em => "em",
            Self::Rem => "rem",
            Self::Ex => "ex",
            Self::Ch => "ch",
            Self::Vw => "vw",
            Self::Vh => "vh",
            Self::Vmin => "vmin",
            Self::Vmax => "vmax",
            Self::Percent => "%",
        }
    }
}

impl fmt::Display for LengthUnit {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.as_str())
    }
}
```

### Step 3: Implement Length Struct (Estimated: 2 hours)

**What to do:**
1. Define struct with value (f32) and unit (LengthUnit)
2. Add convenience constructors for each unit type
3. Add `resolve()` method for computing absolute pixel values
4. Add unit conversion helpers

**Implementation:**

```rust
/// A CSS length value with a specific unit
///
/// Represents a computed length value that may need further resolution
/// depending on context (containing block size, font size, etc.).
///
/// # Examples
///
/// ```
/// use fastrender::style::{Length, LengthUnit};
///
/// let length = Length::px(100.0);
/// assert_eq!(length.value, 100.0);
/// assert_eq!(length.unit, LengthUnit::Px);
///
/// let em_length = Length::em(2.0);
/// let resolved = em_length.resolve_with_font_size(16.0);
/// assert_eq!(resolved, 32.0);
/// ```
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Length {
    /// The numeric value
    pub value: f32,
    /// The unit
    pub unit: LengthUnit,
}

impl Length {
    /// Creates a new length with the given value and unit
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::style::{Length, LengthUnit};
    ///
    /// let length = Length::new(10.0, LengthUnit::Px);
    /// assert_eq!(length.value, 10.0);
    /// ```
    pub const fn new(value: f32, unit: LengthUnit) -> Self {
        Self { value, unit }
    }

    // Convenience constructors for absolute units

    /// Creates a length in pixels
    pub const fn px(value: f32) -> Self {
        Self::new(value, LengthUnit::Px)
    }

    /// Creates a length in points (1pt = 1.333px)
    pub const fn pt(value: f32) -> Self {
        Self::new(value, LengthUnit::Pt)
    }

    /// Creates a length in picas (1pc = 16px)
    pub const fn pc(value: f32) -> Self {
        Self::new(value, LengthUnit::Pc)
    }

    /// Creates a length in inches (1in = 96px)
    pub const fn inches(value: f32) -> Self {
        Self::new(value, LengthUnit::In)
    }

    /// Creates a length in centimeters (1cm = 37.8px)
    pub const fn cm(value: f32) -> Self {
        Self::new(value, LengthUnit::Cm)
    }

    /// Creates a length in millimeters (1mm = 3.78px)
    pub const fn mm(value: f32) -> Self {
        Self::new(value, LengthUnit::Mm)
    }

    // Convenience constructors for relative units

    /// Creates a length in em units
    pub const fn em(value: f32) -> Self {
        Self::new(value, LengthUnit::Em)
    }

    /// Creates a length in rem units
    pub const fn rem(value: f32) -> Self {
        Self::new(value, LengthUnit::Rem)
    }

    /// Creates a length in ex units
    pub const fn ex(value: f32) -> Self {
        Self::new(value, LengthUnit::Ex)
    }

    /// Creates a length in ch units
    pub const fn ch(value: f32) -> Self {
        Self::new(value, LengthUnit::Ch)
    }

    /// Creates a percentage value
    pub const fn percent(value: f32) -> Self {
        Self::new(value, LengthUnit::Percent)
    }

    // Unit conversion methods

    /// Converts this length to pixels
    ///
    /// For absolute units, this performs unit conversion.
    /// For relative units, you must use the context-specific resolve methods.
    ///
    /// # Panics
    ///
    /// Panics if called on a relative unit (em, rem, %, etc.)
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::style::Length;
    ///
    /// assert_eq!(Length::px(100.0).to_px(), 100.0);
    /// assert_eq!(Length::pt(72.0).to_px(), 96.0); // 72pt = 1in = 96px
    /// ```
    pub fn to_px(self) -> f32 {
        match self.unit {
            LengthUnit::Px => self.value,
            LengthUnit::Pt => self.value * (96.0 / 72.0), // 1pt = 1/72 inch
            LengthUnit::Pc => self.value * 16.0,           // 1pc = 12pt = 16px
            LengthUnit::In => self.value * 96.0,           // 1in = 96px (CSS spec)
            LengthUnit::Cm => self.value * 37.795276,      // 1cm = 96px/2.54
            LengthUnit::Mm => self.value * 3.7795276,      // 1mm = 1/10 cm
            _ => panic!(
                "Cannot convert {} to px without context",
                self.unit.as_str()
            ),
        }
    }

    /// Resolves this length to pixels using a percentage base
    ///
    /// Used when the length is relative to a containing block dimension.
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::style::Length;
    ///
    /// let length = Length::percent(50.0);
    /// assert_eq!(length.resolve_against(200.0), 100.0);
    ///
    /// let px_length = Length::px(100.0);
    /// assert_eq!(px_length.resolve_against(200.0), 100.0); // Absolute units ignore base
    /// ```
    pub fn resolve_against(self, percentage_base: f32) -> f32 {
        match self.unit {
            LengthUnit::Percent => (self.value / 100.0) * percentage_base,
            _ if self.unit.is_absolute() => self.to_px(),
            _ => panic!(
                "Cannot resolve {} without additional context",
                self.unit.as_str()
            ),
        }
    }

    /// Resolves this length using a font size (for em/rem units)
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::style::Length;
    ///
    /// let length = Length::em(2.0);
    /// assert_eq!(length.resolve_with_font_size(16.0), 32.0);
    ///
    /// let rem_length = Length::rem(1.5);
    /// assert_eq!(rem_length.resolve_with_font_size(16.0), 24.0);
    /// ```
    pub fn resolve_with_font_size(self, font_size_px: f32) -> f32 {
        match self.unit {
            LengthUnit::Em | LengthUnit::Rem => self.value * font_size_px,
            _ if self.unit.is_absolute() => self.to_px(),
            _ => panic!(
                "Cannot resolve {} with only font size",
                self.unit.as_str()
            ),
        }
    }

    /// Resolves this length using viewport dimensions
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::style::Length;
    ///
    /// let length = Length::new(50.0, fastrender::style::LengthUnit::Vw);
    /// assert_eq!(length.resolve_with_viewport(800.0, 600.0), 400.0);
    ///
    /// let vh_length = Length::new(50.0, fastrender::style::LengthUnit::Vh);
    /// assert_eq!(vh_length.resolve_with_viewport(800.0, 600.0), 300.0);
    /// ```
    pub fn resolve_with_viewport(self, viewport_width: f32, viewport_height: f32) -> f32 {
        match self.unit {
            LengthUnit::Vw => (self.value / 100.0) * viewport_width,
            LengthUnit::Vh => (self.value / 100.0) * viewport_height,
            LengthUnit::Vmin => {
                (self.value / 100.0) * viewport_width.min(viewport_height)
            }
            LengthUnit::Vmax => {
                (self.value / 100.0) * viewport_width.max(viewport_height)
            }
            _ if self.unit.is_absolute() => self.to_px(),
            _ => panic!(
                "Cannot resolve {} with only viewport dimensions",
                self.unit.as_str()
            ),
        }
    }

    /// Returns true if this is a zero length
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::style::Length;
    ///
    /// assert!(Length::px(0.0).is_zero());
    /// assert!(!Length::px(0.1).is_zero());
    /// ```
    pub fn is_zero(self) -> bool {
        self.value == 0.0
    }
}

impl fmt::Display for Length {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}{}", self.value, self.unit)
    }
}
```

### Step 4: Implement LengthOrAuto Enum (Estimated: 1 hour)

**What to do:**
1. Define enum with Auto and Length variants
2. Add convenience methods and constructors
3. Add pattern matching helpers

**Implementation:**

```rust
/// A CSS length value or the `auto` keyword
///
/// Many CSS properties accept either a specific length or `auto`,
/// which means "compute automatically based on context".
///
/// # Examples
///
/// ```
/// use fastrender::style::{LengthOrAuto, Length};
///
/// let auto_width = LengthOrAuto::Auto;
/// assert!(auto_width.is_auto());
///
/// let fixed_width = LengthOrAuto::Length(Length::px(100.0));
/// assert_eq!(fixed_width.to_px().unwrap(), 100.0);
/// ```
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum LengthOrAuto {
    /// A specific length value
    Length(Length),
    /// The `auto` keyword
    Auto,
}

impl LengthOrAuto {
    /// Creates a length in pixels
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::style::LengthOrAuto;
    ///
    /// let width = LengthOrAuto::px(100.0);
    /// assert_eq!(width.to_px().unwrap(), 100.0);
    /// ```
    pub const fn px(value: f32) -> Self {
        Self::Length(Length::px(value))
    }

    /// Creates a percentage value
    pub const fn percent(value: f32) -> Self {
        Self::Length(Length::percent(value))
    }

    /// Returns true if this is `auto`
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::style::LengthOrAuto;
    ///
    /// assert!(LengthOrAuto::Auto.is_auto());
    /// assert!(!LengthOrAuto::px(100.0).is_auto());
    /// ```
    pub fn is_auto(self) -> bool {
        matches!(self, Self::Auto)
    }

    /// Returns the length if this is not auto
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::style::{LengthOrAuto, Length};
    ///
    /// let value = LengthOrAuto::px(100.0);
    /// assert_eq!(value.length(), Some(Length::px(100.0)));
    ///
    /// assert_eq!(LengthOrAuto::Auto.length(), None);
    /// ```
    pub fn length(self) -> Option<Length> {
        match self {
            Self::Length(length) => Some(length),
            Self::Auto => None,
        }
    }

    /// Converts to pixels if this is an absolute length, otherwise returns None
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::style::LengthOrAuto;
    ///
    /// assert_eq!(LengthOrAuto::px(100.0).to_px(), Some(100.0));
    /// assert_eq!(LengthOrAuto::Auto.to_px(), None);
    /// ```
    pub fn to_px(self) -> Option<f32> {
        match self {
            Self::Length(length) if length.unit.is_absolute() => Some(length.to_px()),
            _ => None,
        }
    }

    /// Resolves this value against a percentage base
    ///
    /// Returns None if this is Auto.
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::style::LengthOrAuto;
    ///
    /// let percent = LengthOrAuto::percent(50.0);
    /// assert_eq!(percent.resolve_against(200.0), Some(100.0));
    ///
    /// assert_eq!(LengthOrAuto::Auto.resolve_against(200.0), None);
    /// ```
    pub fn resolve_against(self, percentage_base: f32) -> Option<f32> {
        match self {
            Self::Length(length) => Some(length.resolve_against(percentage_base)),
            Self::Auto => None,
        }
    }

    /// Resolves this value, substituting a default for Auto
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::style::LengthOrAuto;
    ///
    /// assert_eq!(LengthOrAuto::px(100.0).resolve_or(50.0, 0.0), 100.0);
    /// assert_eq!(LengthOrAuto::Auto.resolve_or(50.0, 0.0), 50.0);
    /// ```
    pub fn resolve_or(self, default: f32, percentage_base: f32) -> f32 {
        match self {
            Self::Length(length) => length.resolve_against(percentage_base),
            Self::Auto => default,
        }
    }
}

impl From<Length> for LengthOrAuto {
    fn from(length: Length) -> Self {
        Self::Length(length)
    }
}

impl fmt::Display for LengthOrAuto {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Length(length) => write!(f, "{}", length),
            Self::Auto => write!(f, "auto"),
        }
    }
}
```

### Step 5: Write Comprehensive Tests (Estimated: 1-2 hours)

**Add at bottom of `src/style/values.rs`:**

```rust
#[cfg(test)]
mod tests {
    use super::*;

    // LengthUnit tests
    #[test]
    fn test_length_unit_classification() {
        assert!(LengthUnit::Px.is_absolute());
        assert!(LengthUnit::Pt.is_absolute());
        assert!(LengthUnit::In.is_absolute());

        assert!(LengthUnit::Em.is_font_relative());
        assert!(LengthUnit::Rem.is_font_relative());

        assert!(LengthUnit::Vw.is_viewport_relative());
        assert!(LengthUnit::Vh.is_viewport_relative());

        assert!(LengthUnit::Percent.is_percentage());
    }

    #[test]
    fn test_length_unit_as_str() {
        assert_eq!(LengthUnit::Px.as_str(), "px");
        assert_eq!(LengthUnit::Em.as_str(), "em");
        assert_eq!(LengthUnit::Percent.as_str(), "%");
    }

    // Length tests
    #[test]
    fn test_length_constructors() {
        let px = Length::px(100.0);
        assert_eq!(px.value, 100.0);
        assert_eq!(px.unit, LengthUnit::Px);

        let em = Length::em(2.0);
        assert_eq!(em.value, 2.0);
        assert_eq!(em.unit, LengthUnit::Em);
    }

    #[test]
    fn test_length_to_px() {
        assert_eq!(Length::px(100.0).to_px(), 100.0);
        assert_eq!(Length::inches(1.0).to_px(), 96.0);
        assert!((Length::pt(72.0).to_px() - 96.0).abs() < 0.1); // 72pt = 1in = 96px
    }

    #[test]
    fn test_length_unit_conversions() {
        // 1 inch = 96px
        assert_eq!(Length::inches(1.0).to_px(), 96.0);

        // 1 point = 1/72 inch
        let pt_to_px = Length::pt(72.0).to_px();
        assert!((pt_to_px - 96.0).abs() < 0.01);

        // 1 pica = 12 points = 16px
        assert_eq!(Length::pc(1.0).to_px(), 16.0);

        // 1 cm = 96/2.54 px
        let cm_to_px = Length::cm(2.54).to_px();
        assert!((cm_to_px - 96.0).abs() < 0.1);
    }

    #[test]
    fn test_length_percentage_resolution() {
        let percent = Length::percent(50.0);
        assert_eq!(percent.resolve_against(200.0), 100.0);
        assert_eq!(percent.resolve_against(100.0), 50.0);
    }

    #[test]
    fn test_length_font_size_resolution() {
        let em = Length::em(2.0);
        assert_eq!(em.resolve_with_font_size(16.0), 32.0);

        let rem = Length::rem(1.5);
        assert_eq!(rem.resolve_with_font_size(16.0), 24.0);
    }

    #[test]
    fn test_length_viewport_resolution() {
        let vw = Length::new(50.0, LengthUnit::Vw);
        assert_eq!(vw.resolve_with_viewport(800.0, 600.0), 400.0);

        let vh = Length::new(50.0, LengthUnit::Vh);
        assert_eq!(vh.resolve_with_viewport(800.0, 600.0), 300.0);

        let vmin = Length::new(10.0, LengthUnit::Vmin);
        assert_eq!(vmin.resolve_with_viewport(800.0, 600.0), 60.0); // 10% of 600

        let vmax = Length::new(10.0, LengthUnit::Vmax);
        assert_eq!(vmax.resolve_with_viewport(800.0, 600.0), 80.0); // 10% of 800
    }

    #[test]
    fn test_length_is_zero() {
        assert!(Length::px(0.0).is_zero());
        assert!(Length::em(0.0).is_zero());
        assert!(!Length::px(0.1).is_zero());
    }

    #[test]
    #[should_panic(expected = "Cannot convert em to px without context")]
    fn test_length_to_px_panics_on_relative_units() {
        Length::em(2.0).to_px();
    }

    // LengthOrAuto tests
    #[test]
    fn test_length_or_auto_constructors() {
        let auto = LengthOrAuto::Auto;
        assert!(auto.is_auto());

        let length = LengthOrAuto::px(100.0);
        assert!(!length.is_auto());
        assert_eq!(length.to_px(), Some(100.0));
    }

    #[test]
    fn test_length_or_auto_length() {
        let value = LengthOrAuto::px(100.0);
        assert_eq!(value.length(), Some(Length::px(100.0)));

        let auto = LengthOrAuto::Auto;
        assert_eq!(auto.length(), None);
    }

    #[test]
    fn test_length_or_auto_to_px() {
        assert_eq!(LengthOrAuto::px(100.0).to_px(), Some(100.0));
        assert_eq!(LengthOrAuto::Auto.to_px(), None);

        // Relative units return None (need context)
        let em = LengthOrAuto::Length(Length::em(2.0));
        assert_eq!(em.to_px(), None);
    }

    #[test]
    fn test_length_or_auto_resolve_against() {
        let percent = LengthOrAuto::percent(50.0);
        assert_eq!(percent.resolve_against(200.0), Some(100.0));

        let px = LengthOrAuto::px(75.0);
        assert_eq!(px.resolve_against(200.0), Some(75.0));

        let auto = LengthOrAuto::Auto;
        assert_eq!(auto.resolve_against(200.0), None);
    }

    #[test]
    fn test_length_or_auto_resolve_or() {
        assert_eq!(LengthOrAuto::px(100.0).resolve_or(50.0, 0.0), 100.0);
        assert_eq!(LengthOrAuto::Auto.resolve_or(50.0, 0.0), 50.0);

        let percent = LengthOrAuto::percent(25.0);
        assert_eq!(percent.resolve_or(0.0, 200.0), 50.0);
    }

    #[test]
    fn test_length_or_auto_from_length() {
        let length = Length::px(100.0);
        let auto_length: LengthOrAuto = length.into();
        assert_eq!(auto_length, LengthOrAuto::Length(length));
    }

    #[test]
    fn test_length_display() {
        assert_eq!(format!("{}", Length::px(100.0)), "100px");
        assert_eq!(format!("{}", Length::em(2.5)), "2.5em");
        assert_eq!(format!("{}", Length::percent(50.0)), "50%");
    }

    #[test]
    fn test_length_or_auto_display() {
        assert_eq!(format!("{}", LengthOrAuto::Auto), "auto");
        assert_eq!(format!("{}", LengthOrAuto::px(100.0)), "100px");
    }
}
```

### Step 6: Documentation and Verification (Estimated: 30min)

**Run all verification commands:**

```bash
# Run tests
cargo test style::values

# Check clippy
cargo clippy -- -D warnings

# Format code
cargo fmt

# Generate and view documentation
cargo doc --no-deps --open
```

## Testing Requirements

### Unit Tests

All tests are included inline. Run with:
```bash
cargo test style::values
```

Expected: ~25 tests passing, covering:
- Unit classification
- All convenience constructors
- Unit conversions
- Percentage resolution
- Font-size-relative resolution
- Viewport-relative resolution
- Auto handling
- Edge cases

### Integration Tests

These types will be tested more thoroughly when integrated with ComputedStyle (W2.T05) and layout algorithms (Wave 3-4).

## Output Artifacts

### Code Files

1. **`src/style/values.rs`**
   - LengthUnit, Length, LengthOrAuto implementations
   - All public APIs documented
   - Comprehensive test suite
   - ~400 lines total

2. **`src/style/mod.rs`**
   - Module organization
   - Re-exports

### Notes File

Create: **`docs/tasks/notes/W1.T03-notes.md`**

```markdown
# Task W1.T03 Output Notes

## Implementation Summary

Implemented three core CSS value types:
- **LengthUnit**: Enum of all CSS length unit types (px, em, %, etc.)
- **Length**: Value + unit pair with resolution methods
- **LengthOrAuto**: Discriminated union for properties that accept `auto`

These types bridge CSS syntax and layout algorithms, handling unit conversions and context-dependent resolution.

## API Contracts

### Public Types

```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum LengthUnit {
    Px, Pt, Pc, In, Cm, Mm,      // Absolute
    Em, Rem, Ex, Ch,              // Font-relative
    Vw, Vh, Vmin, Vmax,           // Viewport-relative
    Percent,                      // Percentage
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Length {
    pub value: f32,
    pub unit: LengthUnit,
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum LengthOrAuto {
    Length(Length),
    Auto,
}
```

### Key Methods

```rust
impl LengthUnit {
    pub fn is_absolute(self) -> bool;
    pub fn is_font_relative(self) -> bool;
    pub fn is_viewport_relative(self) -> bool;
}

impl Length {
    // Constructors
    pub const fn px(value: f32) -> Self;
    pub const fn em(value: f32) -> Self;
    pub const fn percent(value: f32) -> Self;
    // ... constructors for all units

    // Conversion/resolution
    pub fn to_px(self) -> f32;  // Absolute units only
    pub fn resolve_against(self, percentage_base: f32) -> f32;
    pub fn resolve_with_font_size(self, font_size_px: f32) -> f32;
    pub fn resolve_with_viewport(self, vw: f32, vh: f32) -> f32;
}

impl LengthOrAuto {
    pub fn is_auto(self) -> bool;
    pub fn length(self) -> Option<Length>;
    pub fn to_px(self) -> Option<f32>;
    pub fn resolve_against(self, percentage_base: f32) -> Option<f32>;
    pub fn resolve_or(self, default: f32, percentage_base: f32) -> f32;
}
```

## Decisions Made

### Decision 1: Use f32 for Values

**Choice:** All length values are f32, not f64
**Rationale:**
- Consistent with geometry types (W1.T01)
- Sufficient precision for CSS layout
- Better performance and memory usage
**Impact:** All downstream code should use f32

### Decision 2: Separate resolve_* Methods

**Choice:** Different methods for different resolution contexts
**Rationale:**
- Type safety: Can't accidentally resolve em units against percentage base
- Clear intent: Method name indicates what context is needed
- Compile-time errors: Catches mistakes early

**Alternatives Considered:**
- Single resolve() method taking all context → rejected as error-prone
- Runtime context enum → rejected as less type-safe

### Decision 3: Panic on Invalid Conversions

**Choice:** Methods like `to_px()` panic on relative units
**Rationale:**
- Programming error to call without context
- Should be caught in development, not production
- Clearer than returning Result for obvious misuse

**Impact:** Callers must check unit type or use appropriate resolve method

### Decision 4: Make LengthOrAuto an Enum, Not Option

**Choice:** Explicit enum, not `Option<Length>`
**Rationale:**
- More semantically clear
- Auto is not "absence of length", it's a distinct value
- Better pattern matching ergonomics
- Follows CSS semantics

## Spec Interpretations

### CSS Pixel Definition

**Spec says** (CSS Values Level 3): "The reference pixel is the visual angle of one pixel on a device with a pixel density of 96dpi"

**Interpretation**: 1px = 1/96 inch, 1in = 96px exactly

**Implementation**: Used exact conversion factors from spec

### Unit Conversions

All conversions use CSS 2.1 defined ratios:
- 1in = 2.54cm
- 1in = 96px
- 1in = 72pt
- 1pc = 12pt

## Discoveries & Gotchas

### Discovery 1: Viewport Units Need Context

**What:** vmin/vmax depend on viewport dimensions
**Why it matters:** Cannot be resolved without viewport size
**Recommendation:** Layout algorithms must pass viewport size through constraints

### Gotcha 1: Percentage Heights Are Contextual

**Problem:** Percentage could be relative to containing block height OR font size (for line-height)
**Solution:** Context must specify what percentage is relative to
**Warning:** W2.T05 (ComputedStyle) must document which properties use which base

### Gotcha 2: Zero Lengths Have Units

**Problem:** CSS `0` has no unit, but we need to store one
**Solution:** Use `Length::px(0.0)` as canonical zero
**Impact:** All zero lengths convert to px(0) during parsing

## Performance Notes

### Performance Characteristics
- All types are Copy (8-12 bytes each)
- Resolution methods are inline-friendly
- No allocations

### Optimization Opportunities
- **Caching**: Resolved values could be cached in ComputedStyle
- **SIMD**: Batch resolution of many lengths could use SIMD

## Recommendations for Downstream Tasks

### For Task W2.T05 (ComputedStyle):

- Use `LengthOrAuto` for width, height, margins
- Use `Length` for padding, border-width (never auto)
- Document percentage bases for each property
- Consider caching resolved values if profiles show benefit

### For Task W3.T04 (Block Layout):

- Use `resolve_against()` for width/height percentages
- Use `resolve_or()` with 0.0 for auto margins in BFC
- Remember: auto width has special algorithm, don't just use default

### For Task W3.T16 (Font Metrics):

- Use `resolve_with_font_size()` for em/rem/ex/ch units
- Font size cascade must happen before layout

### For Task W4.T12 (Inline Layout):

- Line-height percentages are relative to font size, not containing block!
- Use `resolve_with_font_size()` not `resolve_against()`

## Open Questions

### Question 1: Subpixel Rendering

**Question:** Should we round resolved values to integer pixels?
**Context:** Browsers use subpixel layout (fractional pixels)
**Suggested resolution:** Keep fractional values, let rasterizer handle rounding
**Assigned to:** W5.T07 (rasterization) should document approach

### Question 2: Negative Lengths

**Question:** Should we allow negative lengths?
**Context:** Most properties don't allow negative, but some (margins) do
**Suggested resolution:** Allow at type level, validate in ComputedStyle
**Assigned to:** W2.T05 should document which properties allow negative

## Test Coverage

### What's Tested
- ✅ All unit type classifications
- ✅ All convenience constructors
- ✅ Absolute unit conversions
- ✅ Percentage resolution
- ✅ Font-relative resolution
- ✅ Viewport-relative resolution
- ✅ Auto handling in all scenarios
- ✅ Display formatting

### What's Not Tested
- ❌ ex/ch unit resolution (needs actual font metrics - W3.T16)
- ❌ Integration with ComputedStyle (W2.T05)
- ❌ Performance of batch resolution (not needed until profiling)

### Test Statistics
- Unit tests: 25 tests
- All tests pass: ✅
- Coverage: All public methods tested

## Code Quality
- ✅ Clippy passes with no warnings
- ✅ Rustfmt applied
- ✅ All public APIs documented with examples
- ✅ Display trait implemented

## References Used
1. CSS Values and Units Level 3: https://www.w3.org/TR/css-values-3/
2. CSS 2.1 Section 4.3 (Values): https://www.w3.org/TR/CSS21/syndata.html#values
3. MDN CSS Values and Units: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Values_and_Units

---

**Task completed:** 2025-01-20
**Time taken:** 5 hours
**Tests passing:** 25/25
```

## Common Pitfalls to Avoid

### Pitfall 1: Using Wrong Resolution Method

**Wrong:** Calling `to_px()` on em units
**Right:** Call `resolve_with_font_size()` for font-relative units

### Pitfall 2: Forgetting Percentage Bases Differ

**Wrong:** Using same base for all percentage resolutions
**Right:** Width percentages use containing block width, line-height percentages use font size

### Pitfall 3: Treating Auto as Zero

**Wrong:** `if auto then 0 else value`
**Right:** Auto has special algorithms per property (see W3.T04 for width computation)

### Pitfall 4: Rounding Too Early

**Wrong:** Converting to int pixels immediately
**Right:** Keep f32 precision throughout layout, round only when rasterizing

## Verification Checklist

- [ ] All objectives met
- [ ] All success criteria satisfied
- [ ] Code compiles
- [ ] Tests pass: `cargo test style::values`
- [ ] Clippy clean: `cargo clippy -- -D warnings`
- [ ] Formatted: `cargo fmt --check`
- [ ] All public APIs documented
- [ ] Notes file complete
- [ ] Module structure correct

## Time Tracking

- **Module setup:** 30min
- **LengthUnit enum:** 1hr
- **Length struct:** 2hrs
- **LengthOrAuto enum:** 1hr
- **Testing:** 1-2hrs
- **Documentation:** 30min
- **Total:** 4-6 hours

## Getting Help

If stuck:

1. **CSS Values spec**: https://www.w3.org/TR/css-values-3/
2. **MDN CSS Units**: Comprehensive examples
3. **Browser DevTools**: Inspect computed values to see how browsers handle units
4. **Servo's style crate**: `components/style/values/` for reference implementation

Remember: These types are the bridge between CSS and layout. Get the API right now to avoid refactoring 50 files later!
