---
task_id: "W1.T05"
title: "Implement Display Enum"
wave: 1
estimated_hours: 3-4
depends_on: []
inputs: []
outputs:
  - "src/style/display.rs"
  - "outputs/notes/W1.T05-notes.md"
skills_required:
  - "Rust fundamentals"
  - "CSS display property"
  - "Testing"
context_files:
  - "docs/plan/01-type-system.md"
  - "docs/tasks/TASK_TEMPLATE.md"
verification:
  - "cargo test display"
  - "cargo clippy -- -D warnings"
  - "cargo fmt --check"
---

# Implement Display Enum

## Context

The `display` property is one of the most important CSS properties. It determines how an element participates in layout - whether it generates a block box, inline box, flex container, grid container, table, or doesn't generate a box at all. Understanding and correctly implementing the display property is fundamental to any CSS layout engine.

In FastRender V2, we're rebuilding from scratch with proper CSS Display Module Level 3 semantics. The Display enum is a Wave 1 foundation task with **no dependencies** and must be completed before box generation and layout can proceed.

### Background

**CSS Display Module Level 3:**

The modern `display` property has two parts:
- **Outer display type**: How the element participates in its parent's formatting context (block vs inline)
- **Inner display type**: What formatting context the element establishes for its children (flow, flex, grid, table)

For example:
- `display: block` → outer: block, inner: flow
- `display: inline-block` → outer: inline, inner: flow-root
- `display: flex` → outer: block, inner: flex
- `display: inline-flex` → outer: inline, inner: flex

**Common display values:**
- **none**: Element generates no boxes
- **block**: Block-level box, establishes block formatting context
- **inline**: Inline-level box
- **inline-block**: Inline-level box that establishes block formatting context
- **flex**: Block-level flex container
- **inline-flex**: Inline-level flex container
- **grid**: Block-level grid container
- **inline-grid**: Inline-level grid container
- **table** and related: Table layout boxes

### Why This Matters

Without the Display enum, we cannot:
- Parse the display property from CSS
- Determine what type of box to generate
- Know which layout algorithm to use
- Understand element participation in layout

Box generation (Wave 2) completely depends on this type. Get it wrong and the entire layout system breaks.

## Prerequisites

### Required Knowledge
- **Rust basics**: Enums, pattern matching, traits
- **CSS display property**: Understanding all display values
- **CSS Display Module**: Outer vs inner display types
- **Formatting contexts**: BFC, IFC, flex, grid concepts

### Required Reading
1. **CSS Display Module Level 3**: https://www.w3.org/TR/css-display-3/
   - Section 2: Box Layout Modes (outer and inner display)
   - Section 3: Display Value Syntax
2. **MDN display property**: https://developer.mozilla.org/en-US/docs/Web/CSS/display
3. **Understanding Block Formatting Contexts**: https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Block_formatting_context

## Inputs

### From Dependencies

**None** - This is a Wave 1 task with no dependencies.

### Existing Code

You should check:
- `src/style/` directory - Should exist after W1.T04
- `src/style/mod.rs` - Will need to add `pub mod display;`
- `src/lib.rs` - May need updates

## Objectives

### Primary Goals

1. **Implement Display enum**: Cover all CSS display values
2. **Implement helper methods**: `is_block_level()`, `is_inline_level()`, etc.
3. **Implement parsing**: Parse from CSS display strings
4. **Implement inner/outer display**: Methods to query display semantics
5. **Add comprehensive tests**: Cover all display values and edge cases

### Success Criteria

- [ ] Display enum includes all major display values
- [ ] Parse from CSS strings: "block", "inline-flex", "none", etc.
- [ ] Helper methods: `is_block_level()`, `is_inline_level()`, `is_none()`
- [ ] Methods: `outer_display()`, `inner_display()` based on CSS Display Level 3
- [ ] Methods: `establishes_formatting_context()`, `formatting_context_type()`
- [ ] All tests pass: `cargo test display`
- [ ] Clippy passes with no warnings
- [ ] Rustfmt applied
- [ ] All public APIs have rustdoc comments with examples
- [ ] Notes file created with all sections filled

## Implementation Guide

### Step 1: Create the Display Module (Estimated: 10min)

**What to do:**
1. Create file: `src/style/display.rs`
2. Add module declaration to `src/style/mod.rs`
3. Set up module structure with documentation

**Code:**

Update `src/style/mod.rs`:

```rust
//! Style system types

pub mod color;
pub mod display;

// Re-export commonly used types
pub use color::{Color, Rgba, Hsla};
pub use display::Display;
```

Create `src/style/display.rs`:

```rust
//! CSS Display property
//!
//! This module implements the CSS `display` property according to
//! CSS Display Module Level 3.
//!
//! The display property defines:
//! - Whether an element generates boxes at all
//! - What type of box is generated (block, inline, etc.)
//! - What formatting context the element establishes
//!
//! # Display Types
//!
//! Modern CSS has two-part display values:
//! - **Outer display**: How element participates in parent's FC (block/inline)
//! - **Inner display**: What FC element establishes for children (flow/flex/grid/table)
//!
//! # Examples
//!
//! ```
//! use fastrender::style::Display;
//!
//! let display = Display::parse("flex").unwrap();
//! assert!(display.is_block_level());
//! assert!(display.establishes_formatting_context());
//! ```

use std::fmt;

// Types will be implemented in subsequent steps
```

### Step 2: Implement Display Enum (Estimated: 1 hour)

**What to do:**
1. Define `Display` enum with all major display values
2. Include both legacy (block, inline) and modern (flex, grid) values
3. Add Debug, Clone, Copy, PartialEq derives

**Implementation details:**

The Display enum represents all valid CSS display values. We use a simple enum rather than the two-part outer/inner structure because it's more ergonomic in Rust.

**Example code:**

```rust
/// CSS display property value
///
/// Represents the display type of an element, controlling how it
/// participates in layout and what formatting context it establishes.
///
/// # Examples
///
/// ```
/// use fastrender::style::Display;
///
/// let block = Display::Block;
/// assert!(block.is_block_level());
///
/// let flex = Display::Flex;
/// assert!(flex.establishes_formatting_context());
/// ```
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum Display {
    /// Element generates no boxes (removed from layout tree)
    ///
    /// Corresponds to `display: none`
    None,

    /// Block-level box, establishes block formatting context
    ///
    /// Corresponds to `display: block`
    /// - Outer: block-level
    /// - Inner: flow (block formatting context)
    Block,

    /// Inline-level box
    ///
    /// Corresponds to `display: inline`
    /// - Outer: inline-level
    /// - Inner: flow (participates in parent's inline formatting context)
    Inline,

    /// Inline-level box that establishes block formatting context
    ///
    /// Corresponds to `display: inline-block`
    /// - Outer: inline-level
    /// - Inner: flow-root (establishes new block formatting context)
    InlineBlock,

    /// Block-level flex container
    ///
    /// Corresponds to `display: flex`
    /// - Outer: block-level
    /// - Inner: flex
    Flex,

    /// Inline-level flex container
    ///
    /// Corresponds to `display: inline-flex`
    /// - Outer: inline-level
    /// - Inner: flex
    InlineFlex,

    /// Block-level grid container
    ///
    /// Corresponds to `display: grid`
    /// - Outer: block-level
    /// - Inner: grid
    Grid,

    /// Inline-level grid container
    ///
    /// Corresponds to `display: inline-grid`
    /// - Outer: inline-level
    /// - Inner: grid
    InlineGrid,

    /// Block-level table wrapper box
    ///
    /// Corresponds to `display: table`
    /// - Outer: block-level
    /// - Inner: table
    Table,

    /// Inline-level table wrapper box
    ///
    /// Corresponds to `display: inline-table`
    /// - Outer: inline-level
    /// - Inner: table
    InlineTable,

    /// Table row box
    ///
    /// Corresponds to `display: table-row`
    TableRow,

    /// Table cell box
    ///
    /// Corresponds to `display: table-cell`
    TableCell,

    /// Table row group box
    ///
    /// Corresponds to `display: table-row-group`
    TableRowGroup,

    /// Table header group box
    ///
    /// Corresponds to `display: table-header-group`
    TableHeaderGroup,

    /// Table footer group box
    ///
    /// Corresponds to `display: table-footer-group`
    TableFooterGroup,

    /// Table column box
    ///
    /// Corresponds to `display: table-column`
    TableColumn,

    /// Table column group box
    ///
    /// Corresponds to `display: table-column-group`
    TableColumnGroup,

    /// Table caption box
    ///
    /// Corresponds to `display: table-caption`
    TableCaption,

    /// List item box (block with marker)
    ///
    /// Corresponds to `display: list-item`
    /// - Outer: block-level
    /// - Inner: flow
    /// - Also generates marker box
    ListItem,

    /// Element's children are laid out as flex items, but element itself
    /// uses flow layout for text
    ///
    /// Corresponds to `display: flow-root`
    /// - Outer: block-level
    /// - Inner: flow-root (establishes new BFC)
    FlowRoot,

    /// Contents of element are promoted to parent
    ///
    /// Corresponds to `display: contents`
    /// Element generates no box, but children are laid out as if they were
    /// children of the element's parent
    Contents,
}
```

### Step 3: Implement Helper Methods (Estimated: 45min)

**What to do:**
1. Add methods to query display properties
2. Implement is_block_level(), is_inline_level(), is_none()
3. Add outer_display() and inner_display() methods

**Example code:**

```rust
impl Display {
    /// Returns true if this display value means the element generates no boxes
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::style::Display;
    ///
    /// assert!(Display::None.is_none());
    /// assert!(!Display::Block.is_none());
    /// ```
    pub fn is_none(self) -> bool {
        matches!(self, Display::None)
    }

    /// Returns true if the element generates block-level boxes
    ///
    /// Block-level boxes participate in a block formatting context.
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::style::Display;
    ///
    /// assert!(Display::Block.is_block_level());
    /// assert!(Display::Flex.is_block_level());
    /// assert!(Display::Grid.is_block_level());
    /// assert!(Display::Table.is_block_level());
    /// assert!(!Display::Inline.is_block_level());
    /// assert!(!Display::InlineFlex.is_block_level());
    /// ```
    pub fn is_block_level(self) -> bool {
        matches!(
            self,
            Display::Block
                | Display::Flex
                | Display::Grid
                | Display::Table
                | Display::ListItem
                | Display::FlowRoot
        )
    }

    /// Returns true if the element generates inline-level boxes
    ///
    /// Inline-level boxes participate in an inline formatting context.
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::style::Display;
    ///
    /// assert!(Display::Inline.is_inline_level());
    /// assert!(Display::InlineBlock.is_inline_level());
    /// assert!(Display::InlineFlex.is_inline_level());
    /// assert!(Display::InlineGrid.is_inline_level());
    /// assert!(!Display::Block.is_inline_level());
    /// ```
    pub fn is_inline_level(self) -> bool {
        matches!(
            self,
            Display::Inline
                | Display::InlineBlock
                | Display::InlineFlex
                | Display::InlineGrid
                | Display::InlineTable
        )
    }

    /// Returns true if the element is a table-internal box
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::style::Display;
    ///
    /// assert!(Display::TableRow.is_table_internal());
    /// assert!(Display::TableCell.is_table_internal());
    /// assert!(!Display::Table.is_table_internal());
    /// ```
    pub fn is_table_internal(self) -> bool {
        matches!(
            self,
            Display::TableRow
                | Display::TableCell
                | Display::TableRowGroup
                | Display::TableHeaderGroup
                | Display::TableFooterGroup
                | Display::TableColumn
                | Display::TableColumnGroup
                | Display::TableCaption
        )
    }

    /// Returns true if this display value establishes a new formatting context
    ///
    /// Elements that establish formatting contexts contain their floats,
    /// margins don't collapse through them, etc.
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::style::Display;
    ///
    /// assert!(Display::Flex.establishes_formatting_context());
    /// assert!(Display::Grid.establishes_formatting_context());
    /// assert!(Display::InlineBlock.establishes_formatting_context());
    /// assert!(Display::FlowRoot.establishes_formatting_context());
    /// assert!(!Display::Inline.establishes_formatting_context());
    /// ```
    pub fn establishes_formatting_context(self) -> bool {
        matches!(
            self,
            Display::InlineBlock
                | Display::Flex
                | Display::InlineFlex
                | Display::Grid
                | Display::InlineGrid
                | Display::Table
                | Display::InlineTable
                | Display::FlowRoot
        )
    }

    /// Returns the type of formatting context this element establishes
    ///
    /// Returns None if the element doesn't establish a formatting context.
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::style::{Display, FormattingContextType};
    ///
    /// assert_eq!(
    ///     Display::Flex.formatting_context_type(),
    ///     Some(FormattingContextType::Flex)
    /// );
    /// assert_eq!(
    ///     Display::Grid.formatting_context_type(),
    ///     Some(FormattingContextType::Grid)
    /// );
    /// assert_eq!(Display::Inline.formatting_context_type(), None);
    /// ```
    pub fn formatting_context_type(self) -> Option<FormattingContextType> {
        match self {
            Display::Block => Some(FormattingContextType::Block),
            Display::InlineBlock => Some(FormattingContextType::Block),
            Display::FlowRoot => Some(FormattingContextType::Block),
            Display::Flex | Display::InlineFlex => Some(FormattingContextType::Flex),
            Display::Grid | Display::InlineGrid => Some(FormattingContextType::Grid),
            Display::Table | Display::InlineTable => Some(FormattingContextType::Table),
            _ => None,
        }
    }

    /// Returns the outer display type
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::style::{Display, OuterDisplay};
    ///
    /// assert_eq!(Display::Block.outer_display(), OuterDisplay::Block);
    /// assert_eq!(Display::Inline.outer_display(), OuterDisplay::Inline);
    /// assert_eq!(Display::InlineFlex.outer_display(), OuterDisplay::Inline);
    /// ```
    pub fn outer_display(self) -> OuterDisplay {
        match self {
            Display::None => OuterDisplay::None,
            Display::Inline | Display::InlineBlock | Display::InlineFlex
            | Display::InlineGrid | Display::InlineTable => OuterDisplay::Inline,
            _ => OuterDisplay::Block,
        }
    }

    /// Returns the inner display type
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::style::{Display, InnerDisplay};
    ///
    /// assert_eq!(Display::Block.inner_display(), InnerDisplay::Flow);
    /// assert_eq!(Display::Flex.inner_display(), InnerDisplay::Flex);
    /// assert_eq!(Display::Grid.inner_display(), InnerDisplay::Grid);
    /// ```
    pub fn inner_display(self) -> InnerDisplay {
        match self {
            Display::None => InnerDisplay::None,
            Display::Flex | Display::InlineFlex => InnerDisplay::Flex,
            Display::Grid | Display::InlineGrid => InnerDisplay::Grid,
            Display::Table | Display::InlineTable => InnerDisplay::Table,
            Display::FlowRoot | Display::InlineBlock => InnerDisplay::FlowRoot,
            _ => InnerDisplay::Flow,
        }
    }
}

/// Outer display type (how element participates in parent's formatting context)
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum OuterDisplay {
    /// No box generated
    None,
    /// Block-level box
    Block,
    /// Inline-level box
    Inline,
}

/// Inner display type (what formatting context element establishes)
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum InnerDisplay {
    /// No formatting context
    None,
    /// Normal flow (block formatting context)
    Flow,
    /// Establishes new block formatting context
    FlowRoot,
    /// Flex formatting context
    Flex,
    /// Grid formatting context
    Grid,
    /// Table formatting context
    Table,
}

/// Formatting context types
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum FormattingContextType {
    /// Block formatting context
    Block,
    /// Flex formatting context
    Flex,
    /// Grid formatting context
    Grid,
    /// Table formatting context
    Table,
}
```

### Step 4: Implement Parsing (Estimated: 45min)

**What to do:**
1. Implement parse() method to parse CSS display strings
2. Support all standard display values
3. Handle case-insensitivity

**Example code:**

```rust
impl Display {
    /// Parse a display value from a CSS string
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::style::Display;
    ///
    /// assert_eq!(Display::parse("block").unwrap(), Display::Block);
    /// assert_eq!(Display::parse("flex").unwrap(), Display::Flex);
    /// assert_eq!(Display::parse("inline-block").unwrap(), Display::InlineBlock);
    /// assert!(Display::parse("invalid").is_err());
    /// ```
    pub fn parse(s: &str) -> Result<Self, DisplayParseError> {
        let s = s.trim().to_lowercase();
        match s.as_str() {
            "none" => Ok(Display::None),
            "block" => Ok(Display::Block),
            "inline" => Ok(Display::Inline),
            "inline-block" => Ok(Display::InlineBlock),
            "flex" => Ok(Display::Flex),
            "inline-flex" => Ok(Display::InlineFlex),
            "grid" => Ok(Display::Grid),
            "inline-grid" => Ok(Display::InlineGrid),
            "table" => Ok(Display::Table),
            "inline-table" => Ok(Display::InlineTable),
            "table-row" => Ok(Display::TableRow),
            "table-cell" => Ok(Display::TableCell),
            "table-row-group" => Ok(Display::TableRowGroup),
            "table-header-group" => Ok(Display::TableHeaderGroup),
            "table-footer-group" => Ok(Display::TableFooterGroup),
            "table-column" => Ok(Display::TableColumn),
            "table-column-group" => Ok(Display::TableColumnGroup),
            "table-caption" => Ok(Display::TableCaption),
            "list-item" => Ok(Display::ListItem),
            "flow-root" => Ok(Display::FlowRoot),
            "contents" => Ok(Display::Contents),
            _ => Err(DisplayParseError::InvalidValue(s.to_string())),
        }
    }
}

/// Error when parsing display value
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum DisplayParseError {
    /// Invalid display value
    InvalidValue(String),
}

impl fmt::Display for DisplayParseError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            DisplayParseError::InvalidValue(s) => {
                write!(f, "Invalid display value: '{}'", s)
            }
        }
    }
}

impl std::error::Error for DisplayParseError {}
```

### Step 5: Implement Display Trait (Estimated: 15min)

**What to do:**
1. Implement fmt::Display for Display enum
2. Convert back to CSS string representation

**Example code:**

```rust
impl fmt::Display for Display {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Display::None => write!(f, "none"),
            Display::Block => write!(f, "block"),
            Display::Inline => write!(f, "inline"),
            Display::InlineBlock => write!(f, "inline-block"),
            Display::Flex => write!(f, "flex"),
            Display::InlineFlex => write!(f, "inline-flex"),
            Display::Grid => write!(f, "grid"),
            Display::InlineGrid => write!(f, "inline-grid"),
            Display::Table => write!(f, "table"),
            Display::InlineTable => write!(f, "inline-table"),
            Display::TableRow => write!(f, "table-row"),
            Display::TableCell => write!(f, "table-cell"),
            Display::TableRowGroup => write!(f, "table-row-group"),
            Display::TableHeaderGroup => write!(f, "table-header-group"),
            Display::TableFooterGroup => write!(f, "table-footer-group"),
            Display::TableColumn => write!(f, "table-column"),
            Display::TableColumnGroup => write!(f, "table-column-group"),
            Display::TableCaption => write!(f, "table-caption"),
            Display::ListItem => write!(f, "list-item"),
            Display::FlowRoot => write!(f, "flow-root"),
            Display::Contents => write!(f, "contents"),
        }
    }
}
```

### Step 6: Write Comprehensive Tests (Estimated: 1 hour)

**Required tests:**

Add these tests at the bottom of `src/style/display.rs`:

```rust
#[cfg(test)]
mod tests {
    use super::*;

    // Basic parsing tests
    #[test]
    fn test_parse_block() {
        assert_eq!(Display::parse("block").unwrap(), Display::Block);
    }

    #[test]
    fn test_parse_inline() {
        assert_eq!(Display::parse("inline").unwrap(), Display::Inline);
    }

    #[test]
    fn test_parse_none() {
        assert_eq!(Display::parse("none").unwrap(), Display::None);
    }

    #[test]
    fn test_parse_flex() {
        assert_eq!(Display::parse("flex").unwrap(), Display::Flex);
    }

    #[test]
    fn test_parse_inline_flex() {
        assert_eq!(Display::parse("inline-flex").unwrap(), Display::InlineFlex);
    }

    #[test]
    fn test_parse_grid() {
        assert_eq!(Display::parse("grid").unwrap(), Display::Grid);
    }

    #[test]
    fn test_parse_table() {
        assert_eq!(Display::parse("table").unwrap(), Display::Table);
    }

    #[test]
    fn test_parse_table_cell() {
        assert_eq!(Display::parse("table-cell").unwrap(), Display::TableCell);
    }

    #[test]
    fn test_parse_case_insensitive() {
        assert_eq!(Display::parse("BLOCK").unwrap(), Display::Block);
        assert_eq!(Display::parse("Inline-Block").unwrap(), Display::InlineBlock);
    }

    #[test]
    fn test_parse_invalid() {
        assert!(Display::parse("invalid").is_err());
        assert!(Display::parse("").is_err());
    }

    // is_none tests
    #[test]
    fn test_is_none() {
        assert!(Display::None.is_none());
        assert!(!Display::Block.is_none());
        assert!(!Display::Inline.is_none());
    }

    // is_block_level tests
    #[test]
    fn test_is_block_level() {
        assert!(Display::Block.is_block_level());
        assert!(Display::Flex.is_block_level());
        assert!(Display::Grid.is_block_level());
        assert!(Display::Table.is_block_level());
        assert!(Display::ListItem.is_block_level());
        assert!(Display::FlowRoot.is_block_level());

        assert!(!Display::Inline.is_block_level());
        assert!(!Display::InlineBlock.is_block_level());
        assert!(!Display::InlineFlex.is_block_level());
        assert!(!Display::InlineGrid.is_block_level());
        assert!(!Display::None.is_block_level());
    }

    // is_inline_level tests
    #[test]
    fn test_is_inline_level() {
        assert!(Display::Inline.is_inline_level());
        assert!(Display::InlineBlock.is_inline_level());
        assert!(Display::InlineFlex.is_inline_level());
        assert!(Display::InlineGrid.is_inline_level());
        assert!(Display::InlineTable.is_inline_level());

        assert!(!Display::Block.is_inline_level());
        assert!(!Display::Flex.is_inline_level());
        assert!(!Display::Grid.is_inline_level());
        assert!(!Display::None.is_inline_level());
    }

    // is_table_internal tests
    #[test]
    fn test_is_table_internal() {
        assert!(Display::TableRow.is_table_internal());
        assert!(Display::TableCell.is_table_internal());
        assert!(Display::TableRowGroup.is_table_internal());
        assert!(Display::TableHeaderGroup.is_table_internal());
        assert!(Display::TableFooterGroup.is_table_internal());
        assert!(Display::TableColumn.is_table_internal());
        assert!(Display::TableColumnGroup.is_table_internal());
        assert!(Display::TableCaption.is_table_internal());

        assert!(!Display::Table.is_table_internal());
        assert!(!Display::Block.is_table_internal());
    }

    // establishes_formatting_context tests
    #[test]
    fn test_establishes_formatting_context() {
        assert!(Display::Flex.establishes_formatting_context());
        assert!(Display::InlineFlex.establishes_formatting_context());
        assert!(Display::Grid.establishes_formatting_context());
        assert!(Display::InlineGrid.establishes_formatting_context());
        assert!(Display::InlineBlock.establishes_formatting_context());
        assert!(Display::Table.establishes_formatting_context());
        assert!(Display::FlowRoot.establishes_formatting_context());

        assert!(!Display::Block.establishes_formatting_context());
        assert!(!Display::Inline.establishes_formatting_context());
    }

    // formatting_context_type tests
    #[test]
    fn test_formatting_context_type() {
        assert_eq!(
            Display::Block.formatting_context_type(),
            Some(FormattingContextType::Block)
        );
        assert_eq!(
            Display::Flex.formatting_context_type(),
            Some(FormattingContextType::Flex)
        );
        assert_eq!(
            Display::InlineFlex.formatting_context_type(),
            Some(FormattingContextType::Flex)
        );
        assert_eq!(
            Display::Grid.formatting_context_type(),
            Some(FormattingContextType::Grid)
        );
        assert_eq!(
            Display::Table.formatting_context_type(),
            Some(FormattingContextType::Table)
        );
        assert_eq!(Display::Inline.formatting_context_type(), None);
    }

    // outer_display tests
    #[test]
    fn test_outer_display() {
        assert_eq!(Display::Block.outer_display(), OuterDisplay::Block);
        assert_eq!(Display::Flex.outer_display(), OuterDisplay::Block);
        assert_eq!(Display::Grid.outer_display(), OuterDisplay::Block);

        assert_eq!(Display::Inline.outer_display(), OuterDisplay::Inline);
        assert_eq!(Display::InlineBlock.outer_display(), OuterDisplay::Inline);
        assert_eq!(Display::InlineFlex.outer_display(), OuterDisplay::Inline);
        assert_eq!(Display::InlineGrid.outer_display(), OuterDisplay::Inline);

        assert_eq!(Display::None.outer_display(), OuterDisplay::None);
    }

    // inner_display tests
    #[test]
    fn test_inner_display() {
        assert_eq!(Display::Block.inner_display(), InnerDisplay::Flow);
        assert_eq!(Display::Inline.inner_display(), InnerDisplay::Flow);

        assert_eq!(Display::Flex.inner_display(), InnerDisplay::Flex);
        assert_eq!(Display::InlineFlex.inner_display(), InnerDisplay::Flex);

        assert_eq!(Display::Grid.inner_display(), InnerDisplay::Grid);
        assert_eq!(Display::InlineGrid.inner_display(), InnerDisplay::Grid);

        assert_eq!(Display::Table.inner_display(), InnerDisplay::Table);

        assert_eq!(Display::FlowRoot.inner_display(), InnerDisplay::FlowRoot);
        assert_eq!(Display::InlineBlock.inner_display(), InnerDisplay::FlowRoot);

        assert_eq!(Display::None.inner_display(), InnerDisplay::None);
    }

    // Display trait tests
    #[test]
    fn test_display_formatting() {
        assert_eq!(format!("{}", Display::Block), "block");
        assert_eq!(format!("{}", Display::InlineFlex), "inline-flex");
        assert_eq!(format!("{}", Display::TableCell), "table-cell");
    }

    // Round-trip test
    #[test]
    fn test_parse_display_roundtrip() {
        let values = vec![
            Display::None,
            Display::Block,
            Display::Inline,
            Display::InlineBlock,
            Display::Flex,
            Display::InlineFlex,
            Display::Grid,
            Display::InlineGrid,
            Display::Table,
            Display::TableCell,
        ];

        for display in values {
            let string = format!("{}", display);
            let parsed = Display::parse(&string).unwrap();
            assert_eq!(parsed, display);
        }
    }
}
```

### Step 7: Documentation and Final Polish (Estimated: 15min)

**What to do:**
1. Run `cargo test display` and ensure all tests pass
2. Run `cargo clippy -- -D warnings` and fix any warnings
3. Run `cargo fmt` to format code
4. Generate docs: `cargo doc --no-deps --open`
5. Verify all public APIs have examples in rustdoc

## Testing Requirements

### Unit Tests

All tests are inline in `src/style/display.rs` in the `#[cfg(test)]` module.

**Run tests:**
```bash
cargo test display
```

**Expected output:**
```
running 29 tests
test style::display::tests::test_parse_block ... ok
test style::display::tests::test_parse_inline ... ok
test style::display::tests::test_parse_none ... ok
test style::display::tests::test_parse_flex ... ok
test style::display::tests::test_parse_inline_flex ... ok
test style::display::tests::test_parse_grid ... ok
test style::display::tests::test_parse_table ... ok
test style::display::tests::test_parse_table_cell ... ok
test style::display::tests::test_parse_case_insensitive ... ok
test style::display::tests::test_parse_invalid ... ok
test style::display::tests::test_is_none ... ok
test style::display::tests::test_is_block_level ... ok
test style::display::tests::test_is_inline_level ... ok
test style::display::tests::test_is_table_internal ... ok
test style::display::tests::test_establishes_formatting_context ... ok
test style::display::tests::test_formatting_context_type ... ok
test style::display::tests::test_outer_display ... ok
test style::display::tests::test_inner_display ... ok
test style::display::tests::test_display_formatting ... ok
test style::display::tests::test_parse_display_roundtrip ... ok

test result: ok. 20 passed; 0 failed; 0 ignored; 0 measured
```

### Manual Verification

```bash
# Compile check
cargo build

# Clippy (no warnings)
cargo clippy -- -D warnings

# Format check
cargo fmt --check

# Documentation
cargo doc --no-deps --open
```

## Output Artifacts

### Code Files

1. **`src/style/display.rs`**
   - Complete implementation of Display enum
   - All helper methods
   - Parsing and formatting
   - Comprehensive test suite
   - Passes clippy with no warnings

### Notes File

Create: **`outputs/notes/W1.T05-notes.md`**

Template provided in the full task documentation.

## Common Pitfalls to Avoid

### Pitfall 1: Confusing Block Display with Block-Level

**Wrong:** Thinking only `display: block` is block-level
**Right:** `flex`, `grid`, `table`, `list-item`, `flow-root` are also block-level

Block-level refers to how the element participates in its parent's layout.

### Pitfall 2: Forgetting Inline Variants

**Wrong:** Only implementing `flex` and `grid`
**Right:** Also implement `inline-flex` and `inline-grid`

Many display values have inline variants.

### Pitfall 3: Incorrect Formatting Context Logic

**Wrong:** Thinking `display: block` establishes a new formatting context
**Right:** Only `inline-block`, `flow-root`, `flex`, `grid`, etc. establish new FC

Regular blocks participate in their parent's FC.

### Pitfall 4: Not Handling Case-Insensitivity

**Wrong:** Exact string matching "flex"
**Right:** Convert to lowercase before matching

CSS values are case-insensitive.

### Pitfall 5: Forgetting Table Display Types

**Wrong:** Only implementing common values
**Right:** Include all table-related display values

Tables need many special display values.

## Verification Checklist

Before marking task complete:

- [ ] All objectives met
- [ ] All success criteria satisfied
- [ ] Code compiles: `cargo build`
- [ ] Tests pass: `cargo test display`
- [ ] Clippy happy: `cargo clippy -- -D warnings`
- [ ] Formatted: `cargo fmt --check`
- [ ] All public APIs have rustdoc with examples
- [ ] Notes file complete with all sections
- [ ] Module exports correct (`src/style/mod.rs`)
- [ ] All display values parse correctly
- [ ] Helper methods work for all values

## Time Tracking

Estimated breakdown:
- **Setup:** 10min
- **Display enum:** 1hr
- **Helper methods:** 45min
- **Parsing:** 45min
- **Display trait:** 15min
- **Testing:** 1hr
- **Documentation review:** 15min
- **Total:** 3-4 hours

## Getting Help

If stuck:

1. **Review CSS specs**: CSS Display Module Level 3
2. **Check MDN**: https://developer.mozilla.org/en-US/docs/Web/CSS/display
3. **Understanding formatting contexts**: Research BFC, IFC concepts
4. **Look at browser implementations**: Chromium's display handling

Remember: The display property is fundamental to layout. Every layout algorithm depends on this!
