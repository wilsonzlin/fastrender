---
task_id: "W1.R03"
title: "Unicode Bidi & Line Breaking Research"
wave: 1
estimated_hours: 6-8
depends_on: []
inputs: []
outputs:
  - "docs/tasks/notes/W1.R03-notes.md"
  - "docs/research/unicode-text-algorithms.md"
skills_required:
  - "Reading Unicode Technical Reports"
  - "Understanding text processing"
  - "Algorithm analysis"
context_files:
  - "docs/text/line-breaking.md"
  - "docs/text/shaping.md"
  - "docs/architecture/foundation.md"
verification:
  - "Research notes document created"
  - "UAX #9 (Bidi) algorithm understood and documented"
  - "UAX #14 (Line Breaking) algorithm understood and documented"
---

# Unicode Bidi & Line Breaking Research

## Context

Text rendering in a modern rendering engine requires understanding **two critical Unicode algorithms**:

1. **Unicode Bidirectional Algorithm (UAX #9)**: Handling right-to-left text (Arabic, Hebrew) mixed with left-to-right text
2. **Unicode Line Breaking Algorithm (UAX #14)**: Finding correct break opportunities for wrapping text across lines

These are **complex, non-obvious algorithms** that took years of Unicode Consortium work to specify. We cannot implement text rendering correctly without deep understanding of both.

### Background

**Bidirectional Text (Bidi):**

Some languages (Arabic, Hebrew) are written right-to-left (RTL), but numbers and Latin text are still left-to-right (LTR). When mixed in a single paragraph, the Unicode Bidirectional Algorithm determines the correct visual order.

Example:
```
Logical order:  "Hello ברוך world"
Visual order:   "Hello ךורב world"
                       ← RTL
```

The Hebrew word is reversed and text flows RTL, but "Hello" and "world" remain LTR.

**Line Breaking:**

Different languages have different rules for where text can wrap:
- English: Break at spaces and some punctuation
- Chinese/Japanese: Can break between most characters
- Thai: Break at word boundaries (requires dictionary)
- URLs: Special break rules to avoid confusion

**From CSS Text Module Level 3:**
> "Line breaking is the process of breaking inline-level content into line boxes. It encompasses line breaking as described in Unicode Standard Annex #14."

### Why This Matters

Without bidi support:
- RTL languages render backwards (unusable)
- Mixed LTR/RTL text is garbled
- Cannot support international users

Without proper line breaking:
- Text breaks at wrong places (mid-word in Chinese, wrong punctuation in English)
- URLs break confusingly
- No hyphenation support
- Cannot respect CSS properties (word-break, overflow-wrap)

**This is BLOCKING for:**
- W4.T01 (Bidi Analyzer)
- W4.T08 (Break Opportunity Finder)
- W4.T12 (Inline Layout)

## Prerequisites

### Required Knowledge

- **Unicode basics**: Code points, UTF-8 encoding, normalization
- **Text directionality**: LTR vs RTL concepts
- **CSS text properties**: direction, unicode-bidi, word-break, overflow-wrap
- **Algorithm complexity**: Understanding O(n) algorithms with state machines

### Required Reading

1. **Unicode Bidirectional Algorithm (UAX #9)** (REQUIRED):
   - https://www.unicode.org/reports/tr9/
   - Sections 2-3: Terminology and high-level algorithm
   - Section 4: Detailed algorithm
   - Examples in Section 7

2. **Unicode Line Breaking Algorithm (UAX #14)** (REQUIRED):
   - https://www.unicode.org/reports/tr14/
   - Section 5: Line breaking classes
   - Section 6: Line breaking algorithm
   - Section 7: Pair table rules

3. **CSS Text Module Level 3**:
   - https://www.w3.org/TR/css-text-3/
   - Section 4: White space and wrapping
   - Section 5: Line breaking and word boundaries

4. **docs/text/shaping.md**: Context on text processing pipeline
5. **docs/text/line-breaking.md**: Implementation strategy

## Inputs

### From Dependencies

**None** - This is a Wave 1 research task with no dependencies.

### Existing Resources

- UAX #9 online: https://www.unicode.org/reports/tr9/
- UAX #14 online: https://www.unicode.org/reports/tr14/
- unicode-bidi Rust crate: https://crates.io/crates/unicode-bidi
- unicode-linebreak Rust crate: https://crates.io/crates/unicode-linebreak

## Objectives

### Primary Goals

1. **Understand Unicode Bidirectional Algorithm**: How to reorder mixed LTR/RTL text
2. **Understand Line Breaking Algorithm**: How to find valid break opportunities
3. **Document both algorithms in pseudocode**: Ready for implementation
4. **Identify Rust crates to use**: unicode-bidi and unicode-linebreak
5. **Extract CSS property interactions**: How CSS affects these algorithms
6. **Document edge cases**: Nested directions, combining marks, etc.

### Success Criteria

- [ ] UAX #9 Bidi algorithm understood and documented
- [ ] UAX #14 Line breaking algorithm understood and documented
- [ ] Both algorithms in pseudocode (simplified, not full spec)
- [ ] At least 15 spec quotes captured
- [ ] Concrete examples of complex bidi text
- [ ] Line breaking class examples for multiple languages
- [ ] Rust crate APIs documented
- [ ] Notes file created for W4.T01 and W4.T08

## Research Guide

### Phase 1: Bidi Algorithm Overview (Estimated: 2-3 hours)

**Read:**
- UAX #9, Sections 1-3: Introduction and Overview
- UAX #9, Section 4.1-4.3: Bidi Classes, Algorithm Structure

**Goal:** Understand high-level how the algorithm works.

**Key Concepts to Extract:**

1. **Bidi Classes**: Every character has a class (L, R, EN, AN, etc.)
   - L = Strong Left-to-Right (Latin letters)
   - R = Strong Right-to-Left (Hebrew, Arabic letters)
   - EN = European Number (0-9)
   - AN = Arabic Number (٠-٩)
   - WS = Whitespace
   - (Many more - document all classes)

2. **Algorithm Structure**: Three phases
   - Phase 1: Paragraph level determination
   - Phase 2: Explicit levels and directions
   - Phase 3: Resolving weak and neutral types

3. **Embedding Levels**: Nesting depth of directional runs

**Document in `docs/research/unicode-text-algorithms.md`:**

```markdown
## Unicode Bidirectional Algorithm (UAX #9)

### Purpose

Determine visual ordering of mixed LTR/RTL text.

### Bidi Character Classes

| Class | Name | Examples | Meaning |
|-------|------|----------|---------|
| L | Left-to-Right | a-z, A-Z | Strong LTR |
| R | Right-to-Left | א-ת (Hebrew) | Strong RTL |
| AL | Arabic Letter | ا-ي (Arabic) | Strong RTL + special rules |
| EN | European Number | 0-9 | Weak (follows context) |
| ES | European Separator | + - | Weak |
| WS | Whitespace | space, tab | Neutral |
| ... | ... | ... | ... |

(Complete table with all classes from UAX #9 Table 4)

### High-Level Algorithm

```
function reorder_bidi(text):
    # Phase 1: Determine paragraph direction
    base_level = determine_paragraph_level(text)

    # Phase 2: Compute embedding levels
    levels = compute_embedding_levels(text, base_level)

    # Phase 3: Resolve weak and neutral types
    levels = resolve_weak_types(text, levels)
    levels = resolve_neutral_types(text, levels)

    # Phase 4: Reorder runs by level
    visual_order = reorder_by_levels(text, levels)

    return visual_order
```

### Examples

#### Example 1: Simple RTL

**Logical:** `Hello שלום world`
**Classes:** `L L L L L WS R R R R WS L L L L L`
**Levels:** `0 0 0 0 0 0 1 1 1 1 0 0 0 0 0 0 0`
**Visual:** `Hello םולש world` (RTL word reversed)

#### Example 2: Numbers in RTL

**Logical:** `عدد 123 نص`
**Classes:** `AL AL AL WS EN EN EN WS AL AL`
**Levels:** `1 1 1 1 2 2 2 1 1 1`
**Visual:** `صن 123 ددع` (Numbers stay LTR even in RTL context!)

(More complex examples from UAX #9 Section 7)
```

### Phase 2: Bidi Algorithm Details (Estimated: 1-2 hours)

**Read:**
- UAX #9, Section 5: Resolving Embedding Levels
- UAX #9, Section 6: Resolving Weak Types
- UAX #9, Section 7: Examples

**Extract:**

1. **Embedding Level Rules**: How explicit embeddings (LRE, RLE, PDF) work
2. **Weak Type Resolution**: How EN, ES, ET, CS are resolved
3. **Neutral Type Resolution**: How WS, ON are resolved
4. **Bracket Matching**: Special rules for paired brackets

**Document:**

```markdown
### Detailed Algorithm: Phase 2 (Embedding Levels)

```
function compute_embedding_levels(text, base_level):
    levels = array of length(text) initialized to base_level
    stack = [base_level]

    for i, char in enumerate(text):
        if char is embedding marker (LRE, RLE, LRO, RLO):
            # Push new level
            new_level = stack.top + 1 if even else stack.top + 2
            stack.push(new_level)
            levels[i] = new_level
        elif char is PDF:
            # Pop level
            stack.pop()
            levels[i] = stack.top
        else:
            levels[i] = stack.top

    return levels
```

### Edge Cases

1. **Nested Embeddings**: `LTR<RTL<LTR>RTL>LTR` - multiple levels
2. **Combining Marks**: Must stay with base character
3. **Bracket Pairs**: `(text)` treated specially
4. **Isolated Numbers**: `text 123 text` in RTL context

(Document how each is handled)
```

### Phase 3: Line Breaking Algorithm (Estimated: 2-3 hours)

**Read:**
- UAX #14, Sections 1-5: Introduction, Line Breaking Classes
- UAX #14, Section 6: Line Breaking Algorithm
- UAX #14, Section 7: Pair Table

**Goal:** Understand how to find break opportunities.

**Key Concepts:**

1. **Line Breaking Classes**: Every character has a class (OP, CL, QU, GL, etc.)
2. **Pair Table Rules**: Class A before Class B = rule (direct break, indirect break, prohibited)
3. **Tailoring**: Language-specific modifications to rules

**Document:**

```markdown
## Unicode Line Breaking Algorithm (UAX #14)

### Purpose

Find positions where line breaks are allowed/prohibited.

### Line Breaking Classes

| Class | Name | Examples | Meaning |
|-------|------|----------|---------|
| OP | Open Punctuation | ( [ { | Don't break after |
| CL | Close Punctuation | ) ] } | Don't break before |
| QU | Quotation | " ' | Complex rules |
| GL | Glue | NBSP | Prevent break |
| NS | Nonstarter | ! ? : ; | Don't start line |
| SP | Space | U+0020 | Break opportunity |
| ... | ... | ... | ... |

(Complete table from UAX #14 Table 1)

### High-Level Algorithm

```
function find_break_opportunities(text):
    classes = classify_characters(text)
    opportunities = []

    for i in 1..length(text):
        before_class = classes[i-1]
        after_class = classes[i]

        rule = pair_table_lookup(before_class, after_class)

        if rule == DIRECT_BREAK:
            opportunities.append(i)
        elif rule == INDIRECT_BREAK and intervening_space:
            opportunities.append(i)
        # else: prohibited, no break

    return opportunities
```

### Pair Table Rules

The pair table has thousands of entries. Key patterns:

- **Don't break after OP**: `(text` stays together
- **Don't break before CL**: `text)` stays together
- **Break at SP**: Spaces are break opportunities
- **Don't break GL**: Glue characters prevent breaks

(Excerpt from pair table showing most common rules)

### Examples

#### Example 1: English Text

**Text:** `"Hello world!" said Alice.`
**Classes:** `QU OP AL... WS AL... CL WS AL... AL CL`
**Breaks:** ` ^      ^       ^      ^      ` (at spaces mostly)

#### Example 2: URL

**Text:** `https://example.com/path`
**Classes:** `AL AL AL AL... BA AL... BA AL...`
**Breaks:** ` ^    ^        ^       ^` (special BA class for /)

#### Example 3: CJK Text

**Text:** `你好世界` (Chinese "hello world")
**Classes:** `ID ID ID ID` (Ideographic)
**Breaks:** ` ^  ^  ^  ^` (Can break between any characters!)

### Language-Specific Tailoring

Some languages need special rules:

- **Thai**: Requires dictionary-based breaking
- **Khmer**: Doesn't use spaces, needs word detection
- **Japanese**: Can't break before certain particles
- **Korean**: Special rules for Hangul

(Document where to find tailoring data)
```

### Phase 4: CSS Property Interactions (Estimated: 1 hour)

**Read:**
- CSS Text Level 3, Section 4: White Space and Wrapping
- CSS Text Level 3, Section 5: Breaking and Wrapping

**Extract how CSS properties modify Unicode algorithms:**

**Document:**

```markdown
## CSS Properties Affecting Text Algorithms

### Bidi Properties

1. **`direction: ltr | rtl`**
   - Sets paragraph base direction
   - Overrides UAX #9 paragraph level detection

2. **`unicode-bidi: normal | embed | isolate | ...`**
   - `normal`: Use UAX #9 implicit algorithm
   - `embed`: Insert LRE/RLE markers
   - `isolate`: Use isolate formatting (modern)

### Line Breaking Properties

1. **`white-space: normal | nowrap | pre | pre-wrap | pre-line`**
   - `normal`: Collapse whitespace, break at UAX #14 opportunities
   - `nowrap`: Collapse whitespace, never break
   - `pre`: Preserve all whitespace, break only at newlines
   - `pre-wrap`: Preserve whitespace, break at UAX #14 + newlines

2. **`word-break: normal | break-all | keep-all | break-word`**
   - `normal`: Use UAX #14
   - `break-all`: Allow breaks anywhere (override UAX #14)
   - `keep-all`: No breaks in CJK (override UAX #14)

3. **`overflow-wrap: normal | break-word | anywhere`**
   - When no break opportunities in container width, allow breaking anywhere

4. **`line-break: auto | loose | normal | strict`**
   - Tailoring for CJK line breaking strictness

5. **`hyphens: none | manual | auto`**
   - `auto`: Use hyphenation dictionary to create break opportunities

(Examples of how each property affects algorithm)
```

### Phase 5: Rust Crate APIs (Estimated: 1 hour)

**Research:**
- unicode-bidi crate: https://docs.rs/unicode-bidi/
- unicode-linebreak crate: https://docs.rs/unicode-linebreak/

**Goal:** Understand how to use these crates (don't reimplement algorithms).

**Document:**

```markdown
## Recommended Rust Crates

### unicode-bidi (for UAX #9)

```rust
use unicode_bidi::{BidiInfo, Level};

fn reorder_text(text: &str, base_level: Level) -> String {
    let bidi_info = BidiInfo::new(text, Some(base_level));

    // Get visual ordering
    let visual = bidi_info.reordered_levels_per_char();

    // Reorder text
    bidi_info.reorder_line(...)
}
```

**API highlights:**
- `BidiInfo::new()` - Analyze text
- `.visual_runs()` - Get runs of same direction
- `.reordered_levels_per_char()` - Get level per character

### unicode-linebreak (for UAX #14)

```rust
use unicode_linebreak::{BreakOpportunity, linebreaks};

fn find_breaks(text: &str) -> Vec<usize> {
    let mut breaks = Vec::new();

    for (offset, opportunity) in linebreaks(text) {
        if opportunity == BreakOpportunity::Allowed {
            breaks.push(offset);
        }
    }

    breaks
}
```

**API highlights:**
- `linebreaks()` - Iterator of break opportunities
- `BreakOpportunity::Allowed` - Can break here
- `BreakOpportunity::Mandatory` - Must break (newline)

(More detailed API examples for implementers)
```

## Output Artifacts

### Research Document

Create: **`docs/research/unicode-text-algorithms.md`**

Comprehensive document (2500-3500 words) covering:

1. **Bidi Algorithm** (1200 words)
   - Character classes
   - Algorithm phases
   - Pseudocode
   - Examples
   - Edge cases

2. **Line Breaking Algorithm** (1000 words)
   - Breaking classes
   - Pair table rules
   - Algorithm
   - Examples (English, CJK, URLs)
   - Language tailoring

3. **CSS Interactions** (500 words)
   - Property effects on algorithms
   - Examples

4. **Rust Crate Usage** (400 words)
   - unicode-bidi API
   - unicode-linebreak API
   - Integration patterns

5. **Implementation Strategy** (400 words)
   - Where these fit in text pipeline
   - Performance considerations
   - Testing approach

### Notes File

Create: **`docs/tasks/notes/W1.R03-notes.md`**

```markdown
# Task W1.R03 Output Notes

## Research Summary

Studied Unicode Bidirectional Algorithm (UAX #9) and Unicode Line Breaking Algorithm (UAX #14). Both are complex algorithms specified by Unicode Consortium and required for correct international text rendering.

**Key insight:** Don't reimplement these algorithms from scratch. Use battle-tested Rust crates:
- `unicode-bidi` for UAX #9
- `unicode-linebreak` for UAX #14

Both algorithms are more complex than they appear. Full implementations are 1000+ lines of careful state machine code.

## Bidi Algorithm Summary

**Purpose:** Reorder mixed LTR/RTL text for visual display

**Input:** Logical order text (as typed/stored)
**Output:** Visual order text (as displayed)

**Key phases:**
1. Determine paragraph base level (LTR or RTL)
2. Compute embedding levels for each character
3. Resolve weak types (numbers, separators)
4. Resolve neutral types (whitespace, punctuation)
5. Reorder runs by level

**Complexity:** O(n) with complex state machine

## Line Breaking Algorithm Summary

**Purpose:** Find valid positions to wrap text across lines

**Input:** Text string
**Output:** List of break opportunity positions

**Key concepts:**
- Every character has a line breaking class
- Pair table defines rules for adjacent classes
- Some breaks mandatory (newlines), some allowed (spaces), some prohibited

**Complexity:** O(n) table lookup per character pair

## Spec Interpretations

### UAX #9 Paragraph Level

**Spec says:** "Find first strong character (L, R, AL)"
**Interpretation:** Scan from start until L or R/AL found, use that to determine base level
**Edge case:** All-neutral paragraph (only punctuation/whitespace) - use direction property

### UAX #14 Indirect Breaks

**Spec says:** "Break allowed if intervening space"
**Interpretation:** ` ` class before break point means allowed, else prohibited
**Example:** `word(text)` - no break before `)` but `word )` allows break before `)`

## Critical Implementation Notes

### For W4.T01 (Bidi Analyzer):

**Use unicode-bidi crate** - Don't reimplement!

```rust
use unicode_bidi::{BidiInfo, Level};

pub struct BidiAnalyzer;

impl BidiAnalyzer {
    pub fn analyze(text: &str, direction: Direction) -> BidiInfo {
        let base_level = match direction {
            Direction::LTR => Level::ltr(),
            Direction::RTL => Level::rtl(),
        };
        BidiInfo::new(text, Some(base_level))
    }
}
```

**Integration points:**
- After text shaping (before line breaking)
- Store bidi levels per glyph
- Use levels during line breaking for cursor positioning

### For W4.T08 (Break Opportunity Finder):

**Use unicode-linebreak crate** - Don't reimplement!

```rust
use unicode_linebreak::{linebreaks, BreakOpportunity};

pub fn find_break_opportunities(text: &str) -> Vec<usize> {
    linebreaks(text)
        .filter_map(|(offset, opp)| {
            match opp {
                BreakOpportunity::Allowed | BreakOpportunity::Mandatory => Some(offset),
                _ => None,
            }
        })
        .collect()
}
```

**Modify based on CSS properties:**
- `white-space: nowrap` → no breaks
- `word-break: break-all` → break everywhere
- `hyphens: auto` → add hyphenation break opportunities

## Discoveries & Gotchas

### Discovery 1: Bidi affects cursor movement

Logical order != visual order means:
- Arrow keys move in logical order
- Mouse clicks map to visual position
- Need bidirectional cursor position mapping

**Implication:** Inline layout needs bidi level information for hit testing.

### Discovery 2: Numbers in RTL context stay LTR

Arabic number example: `عدد 123 نص`
The numbers 123 display LTR even though surrounded by RTL text!

**Reason:** EN (European Number) class has lower precedence than R/AL.

**Test case:** Must verify this works correctly.

### Discovery 3: CJK line breaking allows breaks almost everywhere

Chinese text can break between any two characters (with exceptions).

**Implication:** Line breaking for CJK is much more flexible than English.

**Test case:** Verify break opportunities every character for Chinese.

## Recommendations for Downstream Tasks

### For W4.T01 (Bidi Analyzer):

1. Wrap unicode-bidi crate, don't expose it directly
2. Store bidi levels with glyphs (needed for cursor positioning)
3. Handle CSS direction and unicode-bidi properties
4. Test with mixed LTR/RTL, nested embeddings, numbers in RTL

### For W4.T08 (Break Opportunity Finder):

1. Wrap unicode-linebreak crate
2. Add CSS property filtering (white-space, word-break, etc.)
3. Add hyphenation as separate pass (after base break opportunities)
4. Return break positions as byte offsets (not char offsets)

### For W4.T12 (Inline Layout):

1. Apply bidi reordering BEFORE line breaking
2. Store both logical and visual order
3. Use visual order for display, logical for editing
4. Implement cursor position mapping (visual ↔ logical)

## Open Questions

### Question 1: How to handle bidi in form inputs?

**Context:** Editable text needs cursor positioning
**Complexity:** Visual position != logical position in bidi text
**Resolution:** W4.T12 should implement cursor mapping
**Reference:** Look at browser implementations

### Question 2: Thai line breaking dictionary

**Context:** Thai requires word segmentation for line breaking
**UAX #14 says:** Use language-specific dictionary
**Options:**
  - Use `unicode-segmentation` crate
  - Find Thai-specific dictionary library
**Resolution:** W4.T08 decision

## References Studied

1. UAX #9 - Bidirectional Algorithm
   - https://www.unicode.org/reports/tr9/
   - Sections 2-7 (algorithm and examples)
2. UAX #14 - Line Breaking Algorithm
   - https://www.unicode.org/reports/tr14/
   - Sections 5-7 (classes, algorithm, pair table)
3. CSS Text Module Level 3
   - https://www.w3.org/TR/css-text-3/
   - Sections 4-5 (wrapping and breaking)
4. unicode-bidi crate docs
   - https://docs.rs/unicode-bidi/
5. unicode-linebreak crate docs
   - https://docs.rs/unicode-linebreak/

---

**Research completed:** YYYY-MM-DD
**Time taken:** 6-8 hours
**Confidence level:** High - UAX specs studied thoroughly
**Recommendation:** Use Rust crates, don't reimplement algorithms
```

## Common Pitfalls to Avoid

### Pitfall 1: Trying to Reimplement UAX Algorithms

**Wrong:** "I'll write my own bidi algorithm"
**Right:** Use unicode-bidi crate

The spec is 50+ pages. Browser implementations are 2000+ lines. Don't reinvent.

### Pitfall 2: Ignoring Bidi Edge Cases

**Wrong:** Test only simple LTR/RTL mixing
**Right:** Test nested embeddings, numbers in RTL, brackets

Edge cases are where bugs hide.

### Pitfall 3: Confusing Logical and Visual Order

**Wrong:** Assume text storage order = display order
**Right:** Always distinguish logical (storage) from visual (display)

This is the core insight of bidi.

## Verification Checklist

- [ ] UAX #9 read completely (Sections 1-7)
- [ ] UAX #14 read completely (Sections 1-7)
- [ ] Bidi algorithm in pseudocode
- [ ] Line breaking algorithm in pseudocode
- [ ] At least 15 spec quotes
- [ ] Concrete examples for both algorithms
- [ ] Rust crate APIs documented
- [ ] Research document 2500-3500 words
- [ ] Notes file complete
- [ ] Ready for W4.T01 and W4.T08

## Time Tracking

- **Bidi overview:** 2-3 hours
- **Bidi details:** 1-2 hours
- **Line breaking:** 2-3 hours
- **CSS interactions:** 1 hour
- **Rust crates:** 1 hour
- **Total:** 6-8 hours
