---
task_id: "W1.R04"
title: "Browser Layout Code Study (Servo)"
wave: 1
estimated_hours: 8-12
depends_on: []
inputs: []
outputs:
  - "outputs/notes/W1.R04-notes.md"
  - "docs/research/servo-layout-architecture.md"
skills_required:
  - "Reading Rust codebases"
  - "Understanding CSS layout concepts"
  - "Code pattern analysis"
  - "Architecture documentation"
context_files:
  - "docs/plan/01-core-architecture.md"
  - "docs/plan/02-table-layout.md"
  - "docs/plan/03-line-breaking.md"
  - "docs/plan/04-positioning.md"
verification:
  - "Research document created with all sections filled"
  - "Servo architecture patterns documented"
  - "Code examples extracted and explained"
  - "Recommendations for W2-W4 implementation tasks documented"
---

# Browser Layout Code Study (Servo)

## Context

While CSS specifications tell us **what** to implement, browser codebases show us **how** to implement it. Servo is Mozilla's experimental browser engine written in Rust, making it the ideal reference for FastRender V2.

This research task involves **deep study** of Servo's `layout_2020` module to understand:
- How to architect a modern layout engine
- How to separate box tree construction from fragment tree generation
- How to design formatting context abstractions
- How real browsers implement complex algorithms (table layout, inline layout)
- What patterns work well and what patterns to avoid

### Background

**Why Study Servo Specifically:**

Servo is uniquely valuable because:
1. **Written in Rust**: Same language as FastRender, patterns directly applicable
2. **Modern architecture**: Designed from scratch with lessons from WebKit/Gecko
3. **Well-documented**: Code includes extensive comments and design docs
4. **Production-quality**: Powers Firefox's Stylo CSS engine
5. **Educational**: Simpler than WebKit/Gecko but still spec-compliant

**Servo's Layout Architecture:**

Servo uses a two-tree architecture:
- **Box Tree**: Represents CSS boxes from style computation
- **Fragment Tree**: Represents layout output (positioned, sized fragments)

This separation is **critical** for correctness and follows the CSS specification's conceptual model.

**From Servo's architecture docs:**
> "The box tree represents the CSS box model, while the fragment tree represents the result of layout. This separation allows us to handle complex scenarios like fragmentation, multicol, and pagination correctly."

### Why This Matters

Without studying working browser code:
- We'll reinvent solutions to problems already solved
- We'll miss edge cases that specs don't make explicit
- We'll make architecture mistakes that require rewrites
- We'll use inefficient algorithms where better ones exist

**This research is BLOCKING for:**
- W2.T07 (FormattingContext trait) - Need to understand trait design patterns
- W3.T06 (Table Layout) - Need to see how browsers implement the algorithm
- W4.T12 (Inline Layout) - Need to understand fragment generation patterns
- All layout implementations - Architecture decisions affect everything

Spending 8-12 hours studying Servo now will save **weeks** of implementation mistakes later.

## Prerequisites

### Required Knowledge

- **Rust language**: Understanding structs, traits, enums, pattern matching
- **CSS box model**: Understanding of block/inline layout, containing blocks
- **Git/GitHub**: Ability to browse code repositories, read commit history
- **Code reading**: Ability to understand unfamiliar codebases

### Required Reading

1. **Servo layout_2020 overview**:
   - https://github.com/servo/servo/tree/main/components/layout_2020
   - Read `README.md` in that directory
   - Understand the module structure

2. **CSS 2.1 Visual Formatting Model** (recap):
   - https://www.w3.org/TR/CSS21/visuren.html
   - Sections 9.1-9.10 (review from W1.R01)

3. **docs/plan/01-core-architecture.md**:
   - Our planned architecture
   - Compare with Servo's approach

4. **W1.R01 research notes** (if completed):
   - Refresh CSS concepts before studying implementation

## Inputs

### From Dependencies

**None** - This is a Wave 1 research task with no dependencies.

### Existing Resources

**Servo Repository:**
- Main repo: https://github.com/servo/servo
- Layout 2020: `components/layout_2020/`
- Key files to study (will be detailed in research guide)

**Servo Documentation:**
- Architecture docs: https://github.com/servo/servo/wiki/Design
- Servo book: https://book.servo.org/

## Objectives

### Primary Goals

1. **Understand box tree vs fragment tree separation**: Why this matters and how to implement it
2. **Study FormattingContext trait design**: How Servo abstracts different layout modes
3. **Analyze table layout implementation**: Real-world algorithm implementation
4. **Analyze inline layout implementation**: Fragment generation patterns
5. **Extract architecture patterns**: What to adopt for FastRender V2
6. **Identify pitfalls**: What Servo does that we should avoid or do differently

### Success Criteria

- [ ] Box tree architecture documented with code examples
- [ ] Fragment tree architecture documented with code examples
- [ ] FormattingContext trait design analyzed and documented
- [ ] Table layout algorithm traced and documented
- [ ] Inline layout algorithm traced and documented
- [ ] At least 30 code snippets from Servo with explanations
- [ ] Clear recommendations for W2.T07, W3.T06, W4.T12
- [ ] Research document is 3000-4000 words
- [ ] Notes file created with actionable guidance

## Research Guide

### Phase 1: Module Structure Overview (Estimated: 1-2 hours)

**Navigate to:**
- https://github.com/servo/servo/tree/main/components/layout_2020

**Study file structure:**
```
layout_2020/
├── lib.rs                    # Module root
├── flow/                     # Flow layout (block/inline)
├── fragment_tree/            # Fragment tree types
├── table/                    # Table layout
├── positioned.rs             # Absolute/fixed positioning
├── sizing.rs                 # Size computation
├── display_list.rs           # Paint output
└── ...
```

**Extract:**
- Module organization philosophy
- Separation of concerns
- Naming conventions

**Document in `docs/research/servo-layout-architecture.md`:**

```markdown
# Servo Layout Architecture Study

## Module Structure

Servo's `layout_2020` module is organized by **layout mode** rather than by stage:

### Directory Organization

```
flow/          - Block and inline layout
table/         - Table layout
fragment_tree/ - Output representation
```

**Key insight:** Each layout mode is self-contained. This allows:
- Independent implementation of different CSS specifications
- Clear ownership boundaries
- Easier testing of individual modes

### Module Dependencies

```
lib.rs
  ↓
flow/ ← table/ ← positioned.rs
  ↓
fragment_tree/
  ↓
display_list/
```

**Pattern:** Data flows from style → box tree → fragments → display list

(Continue documenting module structure...)
```

### Phase 2: Box Tree Architecture (Estimated: 2-3 hours)

**Study these files:**
- `layout_2020/flow/mod.rs` - Box tree types
- `layout_2020/flow/construct.rs` - Box tree construction
- `layout_2020/fragment_tree/mod.rs` - Fragment types

**Key questions to answer:**

1. **How is the box tree represented?**
   - What types represent boxes?
   - How are children stored?
   - How is style information attached?

2. **How is the box tree constructed?**
   - From DOM to box tree transformation
   - Anonymous box generation
   - Display value handling

3. **Box tree vs Fragment tree - what's the difference?**
   - What information is in boxes but not fragments?
   - What information is in fragments but not boxes?

**Extract code examples:**

```rust
// Example from Servo showing box tree types
// (Find actual Servo code and include it)
```

**Document:**

```markdown
## Box Tree Architecture

### Box Types in Servo

Servo represents boxes using these primary types:

```rust
// From components/layout_2020/flow/mod.rs
pub enum BoxTree {
    Block(BlockBox),
    Inline(InlineBox),
    Table(TableBox),
    // ... other types
}

pub struct BlockBox {
    pub style: Arc<ComputedValues>,
    pub children: Vec<BoxTree>,
    // ... other fields
}
```

**Key insight:** Each box type wraps a `ComputedValues` (styled element) and has typed children.

### Box Tree Construction

From DOM to box tree:

```rust
// Pseudocode based on Servo's pattern
fn construct_box_tree(element: &Element) -> BoxTree {
    let style = element.computed_style();

    match style.display() {
        Display::Block => construct_block_box(element, style),
        Display::Inline => construct_inline_box(element, style),
        Display::Table => construct_table_box(element, style),
        // ... handle all display types
    }
}
```

**Pattern to adopt:** Separate box tree construction from layout. Box tree is purely structural.

### Box Tree vs Fragment Tree

**Box Tree:**
- Represents CSS boxes (conceptual)
- Created from DOM + style
- Immutable after construction
- Contains no layout information (no positions/sizes)

**Fragment Tree:**
- Represents layout output (concrete)
- Created by layout algorithms
- Contains positions and sizes
- Represents "fragments" that will be painted

**Example difference:**

A single inline box may generate **multiple fragments** (one per line):

```
Box Tree:          Fragment Tree:
InlineBox          InlineFragment (line 1)
  └─ text          InlineFragment (line 2)
                   InlineFragment (line 3)
```

**Critical insight:** Box tree is 1:1 with CSS boxes, fragment tree is 1:N.

(Continue with more examples and analysis...)
```

### Phase 3: FormattingContext Trait Design (Estimated: 2-3 hours)

**Study these files:**
- Look for trait definitions related to formatting contexts
- How block, inline, flex, table layouts are abstracted
- Common interface vs mode-specific methods

**Key questions:**

1. **Does Servo use a FormattingContext trait?**
   - If yes, what's the interface?
   - If no, how are different layout modes handled?

2. **What operations are common across all layout modes?**
   - Layout computation
   - Size negotiation
   - Fragment generation

3. **How does Servo handle nested formatting contexts?**
   - Block containing inline containing block
   - Table cells (block formatting context)

**Document pattern analysis:**

```markdown
## FormattingContext Abstraction

### Servo's Approach

After studying Servo's code, here's how they handle formatting contexts:

[If Servo has a trait]
```rust
// Actual trait from Servo
pub trait FormattingContext {
    fn layout(&mut self, containing_block: &Size) -> FragmentTree;
    // ... other methods
}
```

[If Servo doesn't use a trait]
Servo uses an enum dispatch pattern instead:

```rust
enum LayoutMode {
    Block(BlockLayout),
    Inline(InlineLayout),
    Table(TableLayout),
}

impl LayoutMode {
    fn layout(&mut self, containing_block: &Size) -> FragmentTree {
        match self {
            Block(layout) => layout.layout_block(containing_block),
            Inline(layout) => layout.layout_inline(containing_block),
            Table(layout) => layout.layout_table(containing_block),
        }
    }
}
```

### Pattern Analysis

**Pros of trait approach:**
- Extensible (new layout modes without modifying enum)
- Clear abstraction boundary
- Better for plugin architectures

**Pros of enum approach:**
- No dynamic dispatch (potentially faster)
- Exhaustive matching (compiler checks all cases)
- Simpler for closed set of layout modes

**Recommendation for W2.T07:**

[Based on Servo study, recommend which approach for FastRender V2]

### Common Operations

All layout modes need to:

1. **Compute intrinsic sizes** (min-content, max-content)
2. **Perform layout** (given containing block size, produce fragments)
3. **Handle children** (recursively layout nested contexts)

Servo's pattern for this:

```rust
// Extract actual pattern from Servo code
```

(Continue analyzing trait design patterns...)
```

### Phase 4: Table Layout Implementation (Estimated: 2-3 hours)

**Study these files:**
- `layout_2020/table/mod.rs` - Table layout entry point
- `layout_2020/table/layout.rs` - Table algorithm
- Any files related to column width computation

**Key questions:**

1. **How does Servo implement fixed layout vs auto layout?**
   - Separate code paths or unified?
   - Algorithm structure

2. **How are column widths computed?**
   - Data structures used
   - Fixed layout algorithm
   - Auto layout algorithm

3. **How does Servo handle rowspan/colspan?**
   - Special case handling
   - Edge cases

4. **What data structures represent table layout?**
   - Table grid
   - Column/row tracks
   - Cell mapping

**Extract algorithm pseudocode:**

```markdown
## Table Layout Implementation

### Servo's Table Layout Algorithm

**File:** `components/layout_2020/table/layout.rs`

#### Data Structures

```rust
// Actual Servo code showing table representation
pub struct TableLayout {
    columns: Vec<Column>,
    rows: Vec<Row>,
    cells: Vec<Vec<Cell>>,
}

pub struct Column {
    width: Au,  // Au = Atomic Unit (1/60 of a CSS pixel)
    // ... other fields
}
```

**Key insight:** Servo uses explicit grid representation, not just nested boxes.

#### Fixed Layout Algorithm

```rust
// Pseudocode based on Servo's implementation
fn compute_fixed_layout(table: &Table, available_width: Au) -> Vec<Au> {
    let column_count = analyze_columns(table);
    let mut column_widths = vec![None; column_count];

    // Step 1: Process first row for explicit widths
    for (i, cell) in table.first_row().cells.iter().enumerate() {
        if let Some(width) = cell.style.width.to_used() {
            column_widths[i] = Some(width);
        }
    }

    // Step 2: Distribute remaining width to auto columns
    let specified_total: Au = column_widths.iter()
        .filter_map(|w| *w)
        .sum();
    let remaining = available_width - specified_total;
    let auto_count = column_widths.iter().filter(|w| w.is_none()).count();

    let auto_width = remaining / auto_count as i32;
    for width in column_widths.iter_mut() {
        if width.is_none() {
            *width = Some(auto_width);
        }
    }

    column_widths.into_iter().map(|w| w.unwrap()).collect()
}
```

**Comparison with spec:** This matches CSS 2.1 Section 17.5.2.1 fixed layout algorithm.

#### Auto Layout Algorithm

```rust
// Pseudocode from Servo
fn compute_auto_layout(table: &Table, available_width: Au) -> Vec<Au> {
    // Step 1: Compute min and max widths for each column
    let (min_widths, max_widths) = compute_column_constraints(table);

    // Step 2: Distribute available width
    distribute_width(min_widths, max_widths, available_width)
}

fn compute_column_constraints(table: &Table) -> (Vec<Au>, Vec<Au>) {
    let mut min_widths = vec![Au(0); table.column_count()];
    let mut max_widths = vec![Au(0); table.column_count()];

    // Analyze all cells
    for row in &table.rows {
        for cell in &row.cells {
            let col = cell.column_index;

            // Compute min-content (no wrapping)
            let min = cell.compute_min_content_width();
            min_widths[col] = min_widths[col].max(min);

            // Compute max-content (no constraints)
            let max = cell.compute_max_content_width();
            max_widths[col] = max_widths[col].max(max);

            // Handle colspan
            if cell.colspan > 1 {
                distribute_colspan(cell, &mut min_widths, &mut max_widths);
            }
        }
    }

    (min_widths, max_widths)
}
```

**Key insight:** Auto layout requires analyzing **every cell** to find column constraints.

#### Edge Cases Servo Handles

1. **Colspan distribution:**
   ```rust
   // How Servo distributes colspan width across columns
   fn distribute_colspan(cell: &Cell, widths: &mut Vec<Au>) {
       let spanned_cols = cell.column_index..cell.column_index + cell.colspan;
       let total_width = cell.width;

       // Distribute proportionally based on existing widths
       let existing_total: Au = spanned_cols.clone()
           .map(|i| widths[i])
           .sum();

       for col in spanned_cols {
           let proportion = widths[col] / existing_total;
           widths[col] = total_width * proportion;
       }
   }
   ```

2. **Percentage widths in auto layout:**
   [Document how Servo handles this edge case]

3. **Table narrower than min-content:**
   [Document overflow behavior]

### Patterns to Adopt for W3.T06

1. **Use explicit grid representation**: Don't just rely on box tree
2. **Separate fixed and auto algorithms**: They're fundamentally different
3. **Two-pass auto layout**: First compute constraints, then distribute
4. **Handle colspan carefully**: Proportional distribution, not even split

### Patterns to Avoid

1. **Don't try to unify fixed and auto**: Leads to complex code
2. **Don't forget to handle percentage widths**: They interact with auto layout
3. **Don't ignore border-collapse impact**: Affects column width computation

(Continue with detailed table layout analysis...)
```

### Phase 5: Inline Layout Implementation (Estimated: 2-3 hours)

**Study these files:**
- `layout_2020/flow/inline.rs` - Inline layout
- Look for line breaking logic
- Look for fragment generation from inline boxes

**Key questions:**

1. **How does Servo represent inline formatting context?**
   - Inline boxes vs text runs
   - Atomic inlines (replaced elements)

2. **How are fragments generated from inline boxes?**
   - Line breaking algorithm
   - One box → multiple fragments mapping
   - Bidi text handling

3. **How are inline-block elements handled?**
   - Mixed inline/block layout

4. **What data structures represent line boxes?**

**Document:**

```markdown
## Inline Layout Implementation

### Inline Formatting Context Representation

```rust
// Servo's inline box representation
pub struct InlineFormattingContext {
    inline_items: Vec<InlineItem>,
    // ... other fields
}

pub enum InlineItem {
    TextRun(TextRun),
    AtomicInline(AtomicInline),
    StartTag(InlineBox),
    EndTag(InlineBox),
}
```

**Key insight:** Inline content is "linearized" into a sequence of items.

### Fragment Generation Algorithm

The inline layout algorithm:

```rust
fn layout_inline_formatting_context(
    ifc: &InlineFormattingContext,
    containing_block_width: Au
) -> Vec<LineFragment> {
    let mut line_breaker = LineBreaker::new(containing_block_width);
    let mut lines = Vec::new();

    for item in &ifc.inline_items {
        match item {
            TextRun(text) => {
                // Find break opportunities
                let opportunities = find_break_opportunities(text);

                for segment in line_breaker.add_text(text, opportunities) {
                    if segment.is_line_break() {
                        lines.push(line_breaker.finish_line());
                        line_breaker.start_new_line();
                    }
                }
            }
            AtomicInline(element) => {
                // Layout element, get size
                let size = element.layout();

                if !line_breaker.can_fit(size.width) {
                    lines.push(line_breaker.finish_line());
                    line_breaker.start_new_line();
                }

                line_breaker.add_atomic(element, size);
            }
            // ... handle start/end tags
        }
    }

    // Finish last line
    lines.push(line_breaker.finish_line());

    lines
}
```

**Pattern:** Servo uses a streaming algorithm that builds lines incrementally.

### Line Box Data Structure

```rust
pub struct LineFragment {
    pub fragments: Vec<InlineFragment>,
    pub baseline: Au,
    pub line_height: Au,
}

pub struct InlineFragment {
    pub item: InlineItem,
    pub position: Point,
    pub size: Size,
}
```

**Key insight:** A line is a collection of positioned inline fragments.

### One-to-Many Mapping

Example showing how one inline box becomes multiple fragments:

```
Box tree:
  InlineBox { content: "This is a long piece of text" }

Fragment tree:
  LineFragment (line 1):
    InlineFragment { content: "This is a" }
  LineFragment (line 2):
    InlineFragment { content: "long piece" }
  LineFragment (line 3):
    InlineFragment { content: "of text" }
```

**Critical for W4.T12:** Must handle this 1:N relationship correctly.

### Patterns for W4.T12

1. **Linearize inline content first**: Flatten to sequence of items
2. **Stream process for line breaking**: Don't try to break all lines at once
3. **Keep track of open/close tags**: For proper fragment generation
4. **Handle atomic inlines specially**: They don't split across lines

(Continue with inline layout analysis...)
```

### Phase 6: Architecture Patterns Summary (Estimated: 1-2 hours)

**Synthesize learnings:**
- What patterns appear repeatedly?
- What abstractions work well?
- What would we do differently?

**Document:**

```markdown
## Architecture Patterns to Adopt

### Pattern 1: Separate Box Tree and Fragment Tree

**What:** Maintain two distinct tree representations
**Why:** Box tree is logical (CSS model), fragment tree is physical (layout output)
**Where to apply:** All of FastRender V2 architecture

**Code pattern:**
```rust
// Box tree (no layout info)
struct BoxTree {
    style: ComputedValues,
    children: Vec<BoxTree>,
}

// Fragment tree (with layout info)
struct Fragment {
    position: Point,
    size: Size,
    box_ref: BoxTreeRef,  // Link back to box
}
```

### Pattern 2: Enum Dispatch for Layout Modes

**What:** Use enum variants for different formatting contexts
**Why:** Closed set of layout modes, exhaustive matching
**Where to apply:** W2.T07 FormattingContext design

**Code pattern:**
```rust
enum FormattingContext {
    Block(BlockFormattingContext),
    Inline(InlineFormattingContext),
    Table(TableFormattingContext),
}

impl FormattingContext {
    fn layout(&mut self, containing_block: &Size) -> Fragments {
        match self {
            Block(bfc) => bfc.layout_block(containing_block),
            Inline(ifc) => ifc.layout_inline(containing_block),
            Table(tfc) => tfc.layout_table(containing_block),
        }
    }
}
```

### Pattern 3: Two-Pass Sizing

**What:** Separate intrinsic size computation from actual layout
**Why:** Some layout modes need to know size before laying out children
**Where to apply:** All layout implementations

**Code pattern:**
```rust
trait Layout {
    // Pass 1: Compute intrinsic sizes
    fn compute_intrinsic_sizes(&self) -> IntrinsicSizes;

    // Pass 2: Perform layout with known size
    fn layout(&mut self, available_size: Size) -> Fragments;
}
```

### Pattern 4: Grid Representation for Table Layout

**What:** Explicit 2D grid structure for tables
**Why:** Makes colspan/rowspan handling explicit
**Where to apply:** W3.T06 Table Layout

**Code pattern:**
```rust
struct TableGrid {
    columns: Vec<Column>,
    rows: Vec<Row>,
    cells: Grid<Option<CellRef>>,  // 2D grid with cell references
}
```

### Pattern 5: Linearization for Inline Layout

**What:** Convert inline boxes to linear sequence before line breaking
**Why:** Simplifies line breaking algorithm
**Where to apply:** W4.T12 Inline Layout

**Code pattern:**
```rust
enum InlineItem {
    Text(String),
    Atomic(Box),
    StartTag(InlineBoxRef),
    EndTag(InlineBoxRef),
}

fn linearize(inline_box: &InlineBox) -> Vec<InlineItem> {
    // Flatten inline box tree to sequence
}
```

## Architecture Anti-Patterns to Avoid

### Anti-Pattern 1: Mixing Box Tree and Layout

**Problem:** Storing positions/sizes in box tree
**Why it's bad:** Makes caching invalid, complicates tree structure
**Solution:** Keep box tree immutable, store layout in separate fragment tree

### Anti-Pattern 2: Single-Pass Layout

**Problem:** Trying to layout and size in one traversal
**Why it's bad:** Many layouts need size before laying out children (tables!)
**Solution:** Use two-pass algorithm (intrinsic sizes, then layout)

### Anti-Pattern 3: Implicit Grid for Tables

**Problem:** Relying on box tree structure for table grid
**Why it's bad:** Colspan/rowspan make implicit grid incorrect
**Solution:** Build explicit 2D grid structure

(Continue documenting patterns...)
```

## Output Artifacts

### Research Document

Create: **`docs/research/servo-layout-architecture.md`**

Comprehensive document (3000-4000 words) covering:

1. **Module Structure** (400 words)
   - Organization philosophy
   - Directory layout
   - Module dependencies

2. **Box Tree Architecture** (600 words)
   - Box types
   - Construction algorithm
   - Box vs Fragment separation

3. **FormattingContext Design** (600 words)
   - Trait or enum approach
   - Common operations
   - Pattern analysis

4. **Table Layout Implementation** (800 words)
   - Algorithm walkthrough
   - Code examples
   - Edge case handling

5. **Inline Layout Implementation** (700 words)
   - Fragment generation
   - Line breaking
   - 1:N box-to-fragment mapping

6. **Architecture Patterns** (500 words)
   - Patterns to adopt
   - Anti-patterns to avoid
   - Recommendations for FastRender

7. **Code Examples** (400 words)
   - 30+ annotated Servo code snippets
   - Explanations of why patterns work

### Notes File

Create: **`outputs/notes/W1.R04-notes.md`**

```markdown
# Task W1.R04 Output Notes

## Research Summary

Conducted deep study of Servo's layout_2020 module to understand browser-grade layout architecture. Servo's codebase demonstrates proven patterns for separating box tree from fragment tree, implementing multiple formatting contexts, and handling complex layout algorithms.

**Key findings:**
1. **Box/Fragment separation is essential** - Box tree is logical (CSS model), fragment tree is physical (layout output)
2. **Enum dispatch works well** - For closed set of layout modes, enum is simpler than trait objects
3. **Two-pass sizing is universal** - Almost all layout modes need intrinsic sizes before main layout
4. **Explicit data structures win** - Tables need explicit grids, inline needs linearization

## Box Tree vs Fragment Tree

### Servo's Two-Tree Architecture

**Box Tree:**
- Created from DOM + computed styles
- Represents CSS box model (logical structure)
- Immutable after construction
- No position or size information

**Fragment Tree:**
- Created by layout algorithms
- Represents positioned, sized fragments
- One box may generate many fragments (inline wrapping)
- This is what gets painted

**Critical insight:** This separation allows:
- Caching styles separately from layout
- Handling fragmentation (pagination, multicol)
- Correct 1:N box-to-fragment mapping

### Recommendation for FastRender V2

**Adopt this pattern throughout:**

```rust
// Box tree - created in W2 tasks
pub struct BoxTree {
    pub style: ComputedValues,
    pub children: Vec<BoxTree>,
    // NO position/size fields!
}

// Fragment tree - created in W3-W5 tasks
pub struct Fragment {
    pub position: Point,
    pub size: Size,
    pub source_box: BoxTreeRef,
}
```

## FormattingContext Design

### Servo's Approach

After studying Servo, they use **enum dispatch** not trait objects:

```rust
// Servo pattern (simplified)
enum FormattingContext {
    Block(BlockFC),
    Inline(InlineFC),
    Table(TableFC),
    Flex(FlexFC),
}

impl FormattingContext {
    fn layout(&mut self, cb: &ContainingBlock) -> Vec<Fragment> {
        match self {
            Block(fc) => fc.layout_block(cb),
            Inline(fc) => fc.layout_inline(cb),
            Table(fc) => fc.layout_table(cb),
            Flex(fc) => fc.layout_flex(cb),
        }
    }
}
```

**Why enum instead of trait:**
1. No dynamic dispatch overhead
2. Exhaustive matching (compiler checks all cases)
3. Simpler for closed set of modes
4. Easier to add common fields

**Recommendation for W2.T07:** Use enum dispatch pattern.

## Table Layout Implementation

### Servo's Algorithm Structure

**Fixed layout:**
```rust
fn compute_fixed_layout(table: &Table, width: Au) -> Vec<Au> {
    // 1. Analyze first row only
    let widths = first_row_widths(table);

    // 2. Distribute remaining width to auto columns
    distribute_to_auto_columns(widths, width)
}
```

**Auto layout:**
```rust
fn compute_auto_layout(table: &Table, width: Au) -> Vec<Au> {
    // 1. Analyze ALL cells for min/max widths
    let (min, max) = analyze_all_cells(table);

    // 2. Distribute width based on constraints
    distribute_width(min, max, width)
}
```

### Key Implementation Details

**Grid Representation:**
```rust
struct TableGrid {
    columns: Vec<Column>,
    rows: Vec<Row>,
    cells: Vec<Vec<Option<CellRef>>>,  // 2D sparse grid
}
```

Explicit grid makes colspan/rowspan trivial to handle.

**Colspan Distribution:**
Servo distributes proportionally, not evenly:

```rust
// For cell spanning columns 2-4 with width 300px
// Don't do: 100px each
// Do: Proportional to existing column widths
let existing = [col2.width, col3.width, col4.width];
let total = existing.sum();
col2.width = 300 * (col2.width / total);
col3.width = 300 * (col3.width / total);
col4.width = 300 * (col4.width / total);
```

### Recommendations for W3.T06

1. **Use explicit TableGrid struct** - Don't rely on box tree structure
2. **Separate fixed and auto completely** - Two different functions, not branches
3. **Two-pass auto layout** - First constraints, then distribution
4. **Handle percentages carefully** - They interact with auto layout strangely
5. **Test edge cases from Servo** - They've already found the bugs

## Inline Layout Implementation

### Fragment Generation Pattern

Servo uses a **linearization + streaming** approach:

```rust
// Step 1: Linearize inline boxes to items
enum InlineItem {
    Text(String),
    Atomic(AtomicInline),
    StartTag(InlineBox),
    EndTag(InlineBox),
}

fn linearize(inline_box: &InlineBox) -> Vec<InlineItem> {
    let mut items = vec![];
    items.push(InlineItem::StartTag(inline_box));
    for child in &inline_box.children {
        match child {
            Text(t) => items.push(InlineItem::Text(t)),
            Inline(i) => items.extend(linearize(i)),  // Recursive
            Atomic(a) => items.push(InlineItem::Atomic(a)),
        }
    }
    items.push(InlineItem::EndTag(inline_box));
    items
}

// Step 2: Stream process into lines
fn break_into_lines(items: &[InlineItem], width: Au) -> Vec<Line> {
    let mut line_breaker = LineBreaker::new(width);
    let mut lines = vec![];

    for item in items {
        if !line_breaker.can_fit(item) {
            lines.push(line_breaker.finish());
            line_breaker.start_new_line();
        }
        line_breaker.add(item);
    }

    lines.push(line_breaker.finish());
    lines
}
```

### One-to-Many Mapping

**Critical insight:** One inline box generates multiple fragments.

Example:
```
Box tree:
  <span>This is long text that wraps</span>

Fragment tree:
  Line 1: Fragment("This is long text")
  Line 2: Fragment("that wraps")
```

Both fragments reference the same `<span>` box.

**Implementation detail:**
```rust
struct InlineFragment {
    source_box: InlineBoxRef,  // Which box this came from
    text_range: Range<usize>,  // Which part of text
    position: Point,
    size: Size,
}
```

### Recommendations for W4.T12

1. **Linearize first** - Flatten inline boxes to sequence
2. **Use streaming line breaker** - Process items one at a time
3. **Track open/close tags** - Needed for proper fragment wrapping
4. **Store text ranges** - Fragment refers to slice of original text
5. **Handle atomic inlines specially** - They don't split

## Critical Architecture Decisions

### Decision 1: Enum vs Trait for FormattingContext

**Choice:** Use enum dispatch
**Rationale:** Servo demonstrates this works well for closed set of layout modes
**Impact on W2.T07:** Implement as enum, not trait object

### Decision 2: Explicit Grid for Tables

**Choice:** Create TableGrid structure
**Rationale:** Servo shows implicit grid is too complex for colspan/rowspan
**Impact on W3.T06:** Don't try to use box tree as grid

### Decision 3: Linearization for Inline

**Choice:** Convert inline boxes to linear sequence
**Rationale:** Makes line breaking algorithm much simpler
**Impact on W4.T12:** Add linearization step before line breaking

## Code Patterns Extracted

### Pattern: Two-Pass Sizing

Almost every layout mode in Servo uses this:

```rust
// Pass 1: Compute intrinsic sizes (min-content, max-content)
fn compute_intrinsic_sizes(&self) -> IntrinsicSizes {
    let mut sizes = IntrinsicSizes::zero();
    for child in &self.children {
        let child_sizes = child.compute_intrinsic_sizes();
        sizes.min_content = sizes.min_content.max(child_sizes.min_content);
        sizes.max_content = sizes.max_content.max(child_sizes.max_content);
    }
    sizes
}

// Pass 2: Layout with known available size
fn layout(&mut self, available: Size) -> Vec<Fragment> {
    // Now we know our size, can layout children
    ...
}
```

**Adopt for all layout implementations.**

### Pattern: Containing Block Abstraction

Servo passes containing block information down:

```rust
struct ContainingBlock {
    size: Size,
    writing_mode: WritingMode,
    // ... other properties
}

fn layout_children(&self, cb: &ContainingBlock) -> Vec<Fragment> {
    for child in &self.children {
        child.layout(cb);
    }
}
```

**Adopt for W2-W5 layout tasks.**

### Pattern: Fragment Factory

Servo uses builder pattern for fragments:

```rust
Fragment::new()
    .position(Point::new(x, y))
    .size(Size::new(width, height))
    .source_box(box_ref)
    .build()
```

**Consider for fragment creation.**

## Servo Patterns to Avoid

### Anti-Pattern: Over-abstraction

Servo sometimes has too many abstraction layers (4-5 levels of indirection).

**For FastRender:** Keep it simpler, max 2-3 levels.

### Anti-Pattern: Complex Lifetime Management

Some Servo code has very complex lifetime annotations due to performance optimizations.

**For FastRender:** Prefer Arc/Rc over complex lifetimes. Optimize later if needed.

## Performance Insights

### Servo's Optimization Strategies

1. **Parallel layout**: Uses Rayon for parallelizing subtrees
2. **Incremental layout**: Caches layout results, recomputes only changed subtrees
3. **Memory pools**: Reuses fragment allocations

**For FastRender V2:**
- Don't optimize prematurely
- Implement correct first
- Parallel layout is Wave 6+ (W6.T08-W6.T10)

### Memory Usage Patterns

Servo's fragment tree can be large (millions of fragments for complex pages).

**Recommendation:** Consider:
- Using indices instead of pointers
- Compacting fragment representation
- Arena allocation for fragments

But implement basic version first in Waves 2-5.

## Recommendations by Task

### For W2.T07 (FormattingContext trait):

- Use enum dispatch pattern, not trait objects
- Include these layout modes: Block, Inline, Table (Flex in later wave)
- Common interface: `layout(containing_block) -> Vec<Fragment>`
- Store mode-specific data in enum variants

**Code structure:**
```rust
enum FormattingContext {
    Block(BlockFormattingContext),
    Inline(InlineFormattingContext),
    Table(TableFormattingContext),
}
```

### For W3.T06 (Table Layout):

- Create explicit `TableGrid` structure
- Implement fixed and auto layout as separate functions
- Two-pass auto layout: constraints → distribution
- Handle colspan with proportional distribution
- Test with Servo's edge cases

**Data structure:**
```rust
struct TableGrid {
    columns: Vec<ColumnTrack>,
    rows: Vec<RowTrack>,
    cells: Vec<Vec<Option<CellRef>>>,
}
```

### For W4.T12 (Inline Layout):

- Linearize inline boxes first
- Streaming line breaking algorithm
- Track text ranges in fragments
- Handle 1:N box-to-fragment mapping

**Algorithm structure:**
```rust
fn layout_inline(ifc: &InlineFormattingContext) -> Vec<LineFragment> {
    let items = linearize_inline_boxes(&ifc.boxes);
    break_into_lines(&items, ifc.width)
}
```

## Open Questions

### Question 1: How does Servo handle deeply nested tables?

**Context:** Tables inside table cells can have complex interactions
**Finding:** Servo treats each table as independent formatting context
**Resolution:** Each nested table layouts separately with its cell as containing block

### Question 2: Performance of fragment tree for large documents

**Context:** Million+ fragment pages could have memory issues
**Finding:** Servo uses arena allocation and compact representations
**Resolution:** Implement basic version first, optimize in Wave 6 if needed

## Test Cases from Servo

Extracted interesting test cases to replicate:

1. **Table colspan edge case:**
   ```html
   <table>
     <tr><td colspan="3" width="300px"></td></tr>
     <tr><td>A</td><td>B</td><td>C</td></tr>
   </table>
   ```
   Expected: Columns distributed proportionally, not evenly

2. **Inline wrapping with nested tags:**
   ```html
   <span>Text <strong>with nested</strong> elements</span>
   ```
   Expected: Multiple fragments maintain tag structure

3. **Zero-sized containing block:**
   ```html
   <div style="width: 0"><table>...</table></div>
   ```
   Expected: Table uses min-content width

## References Studied

1. Servo layout_2020 source code
   - https://github.com/servo/servo/tree/main/components/layout_2020
   - Studied: flow/, table/, fragment_tree/, lib.rs

2. Servo architecture documentation
   - https://github.com/servo/servo/wiki/Design

3. Specific commits studied:
   - [List key commits that show architecture decisions]

---

**Research completed:** YYYY-MM-DD
**Time taken:** 8-12 hours
**Confidence level:** High - Servo patterns well understood
**Recommendation:** Adopt box/fragment separation, enum dispatch, explicit data structures
```

## Common Pitfalls to Avoid

### Pitfall 1: Surface-Level Code Reading

**Wrong:** Quickly browse files and assume understanding
**Right:** Trace execution paths, understand data flow, read related commits

Servo's code is complex. You need to understand **why** not just **what**.

### Pitfall 2: Copy-Pasting Without Understanding

**Wrong:** Copy Servo code patterns without understanding rationale
**Right:** Understand the problem being solved, then adapt pattern to FastRender

Servo has different constraints (browser-grade, parallel, etc.).

### Pitfall 3: Ignoring Commit History

**Wrong:** Only read current code
**Right:** Look at git history to understand why decisions were made

Commit messages often explain architecture choices.

### Pitfall 4: Not Extracting Code Examples

**Wrong:** Summarize in words only
**Right:** Include actual Servo code snippets with explanations

Concrete code is more valuable than abstract descriptions.

### Pitfall 5: Forgetting the Goal

**Wrong:** Get lost in Servo details, forget what we need for FastRender
**Right:** Always connect findings to Wave 2-5 implementation tasks

This research must be **actionable** for downstream tasks.

## Verification Checklist

Before marking research complete:

- [ ] Studied Servo's module structure and organization
- [ ] Documented box tree architecture with code examples
- [ ] Documented fragment tree architecture with code examples
- [ ] Analyzed FormattingContext pattern (enum vs trait)
- [ ] Traced table layout algorithm (fixed and auto)
- [ ] Traced inline layout algorithm (linearization and line breaking)
- [ ] Extracted 30+ code snippets from Servo with explanations
- [ ] Documented patterns to adopt (5+ patterns)
- [ ] Documented anti-patterns to avoid (3+ patterns)
- [ ] Created recommendations for W2.T07
- [ ] Created recommendations for W3.T06
- [ ] Created recommendations for W4.T12
- [ ] Research document is 3000-4000 words
- [ ] Notes file complete with all sections
- [ ] Code examples are actual Servo code, not pseudocode

## Time Tracking

Expected breakdown:
- **Module structure overview:** 1-2 hours
- **Box tree architecture study:** 2-3 hours
- **FormattingContext design analysis:** 2-3 hours
- **Table layout deep dive:** 2-3 hours
- **Inline layout deep dive:** 2-3 hours
- **Pattern synthesis and documentation:** 1-2 hours
- **Total:** 8-12 hours

If taking longer than 12 hours, focus on breadth over depth. Goal is actionable patterns, not complete understanding of every line.

## Getting Help

If confused by Servo code:

1. **Read file-level documentation**: Most files have module docs at top
2. **Check git blame**: See when code was added and read commit message
3. **Look for related tests**: Tests show how code is meant to be used
4. **Search Servo wiki**: Architecture decisions are often documented
5. **Compare with spec**: Understand what spec requires, then see how Servo implements

Remember: Servo is a production browser engine with 10+ years of development. It's okay if not everything makes sense. Extract what's useful for FastRender V2.
