---
task_id: "W1.T07"
title: "Create Project Structure"
wave: 1
estimated_hours: 2-3
depends_on: []
inputs: []
outputs:
  - "src/lib.rs"
  - "src/tree/mod.rs"
  - "src/layout/mod.rs"
  - "src/style/mod.rs"
  - "src/text/mod.rs"
  - "src/paint/mod.rs"
  - "Cargo.toml"
  - "docs/tasks/notes/W1.T07-notes.md"
skills_required:
  - "Rust module system"
  - "Project organization"
  - "Documentation"
context_files:
  - "docs/core/type-system.md"
  - "docs/tasks/TASK_TEMPLATE.md"
verification:
  - "cargo build"
  - "cargo test"
  - "cargo doc --no-deps"
---

# Create Project Structure

## Context

Every Rust project needs a well-organized module hierarchy to support long-term growth and maintainability. A rendering engine is particularly complex, with distinct subsystems for DOM trees, style computation, layout algorithms, text shaping, and painting. Each subsystem needs its own module with clear boundaries.

In FastRender V2, we're rebuilding from scratch with a proper architecture. The project structure is a Wave 1 foundation task, meaning it has **no dependencies** and establishes the organizational framework for all future development.

### Background

**Rust Module System:**
- **Modules**: Organize code into logical units (`mod`)
- **Visibility**: Control what's public vs private (`pub`)
- **Re-exports**: Provide ergonomic APIs (`pub use`)
- **Module files**: Two patterns: `foo.rs` or `foo/mod.rs`

**FastRender Module Hierarchy:**
```
fastrender/
├── src/
│   ├── lib.rs              # Crate root, public API
│   ├── geometry.rs         # Core geometric types (already exists)
│   ├── error.rs            # Error types (already exists)
│   ├── tree/               # DOM and box tree structures
│   │   └── mod.rs
│   ├── layout/             # Layout algorithms
│   │   └── mod.rs
│   ├── style/              # CSS cascade and computed styles
│   │   └── mod.rs
│   ├── text/               # Text shaping and line breaking
│   │   └── mod.rs
│   └── paint/              # Painting and rasterization
│       └── mod.rs
```

### Why This Matters

Without a clear module structure, we cannot:
- Organize code logically as the codebase grows
- Provide a clean public API for library users
- Enforce module boundaries and reduce coupling
- Navigate the codebase efficiently
- Onboard new contributors quickly

Every task in Waves 2-6 depends on this organizational structure. Get it wrong and we'll have circular dependencies and spaghetti imports.

## Prerequisites

### Required Knowledge
- **Rust basics**: Modules, visibility, paths
- **Rust module system**: Understanding mod.rs vs file.rs patterns
- **Project organization**: Separating concerns into cohesive modules
- **Documentation**: Writing module-level rustdoc

### Required Reading
1. **The Rust Programming Language, Chapter 7**: Managing Growing Projects with Packages, Crates, and Modules
2. **Rust API Guidelines - Module Organization**: https://rust-lang.github.io/api-guidelines/organization.html
3. **Cargo Book - Package Layout**: https://doc.rust-lang.org/cargo/guide/project-layout.html

## Inputs

### From Dependencies

**None** - This is a Wave 1 task with no dependencies.

### Existing Code

The project already has some basic structure:
- `src/lib.rs` - Already declares some modules
- `src/geometry.rs` - Core geometry types (from W1.T01)
- `src/error.rs` - Error types (from W1.T02)
- `Cargo.toml` - Basic package metadata

We'll be expanding and organizing this structure.

## Objectives

### Primary Goals

1. **Organize module hierarchy**: Create clear separation between subsystems
2. **Create module stub files**: All `mod.rs` files with documentation
3. **Update src/lib.rs**: Declare all modules and set up re-exports
4. **Update Cargo.toml**: Add complete metadata and organize dependencies
5. **Document module organization**: Clear rustdoc explaining the architecture

### Success Criteria

- [ ] All module directories created: `tree/`, `layout/`, `style/`, `text/`, `paint/`
- [ ] All `mod.rs` files have module-level documentation
- [ ] `src/lib.rs` declares all modules and re-exports key types
- [ ] `Cargo.toml` has complete metadata (authors, description, license, etc.)
- [ ] `Cargo.toml` dependencies organized with comments
- [ ] Project builds: `cargo build`
- [ ] Tests pass: `cargo test`
- [ ] Documentation generates: `cargo doc --no-deps`
- [ ] No clippy warnings: `cargo clippy -- -D warnings`
- [ ] Notes file created with all sections filled

## Implementation Guide

### Step 1: Create Module Directories (Estimated: 15min)

**What to do:**
1. Create directories for each major subsystem
2. Create `mod.rs` stub in each directory
3. Verify directory structure is correct

**Commands:**

```bash
# Navigate to src directory
cd /home/user/fastrender/src

# Create module directories
mkdir -p tree
mkdir -p layout
mkdir -p style
mkdir -p text
mkdir -p paint

# Verify structure
ls -la
```

**Expected output:**
```
drwxr-xr-x tree/
drwxr-xr-x layout/
drwxr-xr-x style/
drwxr-xr-x text/
drwxr-xr-x paint/
```

### Step 2: Create tree/mod.rs (Estimated: 20min)

**What to do:**
1. Create `src/tree/mod.rs` with module documentation
2. Add placeholder comment for future submodules
3. Document the tree subsystem's responsibility

**Code:**

Create `src/tree/mod.rs`:

```rust
//! DOM and box tree structures
//!
//! This module contains the tree data structures that represent the document:
//! - **DOM tree**: The parsed HTML document structure
//! - **Box tree**: The CSS box tree generated from the DOM
//! - **Fragment tree**: The positioned, sized fragments ready for painting
//!
//! # Architecture
//!
//! FastRender uses a three-tree architecture:
//!
//! 1. **DOM Tree** (`DomNode`):
//!    - Represents the parsed HTML document
//!    - Immutable after parsing
//!    - Contains element names, attributes, text content
//!
//! 2. **Box Tree** (`BoxNode`):
//!    - Generated from DOM + computed styles
//!    - Represents CSS boxes before layout
//!    - Anonymous boxes are created here
//!    - Not yet positioned or sized
//!
//! 3. **Fragment Tree** (`FragmentNode`):
//!    - Generated by layout algorithms
//!    - Fully positioned and sized
//!    - Ready for painting
//!    - Contains final coordinates and dimensions
//!
//! # Module Organization
//!
//! This module will contain:
//! - `dom.rs` - DOM node types
//! - `box_node.rs` - Box tree types
//! - `fragment.rs` - Fragment tree types
//!
//! # Example
//!
//! ```rust,ignore
//! use fastrender::tree::{DomNode, BoxNode, FragmentNode};
//!
//! // Parse HTML -> DOM tree
//! let dom_tree = parse_html("<div>Hello</div>");
//!
//! // Generate boxes -> Box tree
//! let box_tree = generate_boxes(&dom_tree, &styles);
//!
//! // Run layout -> Fragment tree
//! let fragment_tree = layout(&box_tree, viewport_size);
//!
//! // Paint fragments
//! paint(&fragment_tree);
//! ```

// Module declarations will be added in Wave 2
// pub mod dom;
// pub mod box_node;
// pub mod fragment;
```

### Step 3: Create layout/mod.rs (Estimated: 20min)

**What to do:**
1. Create `src/layout/mod.rs` with module documentation
2. Document layout subsystem responsibilities
3. List future layout algorithm modules

**Code:**

Create `src/layout/mod.rs`:

```rust
//! Layout algorithms
//!
//! This module contains all CSS layout algorithms that transform the box tree
//! into a positioned fragment tree.
//!
//! # Supported Layout Modes
//!
//! FastRender supports all major CSS layout modes:
//!
//! - **Block Layout**: Vertical stacking of block-level boxes
//! - **Inline Layout**: Horizontal flow of inline-level boxes with line breaking
//! - **Flex Layout**: Flexbox container layout (delegated to Taffy)
//! - **Grid Layout**: Grid container layout (delegated to Taffy)
//! - **Table Layout**: Table, row, and cell layout
//! - **Positioned Layout**: Absolute and fixed positioning
//!
//! # Architecture
//!
//! Layout is performed in a top-down, recursive tree walk:
//!
//! 1. **Box Generation**: Create anonymous boxes as needed
//! 2. **Size Computation**: Calculate intrinsic and definite sizes
//! 3. **Positioning**: Determine fragment positions
//! 4. **Fragment Creation**: Generate positioned fragments
//!
//! # Module Organization
//!
//! This module will contain:
//! - `block.rs` - Block layout algorithm
//! - `inline.rs` - Inline layout and line breaking
//! - `flex.rs` - Flexbox integration with Taffy
//! - `grid.rs` - Grid integration with Taffy
//! - `table.rs` - Table layout algorithm
//! - `positioned.rs` - Absolute/fixed positioning
//! - `context.rs` - Layout context shared across algorithms
//!
//! # Example
//!
//! ```rust,ignore
//! use fastrender::layout::LayoutContext;
//! use fastrender::geometry::Size;
//!
//! let viewport = Size::new(1024.0, 768.0);
//! let mut ctx = LayoutContext::new(viewport);
//!
//! // Run layout on box tree root
//! let fragment_tree = ctx.layout(&box_tree_root);
//! ```

// Module declarations will be added in Wave 2+
// pub mod block;
// pub mod inline;
// pub mod flex;
// pub mod grid;
// pub mod table;
// pub mod positioned;
// pub mod context;
```

### Step 4: Create style/mod.rs (Estimated: 20min)

**What to do:**
1. Create `src/style/mod.rs` with module documentation
2. Document style subsystem responsibilities
3. List cascade, computed styles, and property modules

**Code:**

Create `src/style/mod.rs`:

```rust
//! CSS style computation and cascade
//!
//! This module handles CSS parsing, selector matching, cascade resolution,
//! and computed style generation.
//!
//! # Responsibilities
//!
//! - **Parsing**: Parse CSS stylesheets into rule trees
//! - **Matching**: Match CSS selectors against DOM nodes
//! - **Cascade**: Resolve specificity, importance, and origin
//! - **Inheritance**: Propagate inherited properties
//! - **Computation**: Convert specified values to computed values
//!
//! # Architecture
//!
//! Style computation happens in phases:
//!
//! 1. **Parse**: CSS text → `Stylesheet` with `CssRule`s
//! 2. **Match**: For each DOM node, find matching rules
//! 3. **Cascade**: Resolve conflicts, apply specificity
//! 4. **Compute**: Convert relative/percentage values to absolute
//! 5. **Inherit**: Propagate inherited properties to children
//!
//! # Module Organization
//!
//! This module will contain:
//! - `stylesheet.rs` - Stylesheet and rule structures
//! - `selector.rs` - Selector matching logic
//! - `cascade.rs` - Cascade resolution
//! - `computed.rs` - ComputedStyle type
//! - `properties/` - Individual CSS property definitions
//!   - `display.rs`, `position.rs`, `color.rs`, etc.
//!
//! # Example
//!
//! ```rust,ignore
//! use fastrender::style::{Stylesheet, ComputedStyle};
//!
//! // Parse CSS
//! let stylesheet = Stylesheet::parse("div { color: red; }");
//!
//! // Compute styles for a DOM node
//! let computed = ComputedStyle::compute(&dom_node, &stylesheet);
//!
//! assert_eq!(computed.color(), Color::rgb(255, 0, 0));
//! ```

// Module declarations will be added in Wave 2+
// pub mod stylesheet;
// pub mod selector;
// pub mod cascade;
// pub mod computed;
// pub mod properties;
```

### Step 5: Create text/mod.rs (Estimated: 20min)

**What to do:**
1. Create `src/text/mod.rs` with module documentation
2. Document text shaping and line breaking
3. List font, shaping, and bidi modules

**Code:**

Create `src/text/mod.rs`:

```rust
//! Text shaping, font handling, and line breaking
//!
//! This module handles all text-related operations:
//! - Font loading and fallback
//! - Text shaping (glyph generation)
//! - Bidirectional text (bidi) reordering
//! - Line breaking and word wrapping
//!
//! # Responsibilities
//!
//! - **Font Loading**: Load system fonts, parse font files
//! - **Font Matching**: Find fonts matching CSS font-family, weight, style
//! - **Shaping**: Convert Unicode text to positioned glyphs
//! - **Bidi**: Handle right-to-left and mixed-direction text
//! - **Line Breaking**: Find line break opportunities, wrap text
//!
//! # Architecture
//!
//! Text processing pipeline:
//!
//! 1. **Font Resolution**: Match CSS font properties to actual fonts
//! 2. **Bidi Analysis**: Analyze Unicode bidirectional properties
//! 3. **Shaping**: Run HarfBuzz (via rustybuzz) to get glyphs
//! 4. **Line Breaking**: Find break opportunities using UAX #14
//! 5. **Fragment Creation**: Create InlineTextFragment for each run
//!
//! # Module Organization
//!
//! This module will contain:
//! - `font.rs` - Font loading and database
//! - `shaper.rs` - Text shaping integration
//! - `bidi.rs` - Bidirectional text handling
//! - `linebreak.rs` - Line breaking algorithm
//! - `run.rs` - Text run representation
//!
//! # Example
//!
//! ```rust,ignore
//! use fastrender::text::{FontDatabase, Shaper};
//!
//! let font_db = FontDatabase::load_system_fonts();
//! let shaper = Shaper::new(&font_db);
//!
//! let shaped = shaper.shape("Hello, world!", &computed_style);
//! for glyph in shaped.glyphs() {
//!     println!("Glyph {} at ({}, {})", glyph.id, glyph.x, glyph.y);
//! }
//! ```

// Module declarations will be added in Wave 3+
// pub mod font;
// pub mod shaper;
// pub mod bidi;
// pub mod linebreak;
// pub mod run;
```

### Step 6: Create paint/mod.rs (Estimated: 20min)

**What to do:**
1. Create `src/paint/mod.rs` with module documentation
2. Document painting and rasterization
3. List painter, canvas, and display list modules

**Code:**

Create `src/paint/mod.rs`:

```rust
//! Painting and rasterization
//!
//! This module handles converting the positioned fragment tree into pixels.
//!
//! # Responsibilities
//!
//! - **Display List**: Build a display list from fragments
//! - **Stacking Context**: Implement CSS stacking context and z-index
//! - **Painting**: Draw backgrounds, borders, text, images
//! - **Rasterization**: Convert vector graphics to pixels
//!
//! # Architecture
//!
//! Painting happens in phases:
//!
//! 1. **Display List Building**: Walk fragment tree, create display items
//! 2. **Stacking Context Sort**: Order items by z-index and stacking rules
//! 3. **Rasterization**: Draw each display item to canvas
//!
//! # Painting Order
//!
//! CSS defines a specific painting order (CSS 2.1 Appendix E):
//!
//! 1. Background colors and images
//! 2. Borders
//! 3. Child stacking contexts (negative z-index)
//! 4. In-flow non-positioned blocks
//! 5. Floats
//! 6. In-flow inline content
//! 7. Child stacking contexts (z-index: 0 and auto)
//! 8. Positioned descendants (positive z-index)
//!
//! # Module Organization
//!
//! This module will contain:
//! - `display_list.rs` - Display list building
//! - `stacking.rs` - Stacking context implementation
//! - `painter.rs` - Main painter that draws to canvas
//! - `background.rs` - Background painting
//! - `border.rs` - Border painting
//! - `text_paint.rs` - Text rendering
//! - `image_paint.rs` - Image rendering
//!
//! # Example
//!
//! ```rust,ignore
//! use fastrender::paint::Painter;
//! use fastrender::geometry::Size;
//!
//! let size = Size::new(800.0, 600.0);
//! let mut painter = Painter::new(size);
//!
//! painter.paint(&fragment_tree);
//!
//! let image = painter.into_image();
//! image.save_png("output.png");
//! ```

// Module declarations will be added in Wave 4+
// pub mod display_list;
// pub mod stacking;
// pub mod painter;
// pub mod background;
// pub mod border;
// pub mod text_paint;
// pub mod image_paint;
```

### Step 7: Update src/lib.rs (Estimated: 30min)

**What to do:**
1. Update module declarations
2. Organize re-exports for ergonomic API
3. Add crate-level documentation
4. Group modules logically

**Code:**

Update `src/lib.rs`:

```rust
//! FastRender: High-performance Rust HTML/CSS to image renderer
//!
//! FastRender is a rendering engine that converts HTML and CSS into images.
//! It implements the CSS 2.1 specification with select CSS3 features.
//!
//! # Architecture
//!
//! FastRender uses a pipeline architecture with distinct phases:
//!
//! ```text
//! HTML/CSS → Parsing → Styling → Layout → Painting → Image
//! ```
//!
//! ## Major Subsystems
//!
//! - **tree**: DOM, box tree, and fragment tree structures
//! - **style**: CSS parsing, cascade, and computed styles
//! - **layout**: Layout algorithms (block, inline, flex, grid, table)
//! - **text**: Text shaping, font handling, line breaking
//! - **paint**: Painting and rasterization
//!
//! ## Foundation Types
//!
//! - **geometry**: Core geometric primitives (Point, Size, Rect, EdgeOffsets)
//! - **error**: Comprehensive error types for all subsystems
//!
//! # Quick Start
//!
//! ```rust,ignore
//! use fastrender::{Renderer, RenderOptions};
//!
//! let html = r#"
//!     <!DOCTYPE html>
//!     <html>
//!         <body>
//!             <h1>Hello, FastRender!</h1>
//!         </body>
//!     </html>
//! "#;
//!
//! let renderer = Renderer::new();
//! let image = renderer.render(html, RenderOptions::default())?;
//! image.save_png("output.png")?;
//! ```
//!
//! # Feature Flags
//!
//! Currently FastRender has no feature flags - all features are enabled by default.
//!
//! # CSS Support
//!
//! FastRender implements:
//! - CSS 2.1 (full specification)
//! - Flexbox (CSS Flexible Box Layout Module Level 1)
//! - Grid (CSS Grid Layout Module Level 1)
//! - Select CSS3 features (border-radius, box-shadow, opacity)
//!
//! # Performance
//!
//! FastRender is optimized for:
//! - Single-threaded rendering (no thread synchronization overhead)
//! - Minimal allocations (use of arena allocators where beneficial)
//! - Cache-friendly data structures (struct-of-arrays where appropriate)

// ============================================================================
// Foundation Types
// ============================================================================

pub mod geometry;
pub mod error;

// ============================================================================
// Tree Structures
// ============================================================================

pub mod tree;

// ============================================================================
// Style System
// ============================================================================

pub mod style;

// ============================================================================
// Layout System
// ============================================================================

pub mod layout;

// ============================================================================
// Text System
// ============================================================================

pub mod text;

// ============================================================================
// Paint System
// ============================================================================

pub mod paint;

// ============================================================================
// Legacy Modules (to be refactored into above structure)
// ============================================================================

// These modules exist from FastRender V1 and will be gradually
// refactored into the new architecture above
pub mod css;
pub mod dom;
pub mod image_loader;
pub mod image_output;
pub mod renderer;

// ============================================================================
// Public API Re-exports
// ============================================================================

// Error types
pub use error::{Error, Result};

// Geometry types
pub use geometry::{EdgeOffsets, Point, Rect, Size};

// Renderer (main entry point)
pub use renderer::{ImageFormat, RenderOptions, Renderer};

// Re-export tree types (will be added in Wave 2)
// pub use tree::{BoxNode, DomNode, FragmentNode};

// Re-export style types (will be added in Wave 2)
// pub use style::{ComputedStyle, Display, Position};
```

### Step 8: Update Cargo.toml (Estimated: 20min)

**What to do:**
1. Ensure all metadata is complete
2. Organize dependencies with comments
3. Group related dependencies together
4. Verify all versions are current

**Code:**

Review and update `Cargo.toml` if needed:

```toml
[package]
name = "fastrender"
version = "0.1.0"
edition = "2021"
authors = ["FastRender Contributors"]
description = "High-performance Rust HTML/CSS to image renderer"
license = "MIT OR Apache-2.0"
repository = "https://github.com/fastrender/fastrender"
keywords = ["html", "css", "renderer", "image", "screenshot"]
categories = ["rendering", "graphics", "web-programming"]
readme = "README.md"
rust-version = "1.70"  # Minimum supported Rust version

[dependencies]
# ============================================================================
# HTML/CSS Parsing
# ============================================================================

# HTML parsing
html5ever = "0.35"
markup5ever_rcdom = "0.35"

# CSS parsing - using Mozilla's battle-tested parsers
cssparser = "0.35"
selectors = "0.32"
precomputed-hash = "0.1"

# ============================================================================
# Layout
# ============================================================================

# Layout engine - vendored locally to fix grid auto-placement
taffy = { path = "vendor/taffy" }

# ============================================================================
# Text Shaping and Fonts
# ============================================================================

# Text shaping
rustybuzz = "0.20"
ttf-parser = "0.25"
fontdb = "0.23"

# Unicode text processing
unicode-linebreak = "0.1"
unicode-bidi = "0.3"

# ============================================================================
# 2D Graphics and Rendering
# ============================================================================

# 2D rendering backend
tiny-skia = "0.11"

# Image encoding/decoding
image = { version = "0.25", default-features = false, features = ["png", "jpeg", "webp"] }

# SVG rendering
resvg = "0.43"

# ============================================================================
# Utilities
# ============================================================================

# CSS color parsing
csscolorparser = "0.6"

# URL handling
url = "2.5"
urlencoding = "2.1"

# Error handling
thiserror = "1.0"

# HTTP client for loading resources
ureq = "3.1"

# Base64 encoding for data URLs
base64 = "0.22"

# ============================================================================
# Development Dependencies
# ============================================================================

[dev-dependencies]
criterion = "0.5"

[[bench]]
name = "render_benchmark"
harness = false

# ============================================================================
# Release Profile Optimization
# ============================================================================

[profile.release]
opt-level = 3
lto = true
codegen-units = 1
strip = true

# ============================================================================
# Workspace Configuration
# ============================================================================

# No workspace currently - single crate project
```

The existing `Cargo.toml` is already well-organized. You may want to add the `readme` and `rust-version` fields if they're missing.

### Step 9: Verification (Estimated: 15min)

**What to do:**
1. Build the project to ensure everything compiles
2. Run tests to ensure nothing broke
3. Generate documentation to verify module docs
4. Check for clippy warnings

**Commands:**

```bash
# Build the project
cargo build

# Run all tests
cargo test

# Generate documentation
cargo doc --no-deps --open

# Check for warnings
cargo clippy -- -D warnings

# Format check
cargo fmt --check
```

**Expected results:**
- Build succeeds with no errors
- All tests pass
- Documentation generates successfully with new module docs
- No clippy warnings
- Code is properly formatted

## Testing Requirements

### Compilation Test

The primary test is that the project builds:

```bash
cargo build
```

**Expected output:**
```
   Compiling fastrender v0.1.0 (/home/user/fastrender)
    Finished dev [unoptimized + debuginfo] target(s) in 5.2s
```

### Module Structure Test

Verify module structure is correct:

```bash
# List all modules
cargo modules tree

# Or manually verify with ls
ls -R src/
```

**Expected structure:**
```
src/:
lib.rs geometry.rs error.rs tree/ layout/ style/ text/ paint/

src/tree/:
mod.rs

src/layout/:
mod.rs

src/style/:
mod.rs

src/text/:
mod.rs

src/paint/:
mod.rs
```

### Documentation Test

Generate and view documentation:

```bash
cargo doc --no-deps --open
```

**Verify:**
- All modules appear in the documentation
- Module-level docs render correctly
- Crate-level docs appear on the main page

## Output Artifacts

### Code Files

1. **`src/lib.rs`**
   - Updated with organized module declarations
   - Comprehensive crate-level documentation
   - Clean re-export structure

2. **`src/tree/mod.rs`**
   - Module documentation explaining three-tree architecture
   - Placeholder for future submodules

3. **`src/layout/mod.rs`**
   - Module documentation explaining layout algorithms
   - List of planned layout modes

4. **`src/style/mod.rs`**
   - Module documentation explaining cascade and computation
   - CSS property organization

5. **`src/text/mod.rs`**
   - Module documentation explaining text processing pipeline
   - Font, shaping, and bidi modules

6. **`src/paint/mod.rs`**
   - Module documentation explaining painting order
   - Display list and rasterization

7. **`Cargo.toml`** (updated if needed)
   - Complete metadata
   - Organized dependency groups with comments

### Notes File

Create: **`docs/tasks/notes/W1.T07-notes.md`**

Use this template (fill in after completion):

```markdown
# Task W1.T07 Output Notes

## Implementation Summary

Created comprehensive module structure for FastRender V2:
- **tree/**: DOM, box tree, and fragment tree structures
- **layout/**: Layout algorithms (block, inline, flex, grid, table)
- **style/**: CSS cascade and computed styles
- **text/**: Text shaping, fonts, and line breaking
- **paint/**: Painting and rasterization

All modules have stub `mod.rs` files with comprehensive documentation.

## Module Organization

### Tree Module (`src/tree/mod.rs`)

**Responsibility**: DOM and box tree structures

**Future submodules**:
- `dom.rs` - DOM node types
- `box_node.rs` - Box tree types
- `fragment.rs` - Fragment tree types

**Wave 2 tasks**: W2.T01 (BoxNode), W2.T02 (DomNode), W2.T03 (FragmentNode)

### Layout Module (`src/layout/mod.rs`)

**Responsibility**: Layout algorithms

**Future submodules**:
- `block.rs` - Block layout
- `inline.rs` - Inline layout and line breaking
- `flex.rs` - Flexbox integration
- `grid.rs` - Grid integration
- `table.rs` - Table layout
- `positioned.rs` - Absolute/fixed positioning
- `context.rs` - Layout context

**Wave 3+ tasks**: Layout algorithm implementations

### Style Module (`src/style/mod.rs`)

**Responsibility**: CSS cascade and computed styles

**Future submodules**:
- `stylesheet.rs` - Stylesheet structures
- `selector.rs` - Selector matching
- `cascade.rs` - Cascade resolution
- `computed.rs` - ComputedStyle type
- `properties/` - CSS property definitions

**Wave 2 tasks**: W2.T05 (ComputedStyle), property enums

### Text Module (`src/text/mod.rs`)

**Responsibility**: Text shaping and font handling

**Future submodules**:
- `font.rs` - Font loading
- `shaper.rs` - Text shaping
- `bidi.rs` - Bidirectional text
- `linebreak.rs` - Line breaking
- `run.rs` - Text run representation

**Wave 3+ tasks**: Text processing pipeline

### Paint Module (`src/paint/mod.rs`)

**Responsibility**: Painting and rasterization

**Future submodules**:
- `display_list.rs` - Display list building
- `stacking.rs` - Stacking contexts
- `painter.rs` - Main painter
- `background.rs` - Background painting
- `border.rs` - Border painting
- `text_paint.rs` - Text rendering
- `image_paint.rs` - Image rendering

**Wave 4+ tasks**: Painting implementation

## Decisions Made

### Decision 1: Directory-Based Modules

**Choice**: Use `module/mod.rs` pattern instead of `module.rs`
**Rationale**:
- Allows submodules to be added easily
- Each subsystem can grow without restructuring
- Clear directory boundaries
- Matches common Rust project conventions

**Impact**: Future submodules just need to be added as files in the directory

### Decision 2: Comprehensive Module Documentation

**Choice**: Write detailed module-level docs even before implementation
**Rationale**:
- Serves as a roadmap for future tasks
- Documents architecture decisions early
- Helps contributors understand module boundaries
- Provides context for code review

**Impact**: Contributors can understand system architecture before code exists

### Decision 3: Re-export Key Types in lib.rs

**Choice**: Re-export commonly-used types at crate root
**Rationale**:
- More ergonomic API: `use fastrender::Point` vs `use fastrender::geometry::Point`
- Follows Rust API guidelines
- Hides internal module organization from public API
- Makes breaking changes easier (can move modules without breaking users)

**Impact**: Users have a simpler import story

## Project Structure

```
fastrender/
├── src/
│   ├── lib.rs              # Crate root with re-exports
│   ├── geometry.rs         # Geometric types (Wave 1)
│   ├── error.rs            # Error types (Wave 1)
│   ├── tree/
│   │   └── mod.rs          # Tree structures (stub)
│   ├── layout/
│   │   └── mod.rs          # Layout algorithms (stub)
│   ├── style/
│   │   └── mod.rs          # Style system (stub)
│   ├── text/
│   │   └── mod.rs          # Text processing (stub)
│   ├── paint/
│   │   └── mod.rs          # Painting (stub)
│   ├── css.rs              # Legacy (to be refactored)
│   ├── dom.rs              # Legacy (to be refactored)
│   ├── image_loader.rs     # Legacy (to be refactored)
│   ├── image_output.rs     # Legacy (to be refactored)
│   └── renderer.rs         # Legacy (to be refactored)
├── Cargo.toml              # Updated with complete metadata
└── docs/tasks/notes/
    └── W1.T07-notes.md     # This file
```

## Recommendations for Downstream Tasks

### For Wave 2 Type Implementation Tasks:

- **W2.T01 (BoxNode)**: Create `src/tree/box_node.rs`, add `pub mod box_node;` to `src/tree/mod.rs`
- **W2.T02 (DomNode)**: Create `src/tree/dom.rs`, add `pub mod dom;` to `src/tree/mod.rs`
- **W2.T03 (FragmentNode)**: Create `src/tree/fragment.rs`, add `pub mod fragment;` to `src/tree/mod.rs`
- **W2.T05 (ComputedStyle)**: Create `src/style/computed.rs`, add `pub mod computed;` to `src/style/mod.rs`

### For Wave 3+ Algorithm Tasks:

- Follow the same pattern: create submodule file, update parent mod.rs
- Add public exports in `src/lib.rs` for key types
- Update module-level documentation in mod.rs

## Open Questions

**Q1**: Should legacy modules (css, dom, renderer) be marked as deprecated?
**A**: Not yet - they're still being used. We'll refactor them incrementally as new modules are implemented.

**Q2**: Should we use a workspace structure for future plugins?
**A**: Not needed now, but could be added later if we want extensibility.

## Code Quality

- ✅ Project builds successfully
- ✅ All tests pass
- ✅ Documentation generates without errors
- ✅ No clippy warnings
- ✅ Code is formatted
- ✅ All modules have comprehensive documentation
- ✅ Clear separation of concerns

## References Used

1. The Rust Programming Language, Chapter 7 - Module System
2. Rust API Guidelines - Organization
3. Cargo Book - Package Layout
4. WebRender source code - Module organization patterns

---

**Task completed:** [DATE]
**Time taken:** [X] hours
**Modules created:** 5 (tree, layout, style, text, paint)
```

## Common Pitfalls to Avoid

### Pitfall 1: Circular Dependencies

**Wrong:** Importing from sibling modules without going through parent
**Right:** Use parent module re-exports or carefully design module boundaries

Example of circular dependency problem:
```rust
// src/tree/box_node.rs
use crate::style::computed::ComputedStyle; // OK

// src/style/computed.rs
use crate::tree::box_node::BoxNode; // Creates circular dependency!
```

**Solution**: Use trait objects or separate shared types into a common module.

### Pitfall 2: Exposing Internal Implementation Details

**Wrong:** Making all submodules public
**Right:** Only expose what's needed in the public API

```rust
// Wrong - exposes implementation details
pub mod internal_module;

// Right - keep implementation private
mod internal_module;

// If needed externally, re-export specific items
pub use internal_module::PublicType;
```

### Pitfall 3: Inconsistent Module Patterns

**Wrong**: Mixing `mod.rs` and direct file patterns inconsistently
**Right**: Choose one pattern and stick to it

Use `module/mod.rs` for modules that will have submodules, use `module.rs` for single-file modules.

### Pitfall 4: Missing Module-Level Documentation

**Wrong**: Empty or minimal module docs
**Right**: Comprehensive module docs explaining purpose, architecture, and examples

Every module should answer:
- What is this module responsible for?
- How does it fit into the overall architecture?
- What are the key types/functions?
- How do I use it?

### Pitfall 5: Not Updating lib.rs Re-exports

**Wrong**: Creating new public types but not re-exporting them
**Right**: Add public types to lib.rs re-exports for ergonomic API

Users should be able to import common types from the crate root.

## Verification Checklist

Before marking task complete:

- [ ] All module directories created (tree, layout, style, text, paint)
- [ ] All mod.rs files created with comprehensive documentation
- [ ] src/lib.rs updated with module declarations and re-exports
- [ ] Cargo.toml has complete metadata
- [ ] Project builds: `cargo build`
- [ ] Tests pass: `cargo test`
- [ ] Documentation generates: `cargo doc --no-deps`
- [ ] No clippy warnings: `cargo clippy -- -D warnings`
- [ ] Code formatted: `cargo fmt`
- [ ] Notes file complete

## Time Tracking

Estimated breakdown:
- **Directory creation:** 15min
- **tree/mod.rs:** 20min
- **layout/mod.rs:** 20min
- **style/mod.rs:** 20min
- **text/mod.rs:** 20min
- **paint/mod.rs:** 20min
- **src/lib.rs update:** 30min
- **Cargo.toml review:** 20min
- **Verification:** 15min
- **Total:** 2-3 hours

## Getting Help

If stuck:

1. **Rust Book Chapter 7**: Module system fundamentals
2. **Rust API Guidelines**: Best practices for module organization
3. **Cargo Book**: Package layout conventions
4. **Example projects**: Look at well-organized Rust projects like tokio, serde, reqwest

Remember: This is an infrastructure task. The goal is to establish a clean foundation for all future work. Take time to get the organization right!
