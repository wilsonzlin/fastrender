---
task_id: "W1.T01"
title: "Implement Core Geometry Types (Point, Size, Rect, EdgeOffsets)"
wave: 1
estimated_hours: 4-6
depends_on: []
inputs: []
outputs:
  - "src/geometry.rs"
  - "outputs/notes/W1.T01-notes.md"
skills_required:
  - "Rust fundamentals"
  - "Basic 2D geometry"
  - "Testing"
context_files:
  - "docs/plan/01-type-system.md"
  - "docs/tasks/TASK_TEMPLATE.md"
verification:
  - "cargo test geometry"
  - "cargo clippy -- -D warnings"
  - "cargo fmt --check"
---

# Implement Core Geometry Types (Point, Size, Rect, EdgeOffsets)

## Context

Every rendering engine needs fundamental geometric primitives to represent positions, sizes, and rectangular regions. These types form the absolute foundation of the layout and paint systems - they'll be used everywhere throughout the codebase.

In FastRender V2, we're rebuilding from scratch with a proper type system. The geometry types are Wave 1 foundation tasks, meaning they have **no dependencies** and must be completed before any other work can proceed.

### Background

**Geometry in CSS Layout:**
- **Point**: Represents a 2D coordinate in CSS pixel space (x, y)
- **Size**: Represents dimensions (width, height)
- **Rect**: An axis-aligned rectangle (origin point + size)
- **EdgeOffsets**: Four-sided offsets used for margin, padding, and border

All measurements in CSS are in "CSS pixels" which are logical pixels, not physical device pixels. A CSS pixel is defined as 1/96th of an inch, but this is an abstract unit that gets scaled by device pixel ratio.

**Key properties we need:**
- **Immutability-friendly**: Geometry types should be `Copy` where possible
- **Float precision**: Use `f32` for all values (CSS layout uses floating point)
- **Const constructors**: Enable compile-time constant creation
- **Zero values**: Provide convenient zero constants

### Why This Matters

Without these geometry types, we cannot:
- Represent where boxes are positioned (need Point)
- Represent how large boxes are (need Size)
- Represent box boundaries (need Rect)
- Represent margin/padding/border spacing (need EdgeOffsets)

Every single task in Waves 2-6 depends on these types. Get them wrong and we'll have to refactor hundreds of files later.

## Prerequisites

### Required Knowledge
- **Rust basics**: Structs, methods, traits, modules
- **Rust Copy vs Clone**: Understanding when to use each
- **Basic 2D geometry**: Coordinate systems, rectangles, intersection
- **Rust const fn**: For compile-time constant creation

### Required Reading
1. **The Rust Programming Language, Chapter 5**: Structs
2. **The Rust Programming Language, Chapter 10**: Traits
3. **CSS 2.1 Coordinate System**: https://www.w3.org/TR/CSS21/coords.html
   - Understand CSS pixel definition
   - Coordinate system is top-left origin, +x right, +y down

## Inputs

### From Dependencies

**None** - This is a Wave 1 task with no dependencies.

### Existing Code

**None** - This creates brand new files. However, you should check:
- `src/lib.rs` - Will need to add `pub mod geometry;`
- `Cargo.toml` - No new dependencies needed for basic geometry

## Objectives

### Primary Goals

1. **Implement Point type**: 2D coordinate with x, y fields
2. **Implement Size type**: 2D dimensions with width, height fields
3. **Implement Rect type**: Rectangle with origin (Point) and size (Size)
4. **Implement EdgeOffsets type**: Four-sided offsets (top, right, bottom, left)
5. **Add comprehensive tests**: Cover all methods and edge cases

### Success Criteria

- [ ] All four types implemented with full documentation
- [ ] All types derive `Debug, Clone, Copy, PartialEq`
- [ ] Zero constants provided for all types
- [ ] Const constructors provided where possible
- [ ] Rect has utility methods: `contains_point`, `intersects`, `union`, etc.
- [ ] EdgeOffsets has `horizontal()` and `vertical()` helper methods
- [ ] All tests pass: `cargo test geometry`
- [ ] Clippy passes with no warnings
- [ ] Rustfmt applied
- [ ] All public APIs have rustdoc comments with examples
- [ ] Notes file created with all sections filled

## Implementation Guide

### Step 1: Create the Geometry Module (Estimated: 30min)

**What to do:**
1. Create file: `src/geometry.rs`
2. Add module declaration to `src/lib.rs`
3. Set up module structure with documentation

**Code:**

First, update `src/lib.rs` to add the geometry module:

```rust
// Add this to src/lib.rs
pub mod geometry;

// Re-export common types
pub use geometry::{Point, Size, Rect, EdgeOffsets};
```

Then create `src/geometry.rs`:

```rust
//! Core geometry types for layout and painting
//!
//! This module provides fundamental geometric primitives used throughout
//! the rendering engine. All units are in CSS pixels unless otherwise noted.
//!
//! # CSS Pixels
//!
//! CSS pixels are logical units defined as 1/96th of an inch. They are
//! independent of device pixels and get scaled by the device pixel ratio.
//!
//! # Coordinate System
//!
//! The coordinate system has its origin at the top-left corner:
//! - Positive X extends to the right
//! - Positive Y extends downward
//!
//! This matches CSS's coordinate system as defined in CSS 2.1 Section 8.3.1.

use std::fmt;

// Types will be implemented in subsequent steps
```

### Step 2: Implement Point Type (Estimated: 1 hour)

**What to do:**
1. Define `Point` struct with x, y fields
2. Add const constructor and zero constant
3. Add utility methods
4. Write comprehensive rustdoc

**Implementation details:**

The `Point` type represents a 2D coordinate. Make it `Copy` since it's only two f32 values (8 bytes total).

**Example code:**

```rust
/// A 2D point in CSS pixel space
///
/// Represents a coordinate in the rendering surface's coordinate system.
/// The origin (0, 0) is at the top-left corner.
///
/// # Examples
///
/// ```
/// use fastrender::geometry::Point;
///
/// let p1 = Point::new(10.0, 20.0);
/// let p2 = Point::ZERO;
///
/// assert_eq!(p1.x, 10.0);
/// assert_eq!(p1.y, 20.0);
/// assert_eq!(p2, Point::new(0.0, 0.0));
/// ```
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Point {
    /// X coordinate (horizontal position, increases to the right)
    pub x: f32,
    /// Y coordinate (vertical position, increases downward)
    pub y: f32,
}

impl Point {
    /// The zero point at the origin (0, 0)
    pub const ZERO: Self = Self { x: 0.0, y: 0.0 };

    /// Creates a new point at the given coordinates
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::geometry::Point;
    ///
    /// let point = Point::new(100.0, 50.0);
    /// assert_eq!(point.x, 100.0);
    /// assert_eq!(point.y, 50.0);
    /// ```
    pub const fn new(x: f32, y: f32) -> Self {
        Self { x, y }
    }

    /// Translates this point by another point's coordinates
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::geometry::Point;
    ///
    /// let p1 = Point::new(10.0, 20.0);
    /// let p2 = Point::new(5.0, 3.0);
    /// let result = p1.translate(p2);
    ///
    /// assert_eq!(result, Point::new(15.0, 23.0));
    /// ```
    pub fn translate(self, other: Point) -> Self {
        Self {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }

    /// Computes the distance to another point
    ///
    /// Uses Euclidean distance formula: sqrt((x2-x1)² + (y2-y1)²)
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::geometry::Point;
    ///
    /// let p1 = Point::new(0.0, 0.0);
    /// let p2 = Point::new(3.0, 4.0);
    ///
    /// assert_eq!(p1.distance_to(p2), 5.0); // 3-4-5 triangle
    /// ```
    pub fn distance_to(self, other: Point) -> f32 {
        let dx = other.x - self.x;
        let dy = other.y - self.y;
        (dx * dx + dy * dy).sqrt()
    }
}

// Implement Display for better debug output
impl fmt::Display for Point {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "({}, {})", self.x, self.y)
    }
}
```

### Step 3: Implement Size Type (Estimated: 1 hour)

**What to do:**
1. Define `Size` struct with width, height fields
2. Add const constructor and zero constant
3. Add area() method
4. Add is_empty() method to check for zero size

**Example code:**

```rust
/// A 2D size in CSS pixels
///
/// Represents the dimensions of a rectangular region.
/// Both width and height are non-negative (though not enforced by the type).
///
/// # Examples
///
/// ```
/// use fastrender::geometry::Size;
///
/// let size = Size::new(100.0, 50.0);
/// assert_eq!(size.width, 100.0);
/// assert_eq!(size.height, 50.0);
/// assert_eq!(size.area(), 5000.0);
/// ```
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Size {
    /// Width (horizontal extent)
    pub width: f32,
    /// Height (vertical extent)
    pub height: f32,
}

impl Size {
    /// A size with zero width and height
    pub const ZERO: Self = Self {
        width: 0.0,
        height: 0.0,
    };

    /// Creates a new size with the given dimensions
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::geometry::Size;
    ///
    /// let size = Size::new(200.0, 100.0);
    /// assert_eq!(size.width, 200.0);
    /// assert_eq!(size.height, 100.0);
    /// ```
    pub const fn new(width: f32, height: f32) -> Self {
        Self { width, height }
    }

    /// Computes the area (width × height)
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::geometry::Size;
    ///
    /// let size = Size::new(10.0, 20.0);
    /// assert_eq!(size.area(), 200.0);
    /// ```
    pub fn area(self) -> f32 {
        self.width * self.height
    }

    /// Returns true if either width or height is zero
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::geometry::Size;
    ///
    /// assert!(Size::ZERO.is_empty());
    /// assert!(Size::new(0.0, 10.0).is_empty());
    /// assert!(!Size::new(10.0, 10.0).is_empty());
    /// ```
    pub fn is_empty(self) -> bool {
        self.width == 0.0 || self.height == 0.0
    }

    /// Scales this size by a factor
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::geometry::Size;
    ///
    /// let size = Size::new(100.0, 50.0);
    /// let scaled = size.scale(2.0);
    ///
    /// assert_eq!(scaled, Size::new(200.0, 100.0));
    /// ```
    pub fn scale(self, factor: f32) -> Self {
        Self {
            width: self.width * factor,
            height: self.height * factor,
        }
    }
}

impl fmt::Display for Size {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}×{}", self.width, self.height)
    }
}
```

### Step 4: Implement Rect Type (Estimated: 2 hours)

**What to do:**
1. Define `Rect` struct with origin (Point) and size (Size)
2. Add multiple constructors: `new()`, `from_xywh()`, `from_points()`
3. Add accessor methods: `x()`, `y()`, `width()`, `height()`, `min_x()`, `max_x()`, etc.
4. Add geometric operations: `contains_point()`, `intersects()`, `union()`
5. Write comprehensive tests

**Implementation details:**

Rect is the most complex geometry type. It needs many utility methods for layout algorithms.

**Example code:**

```rust
/// An axis-aligned rectangle in CSS pixel space
///
/// Defined by an origin point (top-left corner) and a size.
///
/// # Examples
///
/// ```
/// use fastrender::geometry::{Rect, Point, Size};
///
/// let rect = Rect::new(Point::new(10.0, 20.0), Size::new(100.0, 50.0));
/// assert_eq!(rect.x(), 10.0);
/// assert_eq!(rect.y(), 20.0);
/// assert_eq!(rect.width(), 100.0);
/// assert_eq!(rect.height(), 50.0);
/// ```
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Rect {
    /// The top-left corner of the rectangle
    pub origin: Point,
    /// The size (width and height) of the rectangle
    pub size: Size,
}

impl Rect {
    /// A zero-sized rectangle at the origin
    pub const ZERO: Self = Self {
        origin: Point::ZERO,
        size: Size::ZERO,
    };

    /// Creates a new rectangle from an origin point and size
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::geometry::{Rect, Point, Size};
    ///
    /// let rect = Rect::new(Point::new(5.0, 5.0), Size::new(10.0, 10.0));
    /// assert_eq!(rect.origin.x, 5.0);
    /// ```
    pub const fn new(origin: Point, size: Size) -> Self {
        Self { origin, size }
    }

    /// Creates a rectangle from x, y, width, height components
    ///
    /// This is a convenience constructor for the common case.
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::geometry::Rect;
    ///
    /// let rect = Rect::from_xywh(10.0, 20.0, 100.0, 50.0);
    /// assert_eq!(rect.x(), 10.0);
    /// assert_eq!(rect.width(), 100.0);
    /// ```
    pub const fn from_xywh(x: f32, y: f32, width: f32, height: f32) -> Self {
        Self {
            origin: Point::new(x, y),
            size: Size::new(width, height),
        }
    }

    /// Creates a rectangle from two corner points
    ///
    /// Takes the top-left and bottom-right corners.
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::geometry::{Rect, Point};
    ///
    /// let rect = Rect::from_points(Point::new(10.0, 20.0), Point::new(50.0, 70.0));
    /// assert_eq!(rect.width(), 40.0);
    /// assert_eq!(rect.height(), 50.0);
    /// ```
    pub fn from_points(top_left: Point, bottom_right: Point) -> Self {
        Self {
            origin: top_left,
            size: Size::new(
                bottom_right.x - top_left.x,
                bottom_right.y - top_left.y,
            ),
        }
    }

    // Accessor methods

    /// Returns the x coordinate of the left edge
    pub fn x(self) -> f32 {
        self.origin.x
    }

    /// Returns the y coordinate of the top edge
    pub fn y(self) -> f32 {
        self.origin.y
    }

    /// Returns the width
    pub fn width(self) -> f32 {
        self.size.width
    }

    /// Returns the height
    pub fn height(self) -> f32 {
        self.size.height
    }

    /// Returns the x coordinate of the left edge (same as x())
    pub fn min_x(self) -> f32 {
        self.origin.x
    }

    /// Returns the x coordinate of the right edge
    pub fn max_x(self) -> f32 {
        self.origin.x + self.size.width
    }

    /// Returns the y coordinate of the top edge (same as y())
    pub fn min_y(self) -> f32 {
        self.origin.y
    }

    /// Returns the y coordinate of the bottom edge
    pub fn max_y(self) -> f32 {
        self.origin.y + self.size.height
    }

    /// Returns the center point of the rectangle
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::geometry::{Rect, Point};
    ///
    /// let rect = Rect::from_xywh(0.0, 0.0, 100.0, 50.0);
    /// assert_eq!(rect.center(), Point::new(50.0, 25.0));
    /// ```
    pub fn center(self) -> Point {
        Point::new(
            self.origin.x + self.size.width / 2.0,
            self.origin.y + self.size.height / 2.0,
        )
    }

    // Geometric operations

    /// Returns true if this rectangle contains the given point
    ///
    /// Points on the boundary are considered inside.
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::geometry::{Rect, Point};
    ///
    /// let rect = Rect::from_xywh(10.0, 10.0, 20.0, 20.0);
    /// assert!(rect.contains_point(Point::new(15.0, 15.0)));
    /// assert!(!rect.contains_point(Point::new(5.0, 5.0)));
    /// ```
    pub fn contains_point(self, point: Point) -> bool {
        point.x >= self.min_x()
            && point.x <= self.max_x()
            && point.y >= self.min_y()
            && point.y <= self.max_y()
    }

    /// Returns true if this rectangle intersects another rectangle
    ///
    /// Rectangles that touch at an edge or corner are considered intersecting.
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::geometry::Rect;
    ///
    /// let rect1 = Rect::from_xywh(0.0, 0.0, 10.0, 10.0);
    /// let rect2 = Rect::from_xywh(5.0, 5.0, 10.0, 10.0);
    /// let rect3 = Rect::from_xywh(20.0, 20.0, 10.0, 10.0);
    ///
    /// assert!(rect1.intersects(rect2));
    /// assert!(!rect1.intersects(rect3));
    /// ```
    pub fn intersects(self, other: Rect) -> bool {
        self.min_x() <= other.max_x()
            && self.max_x() >= other.min_x()
            && self.min_y() <= other.max_y()
            && self.max_y() >= other.min_y()
    }

    /// Computes the union of two rectangles
    ///
    /// Returns the smallest rectangle that contains both rectangles.
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::geometry::Rect;
    ///
    /// let rect1 = Rect::from_xywh(0.0, 0.0, 10.0, 10.0);
    /// let rect2 = Rect::from_xywh(5.0, 5.0, 10.0, 10.0);
    /// let union = rect1.union(rect2);
    ///
    /// assert_eq!(union, Rect::from_xywh(0.0, 0.0, 15.0, 15.0));
    /// ```
    pub fn union(self, other: Rect) -> Rect {
        let min_x = self.min_x().min(other.min_x());
        let min_y = self.min_y().min(other.min_y());
        let max_x = self.max_x().max(other.max_x());
        let max_y = self.max_y().max(other.max_y());

        Rect::from_xywh(min_x, min_y, max_x - min_x, max_y - min_y)
    }

    /// Computes the intersection of two rectangles
    ///
    /// Returns None if the rectangles don't intersect.
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::geometry::Rect;
    ///
    /// let rect1 = Rect::from_xywh(0.0, 0.0, 10.0, 10.0);
    /// let rect2 = Rect::from_xywh(5.0, 5.0, 10.0, 10.0);
    ///
    /// let intersection = rect1.intersection(rect2);
    /// assert_eq!(intersection, Some(Rect::from_xywh(5.0, 5.0, 5.0, 5.0)));
    /// ```
    pub fn intersection(self, other: Rect) -> Option<Rect> {
        if !self.intersects(other) {
            return None;
        }

        let min_x = self.min_x().max(other.min_x());
        let min_y = self.min_y().max(other.min_y());
        let max_x = self.max_x().min(other.max_x());
        let max_y = self.max_y().min(other.max_y());

        Some(Rect::from_xywh(min_x, min_y, max_x - min_x, max_y - min_y))
    }

    /// Translates this rectangle by an offset
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::geometry::{Rect, Point};
    ///
    /// let rect = Rect::from_xywh(10.0, 10.0, 20.0, 20.0);
    /// let translated = rect.translate(Point::new(5.0, 3.0));
    ///
    /// assert_eq!(translated, Rect::from_xywh(15.0, 13.0, 20.0, 20.0));
    /// ```
    pub fn translate(self, offset: Point) -> Rect {
        Rect {
            origin: self.origin.translate(offset),
            size: self.size,
        }
    }

    /// Inflates or deflates the rectangle by the given amount on all sides
    ///
    /// Positive values inflate (make larger), negative values deflate (make smaller).
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::geometry::Rect;
    ///
    /// let rect = Rect::from_xywh(10.0, 10.0, 20.0, 20.0);
    /// let inflated = rect.inflate(5.0);
    ///
    /// assert_eq!(inflated, Rect::from_xywh(5.0, 5.0, 30.0, 30.0));
    /// ```
    pub fn inflate(self, amount: f32) -> Rect {
        Rect::from_xywh(
            self.origin.x - amount,
            self.origin.y - amount,
            self.size.width + 2.0 * amount,
            self.size.height + 2.0 * amount,
        )
    }
}

impl fmt::Display for Rect {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "[{}, {}, {}, {}]",
            self.x(),
            self.y(),
            self.width(),
            self.height()
        )
    }
}
```

### Step 5: Implement EdgeOffsets Type (Estimated: 1 hour)

**What to do:**
1. Define `EdgeOffsets` struct with top, right, bottom, left fields
2. Add constructors: `new()`, `all()`, `symmetric()`
3. Add `horizontal()` and `vertical()` sum methods

**Example code:**

```rust
/// Edge offsets representing spacing on all four sides
///
/// Used for margin, padding, and border widths.
/// Follows CSS box model convention: top, right, bottom, left.
///
/// # Examples
///
/// ```
/// use fastrender::geometry::EdgeOffsets;
///
/// let padding = EdgeOffsets::all(10.0);
/// assert_eq!(padding.horizontal(), 20.0);
/// assert_eq!(padding.vertical(), 20.0);
/// ```
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct EdgeOffsets {
    /// Top edge offset
    pub top: f32,
    /// Right edge offset
    pub right: f32,
    /// Bottom edge offset
    pub bottom: f32,
    /// Left edge offset
    pub left: f32,
}

impl EdgeOffsets {
    /// Zero offsets on all sides
    pub const ZERO: Self = Self {
        top: 0.0,
        right: 0.0,
        bottom: 0.0,
        left: 0.0,
    };

    /// Creates edge offsets with the same value on all sides
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::geometry::EdgeOffsets;
    ///
    /// let padding = EdgeOffsets::all(10.0);
    /// assert_eq!(padding.top, 10.0);
    /// assert_eq!(padding.left, 10.0);
    /// ```
    pub const fn all(value: f32) -> Self {
        Self {
            top: value,
            right: value,
            bottom: value,
            left: value,
        }
    }

    /// Creates edge offsets with individual values for each side
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::geometry::EdgeOffsets;
    ///
    /// let margin = EdgeOffsets::new(10.0, 20.0, 10.0, 20.0);
    /// assert_eq!(margin.horizontal(), 40.0);
    /// ```
    pub const fn new(top: f32, right: f32, bottom: f32, left: f32) -> Self {
        Self {
            top,
            right,
            bottom,
            left,
        }
    }

    /// Creates symmetric edge offsets
    ///
    /// # Arguments
    /// * `vertical` - Value for top and bottom
    /// * `horizontal` - Value for left and right
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::geometry::EdgeOffsets;
    ///
    /// let padding = EdgeOffsets::symmetric(10.0, 20.0);
    /// assert_eq!(padding.top, 10.0);
    /// assert_eq!(padding.left, 20.0);
    /// ```
    pub const fn symmetric(vertical: f32, horizontal: f32) -> Self {
        Self {
            top: vertical,
            right: horizontal,
            bottom: vertical,
            left: horizontal,
        }
    }

    /// Returns the sum of left and right offsets
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::geometry::EdgeOffsets;
    ///
    /// let offsets = EdgeOffsets::new(5.0, 10.0, 5.0, 15.0);
    /// assert_eq!(offsets.horizontal(), 25.0);
    /// ```
    pub fn horizontal(self) -> f32 {
        self.left + self.right
    }

    /// Returns the sum of top and bottom offsets
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::geometry::EdgeOffsets;
    ///
    /// let offsets = EdgeOffsets::new(10.0, 5.0, 20.0, 5.0);
    /// assert_eq!(offsets.vertical(), 30.0);
    /// ```
    pub fn vertical(self) -> f32 {
        self.top + self.bottom
    }
}

impl fmt::Display for EdgeOffsets {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "[t:{}, r:{}, b:{}, l:{}]",
            self.top, self.right, self.bottom, self.left
        )
    }
}
```

### Step 6: Write Comprehensive Tests (Estimated: 1-2 hours)

**Required tests:**

Add these tests at the bottom of `src/geometry.rs` inside a `#[cfg(test)]` module:

```rust
#[cfg(test)]
mod tests {
    use super::*;

    // Point tests
    #[test]
    fn test_point_creation() {
        let p = Point::new(10.0, 20.0);
        assert_eq!(p.x, 10.0);
        assert_eq!(p.y, 20.0);
    }

    #[test]
    fn test_point_zero() {
        let p = Point::ZERO;
        assert_eq!(p.x, 0.0);
        assert_eq!(p.y, 0.0);
    }

    #[test]
    fn test_point_translate() {
        let p1 = Point::new(10.0, 20.0);
        let p2 = Point::new(5.0, 3.0);
        let result = p1.translate(p2);
        assert_eq!(result, Point::new(15.0, 23.0));
    }

    #[test]
    fn test_point_distance() {
        let p1 = Point::new(0.0, 0.0);
        let p2 = Point::new(3.0, 4.0);
        assert!((p1.distance_to(p2) - 5.0).abs() < 0.001);
    }

    // Size tests
    #[test]
    fn test_size_creation() {
        let s = Size::new(100.0, 50.0);
        assert_eq!(s.width, 100.0);
        assert_eq!(s.height, 50.0);
    }

    #[test]
    fn test_size_area() {
        let s = Size::new(10.0, 20.0);
        assert_eq!(s.area(), 200.0);
    }

    #[test]
    fn test_size_is_empty() {
        assert!(Size::ZERO.is_empty());
        assert!(Size::new(0.0, 10.0).is_empty());
        assert!(Size::new(10.0, 0.0).is_empty());
        assert!(!Size::new(10.0, 10.0).is_empty());
    }

    #[test]
    fn test_size_scale() {
        let s = Size::new(100.0, 50.0);
        let scaled = s.scale(2.0);
        assert_eq!(scaled, Size::new(200.0, 100.0));
    }

    // Rect tests
    #[test]
    fn test_rect_creation() {
        let rect = Rect::from_xywh(10.0, 20.0, 100.0, 50.0);
        assert_eq!(rect.x(), 10.0);
        assert_eq!(rect.y(), 20.0);
        assert_eq!(rect.width(), 100.0);
        assert_eq!(rect.height(), 50.0);
    }

    #[test]
    fn test_rect_from_points() {
        let rect = Rect::from_points(Point::new(10.0, 20.0), Point::new(50.0, 70.0));
        assert_eq!(rect.width(), 40.0);
        assert_eq!(rect.height(), 50.0);
    }

    #[test]
    fn test_rect_accessors() {
        let rect = Rect::from_xywh(10.0, 20.0, 100.0, 50.0);
        assert_eq!(rect.min_x(), 10.0);
        assert_eq!(rect.max_x(), 110.0);
        assert_eq!(rect.min_y(), 20.0);
        assert_eq!(rect.max_y(), 70.0);
    }

    #[test]
    fn test_rect_center() {
        let rect = Rect::from_xywh(0.0, 0.0, 100.0, 50.0);
        assert_eq!(rect.center(), Point::new(50.0, 25.0));
    }

    #[test]
    fn test_rect_contains_point() {
        let rect = Rect::from_xywh(10.0, 10.0, 20.0, 20.0);
        assert!(rect.contains_point(Point::new(15.0, 15.0)));
        assert!(rect.contains_point(Point::new(10.0, 10.0))); // Boundary
        assert!(rect.contains_point(Point::new(30.0, 30.0))); // Boundary
        assert!(!rect.contains_point(Point::new(5.0, 5.0)));
        assert!(!rect.contains_point(Point::new(35.0, 35.0)));
    }

    #[test]
    fn test_rect_intersects() {
        let rect1 = Rect::from_xywh(0.0, 0.0, 10.0, 10.0);
        let rect2 = Rect::from_xywh(5.0, 5.0, 10.0, 10.0);
        let rect3 = Rect::from_xywh(20.0, 20.0, 10.0, 10.0);
        let rect4 = Rect::from_xywh(10.0, 10.0, 10.0, 10.0); // Touches corner

        assert!(rect1.intersects(rect2));
        assert!(rect2.intersects(rect1)); // Symmetric
        assert!(!rect1.intersects(rect3));
        assert!(rect1.intersects(rect4)); // Corner touch counts
    }

    #[test]
    fn test_rect_union() {
        let rect1 = Rect::from_xywh(0.0, 0.0, 10.0, 10.0);
        let rect2 = Rect::from_xywh(5.0, 5.0, 10.0, 10.0);
        let union = rect1.union(rect2);

        assert_eq!(union, Rect::from_xywh(0.0, 0.0, 15.0, 15.0));
    }

    #[test]
    fn test_rect_intersection() {
        let rect1 = Rect::from_xywh(0.0, 0.0, 10.0, 10.0);
        let rect2 = Rect::from_xywh(5.0, 5.0, 10.0, 10.0);
        let rect3 = Rect::from_xywh(20.0, 20.0, 10.0, 10.0);

        let intersection = rect1.intersection(rect2);
        assert_eq!(intersection, Some(Rect::from_xywh(5.0, 5.0, 5.0, 5.0)));

        let no_intersection = rect1.intersection(rect3);
        assert_eq!(no_intersection, None);
    }

    #[test]
    fn test_rect_translate() {
        let rect = Rect::from_xywh(10.0, 10.0, 20.0, 20.0);
        let translated = rect.translate(Point::new(5.0, 3.0));

        assert_eq!(translated, Rect::from_xywh(15.0, 13.0, 20.0, 20.0));
    }

    #[test]
    fn test_rect_inflate() {
        let rect = Rect::from_xywh(10.0, 10.0, 20.0, 20.0);
        let inflated = rect.inflate(5.0);
        assert_eq!(inflated, Rect::from_xywh(5.0, 5.0, 30.0, 30.0));

        let deflated = rect.inflate(-2.0);
        assert_eq!(deflated, Rect::from_xywh(12.0, 12.0, 16.0, 16.0));
    }

    // EdgeOffsets tests
    #[test]
    fn test_edge_offsets_creation() {
        let offsets = EdgeOffsets::new(10.0, 20.0, 30.0, 40.0);
        assert_eq!(offsets.top, 10.0);
        assert_eq!(offsets.right, 20.0);
        assert_eq!(offsets.bottom, 30.0);
        assert_eq!(offsets.left, 40.0);
    }

    #[test]
    fn test_edge_offsets_all() {
        let offsets = EdgeOffsets::all(10.0);
        assert_eq!(offsets.top, 10.0);
        assert_eq!(offsets.right, 10.0);
        assert_eq!(offsets.bottom, 10.0);
        assert_eq!(offsets.left, 10.0);
    }

    #[test]
    fn test_edge_offsets_symmetric() {
        let offsets = EdgeOffsets::symmetric(10.0, 20.0);
        assert_eq!(offsets.top, 10.0);
        assert_eq!(offsets.bottom, 10.0);
        assert_eq!(offsets.left, 20.0);
        assert_eq!(offsets.right, 20.0);
    }

    #[test]
    fn test_edge_offsets_horizontal() {
        let offsets = EdgeOffsets::new(5.0, 10.0, 5.0, 15.0);
        assert_eq!(offsets.horizontal(), 25.0);
    }

    #[test]
    fn test_edge_offsets_vertical() {
        let offsets = EdgeOffsets::new(10.0, 5.0, 20.0, 5.0);
        assert_eq!(offsets.vertical(), 30.0);
    }
}
```

### Step 7: Documentation and Final Polish (Estimated: 30min)

**What to do:**
1. Run `cargo test geometry` and ensure all tests pass
2. Run `cargo clippy -- -D warnings` and fix any warnings
3. Run `cargo fmt` to format code
4. Generate docs: `cargo doc --no-deps --open`
5. Verify all public APIs have examples in rustdoc

## Testing Requirements

### Unit Tests

All tests are inline in `src/geometry.rs` in the `#[cfg(test)]` module.

**Run tests:**
```bash
cargo test geometry
```

**Expected output:**
```
running 23 tests
test geometry::tests::test_point_creation ... ok
test geometry::tests::test_point_zero ... ok
test geometry::tests::test_point_translate ... ok
test geometry::tests::test_point_distance ... ok
test geometry::tests::test_size_creation ... ok
test geometry::tests::test_size_area ... ok
test geometry::tests::test_size_is_empty ... ok
test geometry::tests::test_size_scale ... ok
test geometry::tests::test_rect_creation ... ok
test geometry::tests::test_rect_from_points ... ok
test geometry::tests::test_rect_accessors ... ok
test geometry::tests::test_rect_center ... ok
test geometry::tests::test_rect_contains_point ... ok
test geometry::tests::test_rect_intersects ... ok
test geometry::tests::test_rect_union ... ok
test geometry::tests::test_rect_intersection ... ok
test geometry::tests::test_rect_translate ... ok
test geometry::tests::test_rect_inflate ... ok
test geometry::tests::test_edge_offsets_creation ... ok
test geometry::tests::test_edge_offsets_all ... ok
test geometry::tests::test_edge_offsets_symmetric ... ok
test geometry::tests::test_edge_offsets_horizontal ... ok
test geometry::tests::test_edge_offsets_vertical ... ok

test result: ok. 23 passed; 0 failed; 0 ignored; 0 measured
```

### Manual Verification

```bash
# Compile check
cargo build

# Clippy (no warnings)
cargo clippy -- -D warnings

# Format check
cargo fmt --check

# Documentation
cargo doc --no-deps --open
```

## Output Artifacts

### Code Files

1. **`src/geometry.rs`**
   - Complete implementation of Point, Size, Rect, EdgeOffsets
   - All public APIs documented with rustdoc
   - Comprehensive test suite included
   - Passes clippy with no warnings

### Notes File

Create: **`outputs/notes/W1.T01-notes.md`**

Use this template (fill in after completion):

```markdown
# Task W1.T01 Output Notes

## Implementation Summary

Implemented four core geometry types for CSS layout:
- **Point**: 2D coordinates (x, y) in CSS pixels
- **Size**: 2D dimensions (width, height)
- **Rect**: Axis-aligned rectangle (origin + size)
- **EdgeOffsets**: Four-sided spacing (top, right, bottom, left)

All types are Copy, have zero constants, and include comprehensive utility methods.

## API Contracts

### Public Types

```rust
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Point {
    pub x: f32,
    pub y: f32,
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Size {
    pub width: f32,
    pub height: f32,
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Rect {
    pub origin: Point,
    pub size: Size,
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub struct EdgeOffsets {
    pub top: f32,
    pub right: f32,
    pub bottom: f32,
    pub left: f32,
}
```

### Key Methods

```rust
// Point
impl Point {
    pub const ZERO: Self;
    pub const fn new(x: f32, y: f32) -> Self;
    pub fn translate(self, other: Point) -> Self;
    pub fn distance_to(self, other: Point) -> f32;
}

// Size
impl Size {
    pub const ZERO: Self;
    pub const fn new(width: f32, height: f32) -> Self;
    pub fn area(self) -> f32;
    pub fn is_empty(self) -> bool;
    pub fn scale(self, factor: f32) -> Self;
}

// Rect
impl Rect {
    pub const ZERO: Self;
    pub const fn new(origin: Point, size: Size) -> Self;
    pub const fn from_xywh(x: f32, y: f32, width: f32, height: f32) -> Self;
    pub fn contains_point(self, point: Point) -> bool;
    pub fn intersects(self, other: Rect) -> bool;
    pub fn union(self, other: Rect) -> Rect;
    pub fn intersection(self, other: Rect) -> Option<Rect>;
    pub fn translate(self, offset: Point) -> Rect;
    pub fn inflate(self, amount: f32) -> Rect;
    // Plus many accessor methods
}

// EdgeOffsets
impl EdgeOffsets {
    pub const ZERO: Self;
    pub const fn all(value: f32) -> Self;
    pub const fn symmetric(vertical: f32, horizontal: f32) -> Self;
    pub fn horizontal(self) -> f32;
    pub fn vertical(self) -> f32;
}
```

## Decisions Made

### Decision 1: Use f32 Instead of f64

**Choice:** All coordinates and dimensions use `f32`
**Rationale:**
- CSS layout calculations don't need f64 precision
- f32 is faster and uses less memory
- Browsers use float (f32 equivalent) internally
- Reduces cache pressure for large fragment trees

**Impact:** Downstream tasks should use f32 consistently

### Decision 2: Make All Types Copy

**Choice:** All geometry types derive Copy
**Rationale:**
- Small types (8-16 bytes)
- Passed by value is more efficient than references
- Simplifies API (no lifetime annotations needed)
- Follows Rust idiom for small data types

**Impact:** Can pass by value without performance concerns

### Decision 3: Fields are Public

**Choice:** All struct fields are public (not using accessors for all operations)
**Rationale:**
- Simpler API, less boilerplate
- These are simple data types with no invariants
- Still provide methods for common operations
- Follows Rust's Point/Size/Rect idiom

**Alternatives Considered:** Private fields with getters/setters - rejected as too verbose for simple types

## Spec Interpretations

### Coordinate System Origin

**Spec says:** CSS 2.1 uses top-left origin with +Y downward
**Interpretation:** Point(0, 0) is top-left, +X right, +Y down
**Reasoning:** Matches CSS coordinate system exactly
**Test coverage:** Implicit in all tests using positive coordinates

## Discoveries & Gotchas

### Discovery 1: Intersection Edge Cases

**What:** Rectangles that touch at edges/corners should be considered intersecting
**Why it matters:** Affects hit testing and paint optimization
**Recommendation:** Use `<=` not `<` in intersection tests

### Gotcha 1: Floating Point Equality

**Problem:** Comparing f32 with `==` can fail due to precision
**Solution:** For tests, use `(a - b).abs() < epsilon` when needed
**Warning:** Production code should avoid exact floating point comparisons

## Performance Notes

### Performance Characteristics

- All operations are O(1)
- No allocations (all types are Copy)
- Methods are inline-friendly (most will be inlined)

### Optimization Opportunities

- **SIMD**: Rect operations (union, intersection) could use SIMD in hot paths
- **Future**: Consider adding `Rect::from_points_batch()` for bulk operations

## Recommendations for Downstream Tasks

### For Task W2.T01 (BoxNode Type):

- Use `Rect::ZERO` as placeholder for unpositioned boxes
- Remember that boxes don't have positions yet (only fragments do)
- Use `Size` for intrinsic sizes

### For Task W2.T03 (FragmentNode Type):

- Fragments MUST have valid Rect (positioned and sized)
- Use `Rect::translate()` for positioning children
- Use `Rect::union()` for computing bounding boxes

### For Task W2.T05 (ComputedStyle):

- Use `EdgeOffsets` for margin, padding, border
- Remember to use `.horizontal()` and `.vertical()` when computing total box size

## Open Questions

None - geometry types are straightforward with well-defined semantics.

## Test Coverage

### What's Tested

- ✅ All constructors (new, from_xywh, all, symmetric, etc.)
- ✅ Zero constants
- ✅ Accessor methods (x, y, width, height, min_x, max_x, etc.)
- ✅ Geometric operations (contains, intersects, union, intersection)
- ✅ Transformations (translate, inflate, scale)
- ✅ Edge cases (empty sizes, boundary conditions)

### What's Not Tested (Gaps)

- ❌ SIMD performance (not relevant until profiling shows need)
- ❌ Precision edge cases with very large/small numbers (not expected in practice)

### Test Statistics

- Unit tests: 23 tests covering all public APIs
- All tests pass: ✅
- Clippy warnings: 0

## Code Quality

- ✅ Clippy passes with no warnings
- ✅ Rustfmt applied
- ✅ All public APIs documented with rustdoc
- ✅ Examples in all public API documentation
- ✅ Display trait implemented for debugging

## References Used

1. CSS 2.1 Section 8.3.1 (Coordinate System) - https://www.w3.org/TR/CSS21/coords.html
2. Rust std::f32 documentation
3. WebRender's geometry types (for inspiration on API design)

---

**Task completed:** 2025-01-20
**Time taken:** 5 hours
**Tests passing:** 23/23
```

## Common Pitfalls to Avoid

### Pitfall 1: Using f64 Instead of f32

**Wrong:** `pub struct Point { pub x: f64, pub y: f64 }`
**Right:** `pub struct Point { pub x: f32, pub y: f32 }`

Layout doesn't need double precision, and f32 is faster.

### Pitfall 2: Not Deriving Copy

**Wrong:** Only deriving `Debug, Clone`
**Right:** Derive `Debug, Clone, Copy, PartialEq`

These are small types that should be Copy.

### Pitfall 3: Missing Const Constructors

**Wrong:** `pub fn new(x: f32, y: f32) -> Self`
**Right:** `pub const fn new(x: f32, y: f32) -> Self`

Const functions enable compile-time constants.

### Pitfall 4: Incomplete Documentation

**Wrong:** `/// Creates a new point`
**Right:** Full rustdoc with examples, as shown in implementation guide

Every public API needs examples.

### Pitfall 5: Insufficient Test Coverage

**Wrong:** Only testing happy path
**Right:** Test edge cases: zero sizes, boundary conditions, negative values

## Verification Checklist

Before marking task complete:

- [ ] All objectives met
- [ ] All success criteria satisfied
- [ ] Code compiles: `cargo build`
- [ ] Tests pass: `cargo test geometry`
- [ ] Clippy happy: `cargo clippy -- -D warnings`
- [ ] Formatted: `cargo fmt --check`
- [ ] All public APIs have rustdoc with examples
- [ ] Notes file complete with all sections
- [ ] `src/lib.rs` updated to export geometry module

## Time Tracking

Estimated breakdown:
- **Setup:** 30min
- **Point implementation:** 1hr
- **Size implementation:** 1hr
- **Rect implementation:** 2hrs
- **EdgeOffsets implementation:** 1hr
- **Testing:** 1-2hrs
- **Documentation review:** 30min
- **Total:** 4-6 hours

## Getting Help

If stuck:

1. **Review the template**: `docs/plan/01-type-system.md` has similar code
2. **Check Rust docs**: std library's geometry types (though they're in external crates)
3. **CSS 2.1 spec**: Section 8 defines the coordinate system
4. **WebRender source**: Look at their euclid crate for geometric primitives

Remember: This is a foundation task. Take time to get it right. Every other task depends on these types!
