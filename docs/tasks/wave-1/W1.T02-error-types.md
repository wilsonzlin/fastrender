---
task_id: "W1.T02"
title: "Implement Error Types"
wave: 1
estimated_hours: 3-4
depends_on: []
inputs: []
outputs:
  - "src/error.rs"
  - "outputs/notes/W1.T02-notes.md"
skills_required:
  - "Rust fundamentals"
  - "Error handling patterns"
  - "Testing"
context_files:
  - "docs/plan/01-type-system.md"
  - "docs/tasks/TASK_TEMPLATE.md"
verification:
  - "cargo test error"
  - "cargo clippy -- -D warnings"
  - "cargo fmt --check"
---

# Implement Error Types

## Context

A robust rendering engine needs comprehensive error handling across all subsystems. Errors can occur during HTML parsing, CSS parsing, layout computation, font loading, text shaping, image loading, and rendering. Each error needs clear context about what went wrong and where.

In FastRender V2, we're rebuilding from scratch with a proper error type hierarchy. The error types are Wave 1 foundation tasks, meaning they have **no dependencies** and must be completed before any other work can proceed.

### Background

**Error Handling in Rust:**
- **Result<T, E>**: The standard way to return errors in Rust
- **thiserror**: Derive macro for custom error types with minimal boilerplate
- **Error trait**: Standard trait for all error types
- **Display**: Human-readable error messages
- **Debug**: Machine-readable error context

**Error Categories in FastRender:**
- **Parse Errors**: HTML/CSS parsing failures
- **Style Errors**: CSS cascade and computation errors
- **Layout Errors**: Box generation and layout algorithm failures
- **Font Errors**: Font loading and fallback failures
- **Text Errors**: Text shaping and line breaking errors
- **Image Errors**: Image loading and decoding failures
- **Render Errors**: Painting and rasterization failures

### Why This Matters

Without comprehensive error types, we cannot:
- Provide helpful error messages to users
- Debug issues in complex rendering pipelines
- Distinguish between recoverable and fatal errors
- Test error paths properly
- Log errors with appropriate context

Every single task in Waves 2-6 depends on these error types. Get them wrong and we'll have to refactor hundreds of error sites later.

## Prerequisites

### Required Knowledge
- **Rust basics**: Enums, structs, traits, modules
- **Result type**: Understanding Result<T, E> and the ? operator
- **Error trait**: std::error::Error and std::fmt::Display
- **thiserror crate**: Using derive macros for error types

### Required Reading
1. **The Rust Programming Language, Chapter 9**: Error Handling
2. **Rust Error Handling**: https://doc.rust-lang.org/book/ch09-00-error-handling.html
3. **thiserror documentation**: https://docs.rs/thiserror/latest/thiserror/
4. **Error Handling in Rust (Blog)**: https://nick.groenen.me/posts/rust-error-handling/

## Inputs

### From Dependencies

**None** - This is a Wave 1 task with no dependencies.

### Existing Code

Check `src/error.rs` - it may already exist with basic error types. We're replacing it with a comprehensive hierarchy.

You should also check:
- `src/lib.rs` - Will need to add `pub mod error;` and re-exports
- `Cargo.toml` - Add `thiserror = "1.0"` if not present

## Objectives

### Primary Goals

1. **Implement Error enum**: Top-level error type covering all subsystems
2. **Implement ParseError**: HTML/CSS parsing errors
3. **Implement LayoutError**: Layout computation errors
4. **Implement FontError**: Font loading errors
5. **Implement ImageError**: Image loading errors
6. **Implement RenderError**: Rendering errors
7. **Add comprehensive tests**: Cover error creation, Display, Debug

### Success Criteria

- [ ] All error types implemented with full documentation
- [ ] All error types derive `Error, Debug, Display` using thiserror
- [ ] Error types support error source chaining where appropriate
- [ ] Helpful error messages that guide users to fixes
- [ ] Result type alias provided: `pub type Result<T> = std::result::Result<T, Error>;`
- [ ] All tests pass: `cargo test error`
- [ ] Clippy passes with no warnings
- [ ] Rustfmt applied
- [ ] All public APIs have rustdoc comments with examples
- [ ] Notes file created with all sections filled

## Implementation Guide

### Step 1: Update Cargo.toml (Estimated: 5min)

**What to do:**
1. Add thiserror dependency if not present
2. Verify version is 1.0 or later

**Code:**

Check if `thiserror` is in `Cargo.toml`. If not, add:

```toml
[dependencies]
# ... existing dependencies ...
thiserror = "1.0"
```

### Step 2: Create the Error Module (Estimated: 30min)

**What to do:**
1. Create or update file: `src/error.rs`
2. Add module declaration to `src/lib.rs`
3. Set up module structure with documentation

**Code:**

First, update `src/lib.rs` to add the error module:

```rust
// Add this to src/lib.rs
pub mod error;

// Re-export for convenience
pub use error::{Error, Result};
```

Then create `src/error.rs`:

```rust
//! Error types for FastRender
//!
//! This module provides comprehensive error types for all subsystems:
//! - Parse errors (HTML/CSS)
//! - Layout errors (box generation, layout algorithms)
//! - Font errors (loading, shaping)
//! - Image errors (loading, decoding)
//! - Render errors (painting, rasterization)
//!
//! All errors use the `thiserror` crate for minimal boilerplate and
//! proper error trait implementations.

use std::fmt;
use thiserror::Error;

/// Result type alias for FastRender operations
///
/// This is a convenience type that uses our Error type as the error variant.
///
/// # Examples
///
/// ```
/// use fastrender::Result;
///
/// fn parse_html(html: &str) -> Result<()> {
///     Ok(())
/// }
/// ```
pub type Result<T> = std::result::Result<T, Error>;

// Error types will be implemented in subsequent steps
```

### Step 3: Implement Top-Level Error Type (Estimated: 45min)

**What to do:**
1. Define `Error` enum with variants for all subsystems
2. Use thiserror derive macro
3. Add helpful error messages
4. Support error source chaining

**Implementation details:**

The `Error` type is the top-level error that encompasses all subsystem errors. Each variant wraps a more specific error type.

**Example code:**

```rust
/// Top-level error type for FastRender
///
/// This enum covers all possible errors that can occur during rendering.
/// Each variant wraps a more specific error type for that subsystem.
///
/// # Examples
///
/// ```
/// use fastrender::Error;
///
/// fn render() -> Result<(), Error> {
///     Err(Error::Layout(LayoutError::InvalidConstraints {
///         message: "Width cannot be negative".to_string(),
///     }))
/// }
/// ```
#[derive(Error, Debug)]
pub enum Error {
    /// HTML or CSS parsing error
    #[error("Parse error: {0}")]
    Parse(#[from] ParseError),

    /// Style computation error
    #[error("Style error: {0}")]
    Style(#[from] StyleError),

    /// Layout error
    #[error("Layout error: {0}")]
    Layout(#[from] LayoutError),

    /// Font loading or shaping error
    #[error("Font error: {0}")]
    Font(#[from] FontError),

    /// Text shaping or line breaking error
    #[error("Text error: {0}")]
    Text(#[from] TextError),

    /// Image loading or decoding error
    #[error("Image error: {0}")]
    Image(#[from] ImageError),

    /// Rendering or rasterization error
    #[error("Render error: {0}")]
    Render(#[from] RenderError),

    /// I/O error (file reading, network, etc.)
    #[error("I/O error: {0}")]
    Io(#[from] std::io::Error),

    /// Generic error for miscellaneous issues
    #[error("{0}")]
    Other(String),
}
```

### Step 4: Implement ParseError Type (Estimated: 30min)

**What to do:**
1. Define `ParseError` enum for HTML/CSS parsing failures
2. Include source information (line, column) where possible
3. Add helpful messages about what went wrong

**Example code:**

```rust
/// Errors that occur during HTML or CSS parsing
///
/// These errors indicate that the input HTML or CSS could not be parsed
/// according to the specifications.
///
/// # Examples
///
/// ```
/// use fastrender::error::ParseError;
///
/// let error = ParseError::InvalidCss {
///     message: "Expected selector, found '{'".to_string(),
///     line: 10,
///     column: 5,
/// };
/// ```
#[derive(Error, Debug, Clone)]
pub enum ParseError {
    /// Invalid HTML structure
    #[error("Invalid HTML at line {line}: {message}")]
    InvalidHtml {
        message: String,
        line: usize,
    },

    /// Invalid CSS syntax
    #[error("Invalid CSS at line {line}, column {column}: {message}")]
    InvalidCss {
        message: String,
        line: usize,
        column: usize,
    },

    /// Invalid selector
    #[error("Invalid selector: {selector}")]
    InvalidSelector {
        selector: String,
    },

    /// Invalid property value
    #[error("Invalid value for property '{property}': {value}")]
    InvalidPropertyValue {
        property: String,
        value: String,
    },

    /// Unsupported CSS feature
    #[error("Unsupported CSS feature: {feature}")]
    UnsupportedFeature {
        feature: String,
    },
}
```

### Step 5: Implement StyleError Type (Estimated: 20min)

**What to do:**
1. Define `StyleError` enum for style computation failures
2. Handle cascade, inheritance, and computed value errors

**Example code:**

```rust
/// Errors that occur during style computation
///
/// These errors happen during the cascade, inheritance, and computed
/// value calculation phases.
#[derive(Error, Debug, Clone)]
pub enum StyleError {
    /// Property value cannot be computed
    #[error("Cannot compute value for property '{property}': {reason}")]
    CannotComputeValue {
        property: String,
        reason: String,
    },

    /// Circular dependency in custom properties (CSS variables)
    #[error("Circular dependency detected in custom property '{property}'")]
    CircularDependency {
        property: String,
    },

    /// Invalid inherit or initial value usage
    #[error("Invalid use of '{keyword}' for property '{property}'")]
    InvalidKeyword {
        property: String,
        keyword: String,
    },
}
```

### Step 6: Implement LayoutError Type (Estimated: 30min)

**What to do:**
1. Define `LayoutError` enum for layout algorithm failures
2. Cover box generation, constraint solving, and positioning errors

**Example code:**

```rust
/// Errors that occur during layout computation
///
/// These errors happen during box generation, layout algorithm execution,
/// or fragment tree construction.
///
/// # Examples
///
/// ```
/// use fastrender::error::LayoutError;
///
/// let error = LayoutError::InvalidConstraints {
///     message: "Width cannot be negative: -100px".to_string(),
/// };
/// println!("{}", error);
/// ```
#[derive(Error, Debug, Clone)]
pub enum LayoutError {
    /// Invalid layout constraints
    #[error("Invalid layout constraints: {message}")]
    InvalidConstraints {
        message: String,
    },

    /// Box generation failed
    #[error("Box generation failed: {message}")]
    BoxGenerationFailed {
        message: String,
    },

    /// Unsupported display value combination
    #[error("Unsupported display value: {display}")]
    UnsupportedDisplay {
        display: String,
    },

    /// Percentage resolution failed (no containing block)
    #[error("Cannot resolve percentage: {property} has no containing block")]
    PercentageResolutionFailed {
        property: String,
    },

    /// Intrinsic size calculation failed
    #[error("Cannot calculate intrinsic size: {reason}")]
    IntrinsicSizeFailed {
        reason: String,
    },

    /// Constraint solver failed (for flex/grid)
    #[error("Constraint solver failed: {message}")]
    ConstraintSolverFailed {
        message: String,
    },
}
```

### Step 7: Implement FontError Type (Estimated: 30min)

**What to do:**
1. Define `FontError` enum for font loading and fallback failures
2. Include font family, style, weight information

**Example code:**

```rust
/// Errors that occur during font loading and resolution
///
/// These errors happen when fonts cannot be loaded from the system or
/// font fallback fails.
///
/// # Examples
///
/// ```
/// use fastrender::error::FontError;
///
/// let error = FontError::FontNotFound {
///     family: "Helvetica Neue".to_string(),
/// };
/// ```
#[derive(Error, Debug, Clone)]
pub enum FontError {
    /// Font family not found
    #[error("Font family not found: '{family}'")]
    FontNotFound {
        family: String,
    },

    /// No fonts available (not even fallback fonts)
    #[error("No fonts available on system")]
    NoFontsAvailable,

    /// Font file is invalid or corrupted
    #[error("Invalid font file: {path}")]
    InvalidFontFile {
        path: String,
    },

    /// Font loading failed
    #[error("Failed to load font '{family}': {reason}")]
    LoadFailed {
        family: String,
        reason: String,
    },

    /// Font database query failed
    #[error("Font database query failed: {reason}")]
    DatabaseQueryFailed {
        reason: String,
    },
}
```

### Step 8: Implement TextError Type (Estimated: 20min)

**What to do:**
1. Define `TextError` enum for text shaping and line breaking failures

**Example code:**

```rust
/// Errors that occur during text shaping and line breaking
///
/// These errors happen during text layout operations like shaping
/// with HarfBuzz or computing line breaks.
#[derive(Error, Debug, Clone)]
pub enum TextError {
    /// Text shaping failed
    #[error("Text shaping failed for text '{text}': {reason}")]
    ShapingFailed {
        text: String,
        reason: String,
    },

    /// Line breaking algorithm failed
    #[error("Line breaking failed: {reason}")]
    LineBreakingFailed {
        reason: String,
    },

    /// Bidi algorithm failed
    #[error("Bidi algorithm failed: {reason}")]
    BidiFailed {
        reason: String,
    },

    /// Glyph not found in font
    #[error("Glyph not found for character U+{codepoint:04X}")]
    GlyphNotFound {
        codepoint: u32,
    },
}
```

### Step 9: Implement ImageError Type (Estimated: 30min)

**What to do:**
1. Define `ImageError` enum for image loading and decoding failures
2. Support URLs, data URLs, and local paths

**Example code:**

```rust
/// Errors that occur during image loading and decoding
///
/// These errors happen when images cannot be loaded from URLs,
/// data URLs, or local paths, or when decoding fails.
///
/// # Examples
///
/// ```
/// use fastrender::error::ImageError;
///
/// let error = ImageError::LoadFailed {
///     url: "https://example.com/image.png".to_string(),
///     reason: "404 Not Found".to_string(),
/// };
/// ```
#[derive(Error, Debug, Clone)]
pub enum ImageError {
    /// Image loading failed
    #[error("Failed to load image from '{url}': {reason}")]
    LoadFailed {
        url: String,
        reason: String,
    },

    /// Image decoding failed
    #[error("Failed to decode image from '{url}': {reason}")]
    DecodeFailed {
        url: String,
        reason: String,
    },

    /// Invalid image format
    #[error("Invalid image format for '{url}': {format}")]
    InvalidFormat {
        url: String,
        format: String,
    },

    /// Invalid data URL
    #[error("Invalid data URL: {reason}")]
    InvalidDataUrl {
        reason: String,
    },

    /// Network error (for remote images)
    #[error("Network error loading '{url}': {status}")]
    NetworkError {
        url: String,
        status: String,
    },
}
```

### Step 10: Implement RenderError Type (Estimated: 20min)

**What to do:**
1. Define `RenderError` enum for painting and rasterization failures

**Example code:**

```rust
/// Errors that occur during rendering and rasterization
///
/// These errors happen during the paint phase when converting
/// the fragment tree to pixels.
#[derive(Error, Debug, Clone)]
pub enum RenderError {
    /// Canvas creation failed
    #[error("Failed to create canvas: {width}x{height}")]
    CanvasCreationFailed {
        width: u32,
        height: u32,
    },

    /// Paint operation failed
    #[error("Paint operation failed: {operation}")]
    PaintFailed {
        operation: String,
    },

    /// Image encoding failed
    #[error("Failed to encode image as {format}: {reason}")]
    EncodeFailed {
        format: String,
        reason: String,
    },

    /// Invalid paint parameters
    #[error("Invalid paint parameters: {message}")]
    InvalidParameters {
        message: String,
    },

    /// Rasterization failed
    #[error("Rasterization failed: {reason}")]
    RasterizationFailed {
        reason: String,
    },
}
```

### Step 11: Write Comprehensive Tests (Estimated: 1 hour)

**Required tests:**

Add these tests at the bottom of `src/error.rs` inside a `#[cfg(test)]` module:

```rust
#[cfg(test)]
mod tests {
    use super::*;

    // ParseError tests
    #[test]
    fn test_parse_error_invalid_html() {
        let error = ParseError::InvalidHtml {
            message: "Unexpected closing tag".to_string(),
            line: 10,
        };
        let display = format!("{}", error);
        assert!(display.contains("line 10"));
        assert!(display.contains("Unexpected closing tag"));
    }

    #[test]
    fn test_parse_error_invalid_css() {
        let error = ParseError::InvalidCss {
            message: "Expected selector".to_string(),
            line: 5,
            column: 10,
        };
        let display = format!("{}", error);
        assert!(display.contains("line 5"));
        assert!(display.contains("column 10"));
    }

    #[test]
    fn test_parse_error_invalid_selector() {
        let error = ParseError::InvalidSelector {
            selector: "div > > p".to_string(),
        };
        assert!(format!("{}", error).contains("div > > p"));
    }

    // StyleError tests
    #[test]
    fn test_style_error_cannot_compute_value() {
        let error = StyleError::CannotComputeValue {
            property: "width".to_string(),
            reason: "Circular dependency".to_string(),
        };
        assert!(format!("{}", error).contains("width"));
        assert!(format!("{}", error).contains("Circular dependency"));
    }

    #[test]
    fn test_style_error_circular_dependency() {
        let error = StyleError::CircularDependency {
            property: "--my-color".to_string(),
        };
        assert!(format!("{}", error).contains("--my-color"));
    }

    // LayoutError tests
    #[test]
    fn test_layout_error_invalid_constraints() {
        let error = LayoutError::InvalidConstraints {
            message: "Width cannot be negative".to_string(),
        };
        assert!(format!("{}", error).contains("Invalid layout constraints"));
    }

    #[test]
    fn test_layout_error_unsupported_display() {
        let error = LayoutError::UnsupportedDisplay {
            display: "ruby".to_string(),
        };
        assert!(format!("{}", error).contains("ruby"));
    }

    #[test]
    fn test_layout_error_percentage_resolution() {
        let error = LayoutError::PercentageResolutionFailed {
            property: "width".to_string(),
        };
        assert!(format!("{}", error).contains("percentage"));
    }

    // FontError tests
    #[test]
    fn test_font_error_not_found() {
        let error = FontError::FontNotFound {
            family: "Comic Sans".to_string(),
        };
        assert!(format!("{}", error).contains("Comic Sans"));
    }

    #[test]
    fn test_font_error_load_failed() {
        let error = FontError::LoadFailed {
            family: "Arial".to_string(),
            reason: "File not found".to_string(),
        };
        let display = format!("{}", error);
        assert!(display.contains("Arial"));
        assert!(display.contains("File not found"));
    }

    // TextError tests
    #[test]
    fn test_text_error_shaping_failed() {
        let error = TextError::ShapingFailed {
            text: "Hello".to_string(),
            reason: "Font missing".to_string(),
        };
        assert!(format!("{}", error).contains("Hello"));
    }

    #[test]
    fn test_text_error_glyph_not_found() {
        let error = TextError::GlyphNotFound {
            codepoint: 0x1F600, // üòÄ
        };
        assert!(format!("{}", error).contains("1F600"));
    }

    // ImageError tests
    #[test]
    fn test_image_error_load_failed() {
        let error = ImageError::LoadFailed {
            url: "https://example.com/img.png".to_string(),
            reason: "404".to_string(),
        };
        let display = format!("{}", error);
        assert!(display.contains("example.com"));
        assert!(display.contains("404"));
    }

    #[test]
    fn test_image_error_invalid_format() {
        let error = ImageError::InvalidFormat {
            url: "image.xyz".to_string(),
            format: "xyz".to_string(),
        };
        assert!(format!("{}", error).contains("xyz"));
    }

    // RenderError tests
    #[test]
    fn test_render_error_canvas_creation() {
        let error = RenderError::CanvasCreationFailed {
            width: 10000,
            height: 10000,
        };
        assert!(format!("{}", error).contains("10000"));
    }

    #[test]
    fn test_render_error_encode_failed() {
        let error = RenderError::EncodeFailed {
            format: "PNG".to_string(),
            reason: "Out of memory".to_string(),
        };
        let display = format!("{}", error);
        assert!(display.contains("PNG"));
        assert!(display.contains("Out of memory"));
    }

    // Top-level Error tests
    #[test]
    fn test_error_from_parse_error() {
        let parse_error = ParseError::InvalidHtml {
            message: "Test".to_string(),
            line: 1,
        };
        let error: Error = parse_error.into();
        assert!(matches!(error, Error::Parse(_)));
    }

    #[test]
    fn test_error_from_layout_error() {
        let layout_error = LayoutError::InvalidConstraints {
            message: "Test".to_string(),
        };
        let error: Error = layout_error.into();
        assert!(matches!(error, Error::Layout(_)));
    }

    // Result type alias test
    #[test]
    fn test_result_type_alias() {
        fn returns_result() -> Result<i32> {
            Ok(42)
        }
        assert_eq!(returns_result().unwrap(), 42);
    }

    #[test]
    fn test_result_with_error() {
        fn returns_error() -> Result<()> {
            Err(Error::Other("test error".to_string()))
        }
        assert!(returns_error().is_err());
    }

    // Error trait tests
    #[test]
    fn test_error_trait_implemented() {
        let error = Error::Other("test".to_string());
        // If this compiles, Error implements std::error::Error
        let _: &dyn std::error::Error = &error;
    }

    #[test]
    fn test_debug_formatting() {
        let error = ParseError::InvalidCss {
            message: "Test".to_string(),
            line: 1,
            column: 5,
        };
        let debug = format!("{:?}", error);
        assert!(debug.contains("InvalidCss"));
    }
}
```

### Step 12: Documentation and Final Polish (Estimated: 20min)

**What to do:**
1. Run `cargo test error` and ensure all tests pass
2. Run `cargo clippy -- -D warnings` and fix any warnings
3. Run `cargo fmt` to format code
4. Generate docs: `cargo doc --no-deps --open`
5. Verify all public APIs have examples in rustdoc

## Testing Requirements

### Unit Tests

All tests are inline in `src/error.rs` in the `#[cfg(test)]` module.

**Run tests:**
```bash
cargo test error
```

**Expected output:**
```
running 27 tests
test error::tests::test_parse_error_invalid_html ... ok
test error::tests::test_parse_error_invalid_css ... ok
test error::tests::test_parse_error_invalid_selector ... ok
test error::tests::test_style_error_cannot_compute_value ... ok
test error::tests::test_style_error_circular_dependency ... ok
test error::tests::test_layout_error_invalid_constraints ... ok
test error::tests::test_layout_error_unsupported_display ... ok
test error::tests::test_layout_error_percentage_resolution ... ok
test error::tests::test_font_error_not_found ... ok
test error::tests::test_font_error_load_failed ... ok
test error::tests::test_text_error_shaping_failed ... ok
test error::tests::test_text_error_glyph_not_found ... ok
test error::tests::test_image_error_load_failed ... ok
test error::tests::test_image_error_invalid_format ... ok
test error::tests::test_render_error_canvas_creation ... ok
test error::tests::test_render_error_encode_failed ... ok
test error::tests::test_error_from_parse_error ... ok
test error::tests::test_error_from_layout_error ... ok
test error::tests::test_result_type_alias ... ok
test error::tests::test_result_with_error ... ok
test error::tests::test_error_trait_implemented ... ok
test error::tests::test_debug_formatting ... ok

test result: ok. 22 passed; 0 failed; 0 ignored; 0 measured
```

### Manual Verification

```bash
# Compile check
cargo build

# Clippy (no warnings)
cargo clippy -- -D warnings

# Format check
cargo fmt --check

# Documentation
cargo doc --no-deps --open
```

## Output Artifacts

### Code Files

1. **`src/error.rs`**
   - Complete implementation of all error types
   - All public APIs documented with rustdoc
   - Comprehensive test suite included
   - Passes clippy with no warnings

### Notes File

Create: **`outputs/notes/W1.T02-notes.md`**

Use this template (fill in after completion):

```markdown
# Task W1.T02 Output Notes

## Implementation Summary

Implemented comprehensive error type hierarchy for FastRender:
- **Error**: Top-level error enum covering all subsystems
- **ParseError**: HTML/CSS parsing errors
- **StyleError**: Style computation errors
- **LayoutError**: Layout algorithm errors
- **FontError**: Font loading errors
- **TextError**: Text shaping errors
- **ImageError**: Image loading errors
- **RenderError**: Rendering errors

All types use thiserror for minimal boilerplate and proper Error trait implementation.

## API Contracts

### Public Types

```rust
pub type Result<T> = std::result::Result<T, Error>;

#[derive(Error, Debug)]
pub enum Error {
    Parse(ParseError),
    Style(StyleError),
    Layout(LayoutError),
    Font(FontError),
    Text(TextError),
    Image(ImageError),
    Render(RenderError),
    Io(std::io::Error),
    Other(String),
}

// Plus all specific error types...
```

### Key Methods

All error types automatically implement:
- `std::error::Error` trait
- `std::fmt::Display` trait
- `std::fmt::Debug` trait
- `From` conversions (via thiserror)

## Decisions Made

### Decision 1: Use thiserror Instead of Manual Implementation

**Choice:** Use thiserror derive macros for all error types
**Rationale:**
- Reduces boilerplate significantly
- Automatic Error trait implementation
- Better error source chaining with #[from]
- Industry standard in Rust ecosystem
- Compile-time error message validation

**Impact:** Adds thiserror dependency but saves development time

### Decision 2: Granular Error Types per Subsystem

**Choice:** Separate error types for each subsystem instead of one giant enum
**Rationale:**
- Better organization and maintainability
- Easier to add new error variants without merge conflicts
- Each subsystem owns its errors
- Clear separation of concerns

**Impact:** More types but better structure

### Decision 3: Include Context in Error Messages

**Choice:** Include relevant context (line numbers, property names, URLs) in error variants
**Rationale:**
- Helps debugging significantly
- Users can understand what went wrong
- Error messages guide users to fixes
- Better than generic "parsing failed" messages

**Example:** `ParseError::InvalidCss { message, line, column }` instead of just `ParseError::InvalidCss(String)`

### Decision 4: Clone for All Error Types

**Choice:** Derive Clone for all error types
**Rationale:**
- Errors may need to be logged and returned
- Allows error recovery patterns
- Small types, cloning is cheap
- Enables error collection patterns

**Impact:** All error types must have cloneable fields

## Spec Interpretations

N/A - Error types are internal implementation detail, not specified by web standards.

## Discoveries & Gotchas

### Discovery 1: thiserror #[from] Attribute

**What:** The #[from] attribute automatically generates From implementations
**Example:** `#[error("Parse error: {0}")] Parse(#[from] ParseError)`
**Impact:** Enables ? operator to automatically convert from ParseError to Error

### Gotcha 1: Error Message Formatting

**Problem:** Easy to forget that Display messages are user-facing
**Solution:** Always include helpful context in error messages
**Example:** Instead of "Invalid value", use "Invalid value for property 'width': -100px"

### Gotcha 2: Clone vs Copy for Errors

**Problem:** Errors contain Strings which are not Copy
**Solution:** Derive Clone instead of Copy
**Warning:** Don't try to make errors Copy - it won't work with String fields

## Performance Notes

### Performance Characteristics

- Error construction is not on the hot path
- Display formatting only happens when errors are printed
- No allocations except for String fields
- Cloning is cheap (mostly String clones)

### Optimization Opportunities

- **Future**: Consider using `Cow<'static, str>` for common error messages
- **Future**: Error message interning for frequently occurring errors

## Recommendations for Downstream Tasks

### For All Tasks:

- Use `Result<T>` instead of `std::result::Result<T, Error>`
- Use `?` operator for error propagation
- Create specific error variants, not generic ones
- Include helpful context in error messages

### For Task W2.T01 (BoxNode Type):

- Use `LayoutError::BoxGenerationFailed` for box generation failures
- Include element debug info in error messages

### For Task W3.T01 (Block Layout):

- Use `LayoutError::InvalidConstraints` for constraint violations
- Use `LayoutError::PercentageResolutionFailed` when no containing block

### For Task W4.T01 (Font System):

- Use `FontError::FontNotFound` with family name
- Chain font loading errors with error sources

## Open Questions

None - error types are straightforward and well-understood.

## Test Coverage

### What's Tested

- ‚úÖ All error variant construction
- ‚úÖ Display formatting for all error types
- ‚úÖ Debug formatting for all error types
- ‚úÖ From conversions (ParseError -> Error, etc.)
- ‚úÖ Result type alias works correctly
- ‚úÖ Error trait implementation

### What's Not Tested (Gaps)

- ‚ùå Error source chaining (requires upstream errors)
- ‚ùå Real-world error scenarios (will be tested in integration tests)

### Test Statistics

- Unit tests: 22 tests covering all error types
- All tests pass: ‚úÖ
- Clippy warnings: 0

## Code Quality

- ‚úÖ Clippy passes with no warnings
- ‚úÖ Rustfmt applied
- ‚úÖ All public APIs documented with rustdoc
- ‚úÖ Examples in error type documentation
- ‚úÖ thiserror used consistently

## References Used

1. Rust Error Handling - https://doc.rust-lang.org/book/ch09-00-error-handling.html
2. thiserror documentation - https://docs.rs/thiserror/latest/thiserror/
3. Error Handling in Rust (Blog) - https://nick.groenen.me/posts/rust-error-handling/

---

**Task completed:** [DATE]
**Time taken:** [HOURS] hours
**Tests passing:** 22/22
```

## Common Pitfalls to Avoid

### Pitfall 1: Forgetting thiserror Dependency

**Wrong:** Manually implementing Error trait
**Right:** Add `thiserror = "1.0"` to Cargo.toml and use derive macros

Manual Error implementations are verbose and error-prone.

### Pitfall 2: Generic Error Messages

**Wrong:** `#[error("Invalid input")]`
**Right:** `#[error("Invalid CSS at line {line}, column {column}: {message}")]`

Include context to help users understand what went wrong.

### Pitfall 3: Not Using #[from] Attribute

**Wrong:** Manually implementing From<ParseError> for Error
**Right:** Use `#[error("Parse error: {0}")] Parse(#[from] ParseError)`

Let thiserror generate the boilerplate.

### Pitfall 4: Making Errors Copy

**Wrong:** `#[derive(Error, Debug, Copy)]`
**Right:** `#[derive(Error, Debug, Clone)]`

Errors contain Strings which are not Copy.

### Pitfall 5: Insufficient Error Variants

**Wrong:** Only having `LayoutError::Failed { message: String }`
**Right:** Specific variants like `InvalidConstraints`, `PercentageResolutionFailed`, etc.

Specific variants enable better error handling and debugging.

## Verification Checklist

Before marking task complete:

- [ ] All objectives met
- [ ] All success criteria satisfied
- [ ] Code compiles: `cargo build`
- [ ] Tests pass: `cargo test error`
- [ ] Clippy happy: `cargo clippy -- -D warnings`
- [ ] Formatted: `cargo fmt --check`
- [ ] All public APIs have rustdoc with examples
- [ ] Notes file complete with all sections
- [ ] `src/lib.rs` updated to export error module
- [ ] Cargo.toml has thiserror dependency

## Time Tracking

Estimated breakdown:
- **Setup:** 5min
- **Top-level Error type:** 45min
- **ParseError:** 30min
- **StyleError:** 20min
- **LayoutError:** 30min
- **FontError:** 30min
- **TextError:** 20min
- **ImageError:** 30min
- **RenderError:** 20min
- **Testing:** 1hr
- **Documentation review:** 20min
- **Total:** 3-4 hours

## Getting Help

If stuck:

1. **Review the Rust book**: Chapter 9 on error handling
2. **Check thiserror docs**: https://docs.rs/thiserror/latest/thiserror/
3. **Look at examples**: Search GitHub for "thiserror derive error" for real-world examples
4. **Error handling patterns**: https://nick.groenen.me/posts/rust-error-handling/

Remember: Good error messages save hours of debugging time. Invest in clear, helpful errors!
