---
task_id: "W4.T12"
title: "Implement Inline Formatting Context Algorithm"
wave: 4
estimated_hours: 12-16
depends_on:
  - "W2.T07"
  - "W4.T05"
  - "W4.T09"
  - "W3.T18"
  - "W1.R01"
inputs:
  - "docs/tasks/notes/W2.T07-notes.md"
  - "docs/tasks/notes/W4.T05-notes.md"
  - "docs/tasks/notes/W4.T09-notes.md"
  - "docs/tasks/notes/W3.T18-notes.md"
  - "docs/tasks/notes/W1.R01-notes.md"
outputs:
  - "src/layout/contexts/inline.rs"
  - "src/layout/contexts/inline/line_builder.rs"
  - "src/layout/contexts/inline/baseline.rs"
  - "docs/tasks/notes/W4.T12-notes.md"
skills_required:
  - "Rust"
  - "CSS inline layout"
  - "Complex algorithm implementation"
  - "Text metrics"
context_files:
  - "docs/layout/inline.md"
  - "docs/tasks/notes/W1.R01-notes.md"
verification:
  - "cargo test layout::contexts::inline"
  - "Can layout multi-line text"
  - "Baseline alignment works"
---

# Implement Inline Formatting Context Algorithm

## Context

The Inline Formatting Context (IFC) handles text layout - one of the most complex parts of a browser engine. This is where text gets shaped, broken into lines, and positioned with proper baseline alignment.

This is the **most complex layout algorithm** in FastRender V2.

### Background

**What is Inline Layout?**

From CSS 2.1 Section 9.4.2:
> "In an inline formatting context, boxes are laid out horizontally, one after the other, beginning at the top of a containing block."

Key behaviors:
- **Horizontal flow**: Inline boxes flow left-to-right (or RTL)
- **Line breaking**: Content wraps to multiple lines
- **Baseline alignment**: Text aligns on baseline
- **Mixed content**: Text, inline boxes, replaced elements
- **Bidirectional text**: LTR and RTL mixed

**The Algorithm** (simplified):
```
1. Shape all text (with fonts, bidi, script)
2. Find line break opportunities
3. For each line:
   a. Collect inline boxes that fit
   b. Break text at line boundary
   c. Compute line box height (tallest content)
   d. Align baselines
   e. Position inline boxes on line
4. Stack lines vertically
```

**Why This is Complex:**

- Text shaping (fonts, ligatures, kerning)
- Bidi text (Arabic, Hebrew mixed with English)
- Line breaking (Unicode Line Breaking Algorithm UAX#14)
- Baseline alignment (dominant baseline, vertical-align)
- Inline-blocks (establish nested BFC)
- Replaced elements (images with intrinsic sizes)

### Why This Matters

Inline layout is consumed by:
- **W2.T10**: LayoutEngine (for inline elements)
- **W3.T04**: Block layout (blocks with inline content)
- **All real web pages**: Almost every page has inline content

This validates:
- Text shaping pipeline (W4.T05)
- Line breaking (W4.T09)
- Font system (W3.T18)
- FormattingContext abstraction

If inline layout works, we can render real web pages.

## Prerequisites

### Required Knowledge
- **CSS 2.1 Section 9.4.2**: Inline formatting contexts
- **CSS 2.1 Section 10.8**: Line height and vertical alignment
- **UAX#14**: Unicode Line Breaking Algorithm
- **Rust**: Complex state machines, iterator patterns

### Required Reading
1. **docs/tasks/notes/W1.R01-notes.md**: IFC section from CSS research
2. **docs/tasks/notes/W4.T05-notes.md**: Text shaping API
3. **docs/tasks/notes/W4.T09-notes.md**: Line breaking API
4. **docs/tasks/notes/W3.T18-notes.md**: Font metrics API
5. **docs/layout/inline.md**: Implementation strategy

## Inputs

### From Dependencies

1. **W4.T05-notes.md** (Text Shaping)
   - Look for: ShapedText API
   - Look for: How to get glyph positions
   - **Critical**: Must use shaped text, not raw text

2. **W4.T09-notes.md** (Line Breaking)
   - Look for: LineBreaker API
   - Look for: Break opportunities
   - **Critical**: Use UAX#14 algorithm, don't invent your own

3. **W3.T18-notes.md** (Font Metrics)
   - Look for: FontMetrics API
   - Look for: Ascent, descent, line height
   - **Critical**: Baseline alignment needs metrics

4. **W1.R01-notes.md** (CSS Research)
   - Look for: IFC algorithm pseudocode
   - Look for: Line box algorithm
   - Look for: Baseline alignment rules

## Objectives

### Primary Goals

1. **Implement InlineFormattingContext**: Implements FormattingContext trait
2. **Implement line builder**: Collects inline boxes into lines
3. **Implement text shaping integration**: Shape text with fonts
4. **Implement line breaking**: Break lines at opportunities
5. **Implement baseline alignment**: Align mixed content on baseline
6. **Handle inline-blocks**: Nested BFCs within inline content
7. **Handle replaced elements**: Images, etc. with intrinsic sizes
8. **Comprehensive tests**: Multi-line text, mixed content, alignment

### Success Criteria

- [ ] InlineFormattingContext implements FormattingContext trait
- [ ] Can layout single-line text
- [ ] Can layout multi-line text (wrapping)
- [ ] Baseline alignment works (text + inline-blocks)
- [ ] Line height computed correctly
- [ ] Line breaking at correct positions (spaces, hyphens)
- [ ] Handles empty lines
- [ ] At least 15 tests covering scenarios
- [ ] Can render paragraph of text correctly

## Implementation Guide

### Step 1: Define Line Builder (Estimated: 3-4 hours)

**`src/layout/contexts/inline/line_builder.rs`:**
```rust
//! Line builder - collects inline boxes into lines

use crate::tree::Fragment;
use crate::geometry::{Point, Rect, Size};

pub struct LineBuilder {
    /// Current line y position
    current_y: f32,
    
    /// Available width
    available_width: f32,
    
    /// Current line width used
    current_line_width: f32,
    
    /// Items on current line
    current_line: Vec<InlineItem>,
    
    /// Completed lines
    lines: Vec<Line>,
}

struct InlineItem {
    fragment: Fragment,
    width: f32,
    height: f32,
    baseline: f32,
}

struct Line {
    items: Vec<InlineItem>,
    y: f32,
    height: f32,
    baseline: f32,
}

impl LineBuilder {
    pub fn new(available_width: f32) -> Self {
        Self {
            current_y: 0.0,
            available_width,
            current_line_width: 0.0,
            current_line: Vec::new(),
            lines: Vec::new(),
        }
    }
    
    pub fn add_item(&mut self, fragment: Fragment, width: f32, height: f32, baseline: f32) {
        if self.current_line_width + width > self.available_width {
            // Line is full, break
            self.finish_line();
        }
        
        self.current_line.push(InlineItem {
            fragment,
            width,
            height,
            baseline,
        });
        
        self.current_line_width += width;
    }
    
    pub fn finish_line(&mut self) {
        if self.current_line.is_empty() {
            return;
        }
        
        // Compute line height (max of all items)
        let line_height = self.current_line.iter()
            .map(|item| item.height)
            .fold(0.0f32, |a, b| a.max(b));
        
        // Compute baseline (for now, use first item's baseline)
        let baseline = self.current_line.first()
            .map(|item| item.baseline)
            .unwrap_or(0.0);
        
        let line = Line {
            items: std::mem::take(&mut self.current_line),
            y: self.current_y,
            height: line_height,
            baseline,
        };
        
        self.lines.push(line);
        self.current_y += line_height;
        self.current_line_width = 0.0;
    }
    
    pub fn build(mut self) -> Vec<Fragment> {
        self.finish_line();
        
        // Position all fragments
        let mut result = Vec::new();
        
        for line in self.lines {
            let mut x = 0.0;
            
            for item in line.items {
                let mut fragment = item.fragment;
                
                // Position at (x, line.y + baseline offset)
                let y = line.y + (line.baseline - item.baseline);
                fragment.set_position(Point::new(x, y));
                
                x += item.width;
                result.push(fragment);
            }
        }
        
        result
    }
}
```

### Step 2: Implement Baseline Alignment (Estimated: 2-3 hours)

**`src/layout/contexts/inline/baseline.rs`:**
```rust
//! Baseline alignment

/// Computes baseline for mixed content
pub fn compute_line_baseline(items: &[InlineItem]) -> f32 {
    // Find dominant baseline (usually text baseline)
    items.iter()
        .filter_map(|item| {
            if item.is_text {
                Some(item.baseline)
            } else {
                None
            }
        })
        .next()
        .unwrap_or(0.0)
}

/// Aligns an item on the baseline
pub fn align_on_baseline(
    item_height: f32,
    item_baseline: f32,
    line_baseline: f32,
) -> f32 {
    line_baseline - item_baseline
}
```

### Step 3: Implement Main IFC Layout (Estimated: 6-8 hours)

**`src/layout/contexts/inline.rs`:**
```rust
//! Inline Formatting Context implementation

use crate::layout::{FormattingContext, LayoutConstraints, LayoutError};
use crate::tree::{BoxNode, Fragment};
use crate::text::{FontContext, ShapedText};

mod line_builder;
mod baseline;

use line_builder::LineBuilder;

pub struct InlineFormattingContext {
    font_context: FontContext,
}

impl InlineFormattingContext {
    pub fn new(font_context: FontContext) -> Self {
        Self { font_context }
    }
}

impl FormattingContext for InlineFormattingContext {
    fn layout(
        &self,
        box_node: &BoxNode,
        constraints: &LayoutConstraints,
    ) -> Result<Fragment, LayoutError> {
        let available_width = constraints.available_width.definite_value()
            .ok_or(LayoutError::MissingContext("Need definite width"))?;
        
        let mut line_builder = LineBuilder::new(available_width);
        
        // Process all children
        for child in &box_node.children {
            if child.is_text() {
                // Shape text
                let text = child.text().unwrap();
                let shaped = shape_text(text, &child.style, &self.font_context)?;
                
                // Break into lines
                let fragments = break_text_into_fragments(
                    shaped,
                    available_width,
                    &child.style,
                )?;
                
                for frag in fragments {
                    let metrics = get_fragment_metrics(&frag);
                    line_builder.add_item(
                        frag,
                        metrics.width,
                        metrics.height,
                        metrics.baseline,
                    );
                }
            } else if child.is_inline_level() {
                // Layout inline box or inline-block
                let child_fc = get_fc_for_box(child);
                let child_fragment = child_fc.layout(child, constraints)?;
                
                let metrics = get_fragment_metrics(&child_fragment);
                line_builder.add_item(
                    child_fragment,
                    metrics.width,
                    metrics.height,
                    metrics.baseline,
                );
            }
        }
        
        let children = line_builder.build();
        
        // Compute container height (sum of line heights)
        let height = children.iter()
            .map(|f| f.bounds.max_y())
            .fold(0.0f32, |a, b| a.max(b));
        
        Ok(Fragment::new_inline(
            Rect::new(Point::ZERO, Size::new(available_width, height)),
            box_node.style.clone(),
            children,
        ))
    }
    
    fn compute_intrinsic_inline_size(
        &self,
        box_node: &BoxNode,
        mode: IntrinsicSizingMode,
    ) -> Result<f32, LayoutError> {
        // For inline, intrinsic size is sum of children
        // (This is simplified; real algorithm is more complex)
        let mut total_width = 0.0;
        
        for child in &box_node.children {
            if child.is_text() {
                let text = child.text().unwrap();
                let shaped = shape_text(text, &child.style, &self.font_context)?;
                total_width += shaped.total_width();
            } else {
                let child_fc = get_fc_for_box(child);
                total_width += child_fc.compute_intrinsic_inline_size(child, mode)?;
            }
        }
        
        Ok(total_width)
    }
}

// Helper functions
fn shape_text(
    text: &str,
    style: &ComputedStyle,
    font_context: &FontContext,
) -> Result<ShapedText, LayoutError> {
    // Use W4.T05 shaping pipeline
    todo!("Integrate with shaping pipeline")
}

fn break_text_into_fragments(
    shaped: ShapedText,
    available_width: f32,
    style: &ComputedStyle,
) -> Result<Vec<Fragment>, LayoutError> {
    // Use W4.T09 line breaking
    todo!("Integrate with line breaker")
}
```

### Step 4: Write Tests (Estimated: 3 hours)

Tests covering:
- Single-line text
- Multi-line text
- Mixed inline and text
- Baseline alignment
- Line height
- Empty lines

## Testing Requirements

**Minimum 15 tests**:
1. Single line text (2 tests)
2. Multi-line wrapping (3 tests)
3. Baseline alignment (3 tests)
4. Mixed content (3 tests)
5. Edge cases (4 tests)

## Output Artifacts

### Code Files

1. **`src/layout/contexts/inline.rs`** (~500 lines)
2. **`src/layout/contexts/inline/line_builder.rs`** (~200 lines)
3. **`src/layout/contexts/inline/baseline.rs`** (~100 lines)
4. **Tests**: ~400 lines

### Notes File

Create: **`docs/tasks/notes/W4.T12-notes.md`**

Must include:
- Complete algorithm
- Baseline alignment explanation
- Integration with shaping and line breaking
- Performance notes
- Edge cases and spec ambiguities

## Common Pitfalls

### Pitfall 1: Not Using Shaped Text

**Wrong:** Using character widths
**Right:** Use shaped text with proper kerning, ligatures

### Pitfall 2: Wrong Baseline Alignment

**Wrong:** Top-aligning everything
**Right:** Use proper baseline alignment with font metrics

### Pitfall 3: Not Handling Line Breaking Correctly

**Wrong:** Breaking at any character
**Right:** Use UAX#14 algorithm from W4.T09

## Verification Checklist

- [ ] All 15+ tests pass
- [ ] Can render paragraph
- [ ] Multi-line wrapping works
- [ ] Baseline alignment correct
- [ ] Notes complete

## Time Tracking

- **Line builder:** 3-4hrs
- **Baseline alignment:** 2-3hrs
- **Main layout:** 6-8hrs
- **Testing:** 3hrs
- **Total:** 12-16 hours

This is the most complex layout algorithm. Take time!
