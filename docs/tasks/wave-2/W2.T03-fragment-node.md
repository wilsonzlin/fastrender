---
task_id: "W2.T03"
title: "Implement FragmentNode Type and Fragment Tree"
wave: 2
estimated_hours: 4-6
depends_on:
  - "W1.T01"
inputs:
  - "outputs/notes/W1.T01-notes.md"
  - "src/geometry.rs"
outputs:
  - "src/tree/fragment_tree.rs"
  - "outputs/notes/W2.T03-notes.md"
skills_required:
  - "Rust"
  - "Tree data structures"
  - "CSS layout concepts"
context_files:
  - "docs/plan/01-type-system.md"
verification:
  - "cargo test tree::fragment_tree"
  - "cargo clippy -- -D warnings"
  - "cargo fmt --check"
---

# Implement FragmentNode Type and Fragment Tree

## Context

In the FastRender V2 architecture, we maintain strict separation between **boxes** (what to layout) and **fragments** (layout results). This task implements the **Fragment Tree** - the output of layout containing positioned and sized boxes.

The Fragment Tree represents "where things ended up after layout". Each FragmentNode knows:
- Its position and size (Rect)
- What type of content it contains
- Its children in visual order
- Link back to source BoxNode (via ID or Arc)

This is a **Wave 2** task that depends on:
- **W1.T01**: Geometry types (Point, Size, Rect) - fragments ARE positioned rectangles

### Background

**Box Tree vs Fragment Tree:**

This is the fundamental architectural split:

| Aspect | Box Tree | Fragment Tree |
|--------|----------|---------------|
| **When created** | Once from DOM | Every layout pass |
| **Mutability** | Immutable | Created fresh each time |
| **Position** | None | Has Rect |
| **Size** | Intrinsic only | Final used values |
| **Splitting** | 1 box = 1 box | 1 box → many fragments |
| **Purpose** | What to layout | Layout results |

**Why Fragments Can Split:**

A single BoxNode can generate multiple fragments:
1. **Inline boxes across lines**: One inline box → multiple line fragments
2. **Block split by columns**: One block → multiple column fragments
3. **Table cells across pages**: One cell → multiple page fragments

Example:
```
BoxNode: <span>This is a long line that wraps</span>
  ↓ Layout
Fragment 1: [x:0, y:0, w:100, h:20] "This is a long"
Fragment 2: [x:0, y:20, w:80, h:20] "line that wraps"
```

**Fragment Types:**

Based on what they contain:
1. **Block fragments**: Positioned block boxes
2. **Inline fragments**: Positioned inline boxes (may be split)
3. **Text fragments**: Actual shaped text with glyphs
4. **Line fragments**: Container for inline/text fragments
5. **Replaced fragments**: Positioned replaced elements

### Why This Matters

Fragments are used by:
- **W3.T04**: Block layout (creates block fragments)
- **W4.T12**: Inline layout (creates inline and text fragments)
- **W5.T01**: Paint (paints fragments to canvas)
- **W6.T02**: Hit testing (finds fragment at point)

Without fragments:
- Can't represent layout results
- Can't paint anything
- Can't do hit testing
- Can't scroll (need to know sizes)

Every visual operation after layout uses fragments.

## Prerequisites

### Required Knowledge
- **Rust structs and enums**: Data modeling
- **Tree structures**: Parent/child relationships
- **CSS layout**: Box model, positioning
- **Geometry**: Working with rectangles

### Required Reading
1. **outputs/notes/W1.T01-notes.md**: Geometry types API
2. **CSS 2.1 Section 9**: Visual formatting model
3. **docs/plan/01-type-system.md**: Architecture overview

## Inputs

### From Dependencies

**W1.T01-notes.md** (Geometry types):
- Look for: `Rect`, `Point`, `Size` API contracts
- Look for: Usage recommendations
- Key insight: Fragments MUST have valid Rect (positioned and sized)
- Key methods: `Rect::translate()` for positioning children, `Rect::union()` for bounds

**Key recommendations from W1.T01:**
```rust
// Fragments always have positions (unlike boxes)
pub struct Fragment {
    pub bounds: Rect,  // Always valid, positioned
    // ...
}

// Use Rect::translate() for child positioning
child_bounds = child_bounds.translate(parent_offset);

// Use Rect::union() for computing bounding boxes
let bbox = fragments.iter()
    .map(|f| f.bounds)
    .fold(Rect::ZERO, |acc, r| acc.union(r));
```

### Existing Code

Read these files:
- `src/geometry.rs` - Rect, Point, Size types
- `src/tree/mod.rs` - Tree module organization

## Objectives

### Primary Goals

1. **Define FragmentContent enum**: Different fragment content types
2. **Define FragmentNode struct**: Positioned box with content
3. **Define FragmentTree wrapper**: Root node container
4. **Add geometric methods**: bounding_box(), translate(), hit testing
5. **Add tree traversal**: Iterator over fragments in paint order
6. **Add helper constructors**: Easy creation of common fragment types
7. **Comprehensive tests**: All fragment types, all methods, edge cases

### Success Criteria

- [ ] FragmentContent enum with variants (Block, Inline, Text, Line, Replaced)
- [ ] FragmentNode struct with bounds (Rect), content, children
- [ ] FragmentNode has optional link to source BoxNode
- [ ] bounding_box() method computes minimal enclosing rect
- [ ] translate() method moves fragment and all children
- [ ] contains_point() for hit testing
- [ ] fragments_at_point() finds all fragments at location
- [ ] Tree traversal in paint order (depth-first)
- [ ] All types derive Debug, Clone
- [ ] 20+ comprehensive tests
- [ ] All tests pass
- [ ] Clippy clean, full documentation

## Implementation Guide

### Step 1: Create Fragment Module (Estimated: 15min)

**What to do:**
1. Create `src/tree/fragment_tree.rs`
2. Update `src/tree/mod.rs`

**Code:**

Update `src/tree/mod.rs`:
```rust
//! Tree structures for boxes and fragments

pub mod box_tree;
pub mod box_type;
pub mod fragment_tree;

// Re-exports
pub use box_tree::{BoxTree, BoxNode};
pub use box_type::BoxType;
pub use fragment_tree::{FragmentTree, FragmentNode, FragmentContent};
```

Create `src/tree/fragment_tree.rs`:
```rust
//! Fragment Tree - Represents layout results with positions and sizes
//!
//! Fragments are the output of layout. Unlike boxes (which represent what
//! to layout), fragments represent where things ended up with final positions
//! and dimensions.
//!
//! # Key Differences from Boxes
//!
//! | Box Tree | Fragment Tree |
//! |----------|---------------|
//! | Immutable | Created per layout |
//! | No position | Has position (Rect) |
//! | 1 box = 1 box | 1 box → N fragments (splitting) |
//! | Input to layout | Output of layout |
//!
//! # Fragment Splitting
//!
//! A single box can generate multiple fragments:
//! - Inline boxes split across multiple lines
//! - Blocks split across columns or pages
//! - Table cells split for pagination
//!
//! # Usage
//!
//! ```
//! use fastrender::tree::{FragmentNode, FragmentContent};
//! use fastrender::geometry::{Rect, Point, Size};
//!
//! let fragment = FragmentNode::new_block(
//!     Rect::from_xywh(10.0, 20.0, 100.0, 50.0),
//!     vec![],
//! );
//!
//! assert_eq!(fragment.bounds.x(), 10.0);
//! assert!(fragment.contains_point(Point::new(50.0, 30.0)));
//! ```

use crate::geometry::{Point, Rect, Size};
use std::fmt;
```

### Step 2: Define FragmentContent Enum (Estimated: 1 hour)

**What to do:**
1. Define enum with variants for each content type
2. Add content-specific data
3. Document each variant

**Code:**

```rust
/// Content type of a fragment
///
/// Fragments can contain different types of content, each requiring
/// different paint and hit-testing logic.
#[derive(Debug, Clone)]
pub enum FragmentContent {
    /// Block-level content
    ///
    /// A positioned block box. Children are other block or line fragments.
    Block {
        /// Index or ID of source BoxNode
        /// For now, just store an optional ID
        box_id: Option<usize>,
    },

    /// Inline-level content (possibly split from inline box)
    ///
    /// A fragment of an inline box. One inline box can generate multiple
    /// inline fragments when it wraps across lines.
    Inline {
        /// Index or ID of source BoxNode
        box_id: Option<usize>,

        /// Which fragment this is (0 = first, 1 = second, etc.)
        /// Used when a single inline box splits across multiple lines
        fragment_index: usize,
    },

    /// Text content with shaped glyphs
    ///
    /// Actual text that has been shaped (font, positions, etc.).
    Text {
        /// The text content
        text: String,

        /// Index or ID of source BoxNode (TextBox)
        box_id: Option<usize>,

        /// Baseline offset from fragment top
        /// Used for text alignment within line
        baseline_offset: f32,
    },

    /// Line box containing inline and text fragments
    ///
    /// Line boxes are generated during inline layout. They contain
    /// inline-level and text fragments arranged horizontally.
    Line {
        /// Baseline position relative to line box top
        baseline: f32,
    },

    /// Replaced element content
    ///
    /// A positioned replaced element (img, canvas, video, etc.)
    Replaced {
        /// Type of replaced content
        replaced_type: ReplacedType,

        /// Index or ID of source BoxNode
        box_id: Option<usize>,
    },
}

/// Types of replaced content
///
/// Mirrors the ReplacedType from box_tree but in fragment context
#[derive(Debug, Clone)]
pub enum ReplacedType {
    /// Image
    Image {
        /// Image source URL or data
        src: String,
    },

    /// Canvas element
    Canvas {
        /// Canvas ID for looking up rendered content
        canvas_id: String,
    },

    /// Video element
    Video {
        /// Video source URL
        src: String,
    },

    /// SVG content
    Svg {
        /// SVG data
        content: String,
    },
}

impl FragmentContent {
    /// Returns true if this is a block fragment
    pub fn is_block(&self) -> bool {
        matches!(self, FragmentContent::Block { .. })
    }

    /// Returns true if this is an inline fragment
    pub fn is_inline(&self) -> bool {
        matches!(self, FragmentContent::Inline { .. })
    }

    /// Returns true if this is a text fragment
    pub fn is_text(&self) -> bool {
        matches!(self, FragmentContent::Text { .. })
    }

    /// Returns true if this is a line fragment
    pub fn is_line(&self) -> bool {
        matches!(self, FragmentContent::Line { .. })
    }

    /// Returns true if this is a replaced element
    pub fn is_replaced(&self) -> bool {
        matches!(self, FragmentContent::Replaced { .. })
    }

    /// Gets the text content if this is a text fragment
    pub fn text(&self) -> Option<&str> {
        match self {
            FragmentContent::Text { text, .. } => Some(text),
            _ => None,
        }
    }
}
```

### Step 3: Define FragmentNode Struct (Estimated: 1.5 hours)

**What to do:**
1. Define struct with bounds, content, children
2. Add convenience constructors
3. Add basic methods

**Code:**

```rust
/// A single fragment in the fragment tree
///
/// Represents a laid-out box with a definite position and size.
///
/// # Examples
///
/// ```
/// use fastrender::tree::{FragmentNode, FragmentContent};
/// use fastrender::geometry::Rect;
///
/// let fragment = FragmentNode::new_block(
///     Rect::from_xywh(0.0, 0.0, 100.0, 50.0),
///     vec![],
/// );
///
/// assert_eq!(fragment.bounds.width(), 100.0);
/// assert!(fragment.content.is_block());
/// ```
#[derive(Debug, Clone)]
pub struct FragmentNode {
    /// The positioned rectangle of this fragment
    ///
    /// This is the final computed position and size after layout.
    /// All coordinates are in the coordinate space of the containing fragment.
    pub bounds: Rect,

    /// The content type of this fragment
    pub content: FragmentContent,

    /// Child fragments
    ///
    /// For block fragments: block and line children
    /// For line fragments: inline and text children
    /// For inline/text/replaced: typically empty
    pub children: Vec<FragmentNode>,
}

impl FragmentNode {
    /// Creates a new fragment with the given bounds, content, and children
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::tree::{FragmentNode, FragmentContent};
    /// use fastrender::geometry::Rect;
    ///
    /// let bounds = Rect::from_xywh(10.0, 20.0, 100.0, 50.0);
    /// let content = FragmentContent::Block { box_id: None };
    /// let fragment = FragmentNode::new(bounds, content, vec![]);
    ///
    /// assert_eq!(fragment.bounds.x(), 10.0);
    /// ```
    pub fn new(bounds: Rect, content: FragmentContent, children: Vec<FragmentNode>) -> Self {
        Self {
            bounds,
            content,
            children,
        }
    }

    /// Creates a new block fragment
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::tree::FragmentNode;
    /// use fastrender::geometry::Rect;
    ///
    /// let fragment = FragmentNode::new_block(
    ///     Rect::from_xywh(0.0, 0.0, 200.0, 100.0),
    ///     vec![],
    /// );
    ///
    /// assert!(fragment.content.is_block());
    /// ```
    pub fn new_block(bounds: Rect, children: Vec<FragmentNode>) -> Self {
        Self::new(
            bounds,
            FragmentContent::Block { box_id: None },
            children,
        )
    }

    /// Creates a new block fragment with a box ID
    pub fn new_block_with_id(
        bounds: Rect,
        box_id: usize,
        children: Vec<FragmentNode>,
    ) -> Self {
        Self::new(
            bounds,
            FragmentContent::Block {
                box_id: Some(box_id),
            },
            children,
        )
    }

    /// Creates a new inline fragment
    pub fn new_inline(bounds: Rect, fragment_index: usize, children: Vec<FragmentNode>) -> Self {
        Self::new(
            bounds,
            FragmentContent::Inline {
                box_id: None,
                fragment_index,
            },
            children,
        )
    }

    /// Creates a new text fragment
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::tree::FragmentNode;
    /// use fastrender::geometry::Rect;
    ///
    /// let fragment = FragmentNode::new_text(
    ///     Rect::from_xywh(0.0, 0.0, 50.0, 20.0),
    ///     "Hello".to_string(),
    ///     16.0, // baseline offset
    /// );
    ///
    /// assert!(fragment.content.is_text());
    /// assert_eq!(fragment.content.text(), Some("Hello"));
    /// ```
    pub fn new_text(bounds: Rect, text: String, baseline_offset: f32) -> Self {
        Self::new(
            bounds,
            FragmentContent::Text {
                text,
                box_id: None,
                baseline_offset,
            },
            vec![],
        )
    }

    /// Creates a new line fragment
    pub fn new_line(bounds: Rect, baseline: f32, children: Vec<FragmentNode>) -> Self {
        Self::new(bounds, FragmentContent::Line { baseline }, children)
    }

    /// Creates a new replaced element fragment
    pub fn new_replaced(bounds: Rect, replaced_type: ReplacedType) -> Self {
        Self::new(
            bounds,
            FragmentContent::Replaced {
                replaced_type,
                box_id: None,
            },
            vec![],
        )
    }

    /// Returns the number of children
    pub fn child_count(&self) -> usize {
        self.children.len()
    }

    /// Returns true if this fragment has no children
    pub fn is_leaf(&self) -> bool {
        self.children.is_empty()
    }
}
```

### Step 4: Implement Geometric Methods (Estimated: 1.5 hours)

**What to do:**
1. Add bounding_box() for subtree
2. Add translate() for moving fragments
3. Add hit testing methods
4. Add tree traversal

**Code:**

```rust
impl FragmentNode {
    /// Computes the bounding box of this fragment and all its children
    ///
    /// Returns the minimal rectangle that contains this fragment and all
    /// descendants. Useful for paint invalidation and scrolling.
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::tree::FragmentNode;
    /// use fastrender::geometry::Rect;
    ///
    /// let child1 = FragmentNode::new_block(
    ///     Rect::from_xywh(0.0, 0.0, 50.0, 50.0),
    ///     vec![],
    /// );
    /// let child2 = FragmentNode::new_block(
    ///     Rect::from_xywh(60.0, 0.0, 50.0, 50.0),
    ///     vec![],
    /// );
    /// let parent = FragmentNode::new_block(
    ///     Rect::from_xywh(0.0, 0.0, 200.0, 100.0),
    ///     vec![child1, child2],
    /// );
    ///
    /// let bbox = parent.bounding_box();
    /// // Should encompass parent and both children
    /// assert_eq!(bbox.min_x(), 0.0);
    /// assert_eq!(bbox.max_x(), 200.0);
    /// ```
    pub fn bounding_box(&self) -> Rect {
        // Start with this fragment's bounds
        let mut bbox = self.bounds;

        // Union with all children's bounding boxes
        for child in &self.children {
            let child_bbox = child.bounding_box();
            bbox = bbox.union(child_bbox);
        }

        bbox
    }

    /// Translates this fragment and all children by the given offset
    ///
    /// This is useful when repositioning a subtree during layout or
    /// when computing absolute positions.
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::tree::FragmentNode;
    /// use fastrender::geometry::{Rect, Point};
    ///
    /// let fragment = FragmentNode::new_block(
    ///     Rect::from_xywh(10.0, 20.0, 100.0, 50.0),
    ///     vec![],
    /// );
    ///
    /// let translated = fragment.translate(Point::new(5.0, 10.0));
    /// assert_eq!(translated.bounds.x(), 15.0);
    /// assert_eq!(translated.bounds.y(), 30.0);
    /// ```
    pub fn translate(&self, offset: Point) -> Self {
        Self {
            bounds: self.bounds.translate(offset),
            content: self.content.clone(),
            children: self
                .children
                .iter()
                .map(|child| child.translate(offset))
                .collect(),
        }
    }

    /// Returns true if this fragment contains the given point
    ///
    /// Checks only this fragment's bounds, not children.
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::tree::FragmentNode;
    /// use fastrender::geometry::{Rect, Point};
    ///
    /// let fragment = FragmentNode::new_block(
    ///     Rect::from_xywh(10.0, 10.0, 100.0, 100.0),
    ///     vec![],
    /// );
    ///
    /// assert!(fragment.contains_point(Point::new(50.0, 50.0)));
    /// assert!(!fragment.contains_point(Point::new(5.0, 5.0)));
    /// ```
    pub fn contains_point(&self, point: Point) -> bool {
        self.bounds.contains_point(point)
    }

    /// Finds all fragments at the given point
    ///
    /// Returns fragments in reverse paint order (topmost first).
    /// This is useful for hit testing and event handling.
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::tree::FragmentNode;
    /// use fastrender::geometry::{Rect, Point};
    ///
    /// let child = FragmentNode::new_block(
    ///     Rect::from_xywh(20.0, 20.0, 30.0, 30.0),
    ///     vec![],
    /// );
    /// let parent = FragmentNode::new_block(
    ///     Rect::from_xywh(0.0, 0.0, 100.0, 100.0),
    ///     vec![child],
    /// );
    ///
    /// let hits = parent.fragments_at_point(Point::new(25.0, 25.0));
    /// // Should find both child and parent
    /// assert_eq!(hits.len(), 2);
    /// ```
    pub fn fragments_at_point(&self, point: Point) -> Vec<&FragmentNode> {
        let mut result = Vec::new();

        // Check children first (reverse paint order = depth-first, reversed)
        for child in self.children.iter().rev() {
            result.extend(child.fragments_at_point(point));
        }

        // Check this fragment
        if self.contains_point(point) {
            result.push(self);
        }

        result
    }

    /// Iterates over all fragments in paint order (depth-first, pre-order)
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::tree::FragmentNode;
    /// use fastrender::geometry::Rect;
    ///
    /// let child1 = FragmentNode::new_block(
    ///     Rect::from_xywh(0.0, 0.0, 50.0, 50.0),
    ///     vec![],
    /// );
    /// let child2 = FragmentNode::new_block(
    ///     Rect::from_xywh(0.0, 50.0, 50.0, 50.0),
    ///     vec![],
    /// );
    /// let parent = FragmentNode::new_block(
    ///     Rect::from_xywh(0.0, 0.0, 100.0, 100.0),
    ///     vec![child1, child2],
    /// );
    ///
    /// let all_fragments: Vec<_> = parent.iter_fragments().collect();
    /// assert_eq!(all_fragments.len(), 3); // parent + 2 children
    /// ```
    pub fn iter_fragments(&self) -> FragmentIterator {
        FragmentIterator {
            stack: vec![self],
        }
    }

    /// Returns an iterator over direct children
    pub fn children(&self) -> impl Iterator<Item = &FragmentNode> {
        self.children.iter()
    }
}

/// Iterator over fragments in paint order (depth-first, pre-order)
pub struct FragmentIterator<'a> {
    stack: Vec<&'a FragmentNode>,
}

impl<'a> Iterator for FragmentIterator<'a> {
    type Item = &'a FragmentNode;

    fn next(&mut self) -> Option<Self::Item> {
        if let Some(fragment) = self.stack.pop() {
            // Push children in reverse order so they're processed in correct order
            for child in fragment.children.iter().rev() {
                self.stack.push(child);
            }
            Some(fragment)
        } else {
            None
        }
    }
}
```

### Step 5: Define FragmentTree Wrapper (Estimated: 30min)

**What to do:**
1. Create wrapper struct
2. Add convenience methods
3. Add tree-level operations

**Code:**

```rust
/// The fragment tree - output of layout
///
/// Contains the root fragment and provides tree-level operations.
///
/// # Examples
///
/// ```
/// use fastrender::tree::{FragmentTree, FragmentNode};
/// use fastrender::geometry::Rect;
///
/// let root = FragmentNode::new_block(
///     Rect::from_xywh(0.0, 0.0, 800.0, 600.0),
///     vec![],
/// );
/// let tree = FragmentTree::new(root);
///
/// assert_eq!(tree.viewport_size().width, 800.0);
/// ```
#[derive(Debug, Clone)]
pub struct FragmentTree {
    /// The root fragment (usually the viewport or document root)
    pub root: FragmentNode,
}

impl FragmentTree {
    /// Creates a new fragment tree with the given root
    pub fn new(root: FragmentNode) -> Self {
        Self { root }
    }

    /// Returns the viewport size (root fragment size)
    pub fn viewport_size(&self) -> Size {
        self.root.bounds.size
    }

    /// Computes the total bounding box of all content
    pub fn content_size(&self) -> Rect {
        self.root.bounding_box()
    }

    /// Finds all fragments at the given point
    pub fn hit_test(&self, point: Point) -> Vec<&FragmentNode> {
        self.root.fragments_at_point(point)
    }

    /// Returns an iterator over all fragments in paint order
    pub fn iter_fragments(&self) -> FragmentIterator {
        self.root.iter_fragments()
    }

    /// Counts total number of fragments in the tree
    pub fn fragment_count(&self) -> usize {
        self.iter_fragments().count()
    }
}

impl fmt::Display for FragmentTree {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "FragmentTree(fragments: {})", self.fragment_count())
    }
}
```

### Step 6: Write Comprehensive Tests (Estimated: 1.5 hours)

**What to do:**
1. Test all constructors
2. Test geometric methods
3. Test hit testing
4. Test tree traversal

**Code:**

```rust
#[cfg(test)]
mod tests {
    use super::*;

    // Constructor tests
    #[test]
    fn test_new_block_fragment() {
        let fragment = FragmentNode::new_block(
            Rect::from_xywh(10.0, 20.0, 100.0, 50.0),
            vec![],
        );

        assert_eq!(fragment.bounds.x(), 10.0);
        assert_eq!(fragment.bounds.y(), 20.0);
        assert!(fragment.content.is_block());
        assert_eq!(fragment.child_count(), 0);
    }

    #[test]
    fn test_new_text_fragment() {
        let fragment = FragmentNode::new_text(
            Rect::from_xywh(0.0, 0.0, 50.0, 20.0),
            "Hello World".to_string(),
            16.0,
        );

        assert!(fragment.content.is_text());
        assert_eq!(fragment.content.text(), Some("Hello World"));
    }

    #[test]
    fn test_new_inline_fragment() {
        let fragment = FragmentNode::new_inline(
            Rect::from_xywh(0.0, 0.0, 100.0, 20.0),
            0,
            vec![],
        );

        assert!(fragment.content.is_inline());
    }

    #[test]
    fn test_new_line_fragment() {
        let text = FragmentNode::new_text(
            Rect::from_xywh(0.0, 0.0, 50.0, 20.0),
            "Text".to_string(),
            16.0,
        );
        let line = FragmentNode::new_line(
            Rect::from_xywh(0.0, 0.0, 200.0, 20.0),
            16.0,
            vec![text],
        );

        assert!(line.content.is_line());
        assert_eq!(line.child_count(), 1);
    }

    // Bounding box tests
    #[test]
    fn test_bounding_box_single() {
        let fragment = FragmentNode::new_block(
            Rect::from_xywh(10.0, 20.0, 100.0, 50.0),
            vec![],
        );

        let bbox = fragment.bounding_box();
        assert_eq!(bbox, fragment.bounds);
    }

    #[test]
    fn test_bounding_box_with_children() {
        let child1 = FragmentNode::new_block(
            Rect::from_xywh(0.0, 0.0, 50.0, 50.0),
            vec![],
        );
        let child2 = FragmentNode::new_block(
            Rect::from_xywh(60.0, 0.0, 50.0, 50.0),
            vec![],
        );
        let parent = FragmentNode::new_block(
            Rect::from_xywh(0.0, 0.0, 200.0, 100.0),
            vec![child1, child2],
        );

        let bbox = parent.bounding_box();
        assert_eq!(bbox.min_x(), 0.0);
        assert_eq!(bbox.max_x(), 200.0);
        assert_eq!(bbox.min_y(), 0.0);
        assert_eq!(bbox.max_y(), 100.0);
    }

    #[test]
    fn test_bounding_box_nested() {
        let grandchild = FragmentNode::new_block(
            Rect::from_xywh(150.0, 150.0, 50.0, 50.0),
            vec![],
        );
        let child = FragmentNode::new_block(
            Rect::from_xywh(50.0, 50.0, 100.0, 100.0),
            vec![grandchild],
        );
        let parent = FragmentNode::new_block(
            Rect::from_xywh(0.0, 0.0, 200.0, 200.0),
            vec![child],
        );

        let bbox = parent.bounding_box();
        // Should include grandchild at (150, 150) with size (50, 50)
        assert_eq!(bbox.min_x(), 0.0);
        assert_eq!(bbox.max_x(), 200.0);
        assert_eq!(bbox.max_y(), 200.0);
    }

    // Translation tests
    #[test]
    fn test_translate_single() {
        let fragment = FragmentNode::new_block(
            Rect::from_xywh(10.0, 20.0, 100.0, 50.0),
            vec![],
        );

        let translated = fragment.translate(Point::new(5.0, 10.0));
        assert_eq!(translated.bounds.x(), 15.0);
        assert_eq!(translated.bounds.y(), 30.0);
        assert_eq!(translated.bounds.width(), 100.0);
    }

    #[test]
    fn test_translate_with_children() {
        let child = FragmentNode::new_block(
            Rect::from_xywh(10.0, 10.0, 30.0, 30.0),
            vec![],
        );
        let parent = FragmentNode::new_block(
            Rect::from_xywh(0.0, 0.0, 100.0, 100.0),
            vec![child],
        );

        let translated = parent.translate(Point::new(50.0, 50.0));
        assert_eq!(translated.bounds.x(), 50.0);
        assert_eq!(translated.bounds.y(), 50.0);
        assert_eq!(translated.children[0].bounds.x(), 60.0);
        assert_eq!(translated.children[0].bounds.y(), 60.0);
    }

    // Hit testing tests
    #[test]
    fn test_contains_point() {
        let fragment = FragmentNode::new_block(
            Rect::from_xywh(10.0, 10.0, 100.0, 100.0),
            vec![],
        );

        assert!(fragment.contains_point(Point::new(50.0, 50.0)));
        assert!(fragment.contains_point(Point::new(10.0, 10.0))); // Boundary
        assert!(fragment.contains_point(Point::new(110.0, 110.0))); // Boundary
        assert!(!fragment.contains_point(Point::new(5.0, 5.0)));
        assert!(!fragment.contains_point(Point::new(120.0, 120.0)));
    }

    #[test]
    fn test_fragments_at_point_single() {
        let fragment = FragmentNode::new_block(
            Rect::from_xywh(0.0, 0.0, 100.0, 100.0),
            vec![],
        );

        let hits = fragment.fragments_at_point(Point::new(50.0, 50.0));
        assert_eq!(hits.len(), 1);
    }

    #[test]
    fn test_fragments_at_point_with_children() {
        let child = FragmentNode::new_block(
            Rect::from_xywh(20.0, 20.0, 30.0, 30.0),
            vec![],
        );
        let parent = FragmentNode::new_block(
            Rect::from_xywh(0.0, 0.0, 100.0, 100.0),
            vec![child],
        );

        // Point in child
        let hits = parent.fragments_at_point(Point::new(25.0, 25.0));
        assert_eq!(hits.len(), 2); // Both child and parent

        // Point only in parent
        let hits = parent.fragments_at_point(Point::new(5.0, 5.0));
        assert_eq!(hits.len(), 1); // Only parent
    }

    #[test]
    fn test_fragments_at_point_overlapping() {
        let child1 = FragmentNode::new_block(
            Rect::from_xywh(10.0, 10.0, 50.0, 50.0),
            vec![],
        );
        let child2 = FragmentNode::new_block(
            Rect::from_xywh(30.0, 30.0, 50.0, 50.0),
            vec![],
        );
        let parent = FragmentNode::new_block(
            Rect::from_xywh(0.0, 0.0, 100.0, 100.0),
            vec![child1, child2],
        );

        // Point in overlapping region
        let hits = parent.fragments_at_point(Point::new(40.0, 40.0));
        assert_eq!(hits.len(), 3); // Both children and parent
        // child2 should come first (reverse paint order)
    }

    // Tree traversal tests
    #[test]
    fn test_iter_fragments_single() {
        let fragment = FragmentNode::new_block(
            Rect::from_xywh(0.0, 0.0, 100.0, 100.0),
            vec![],
        );

        let count = fragment.iter_fragments().count();
        assert_eq!(count, 1);
    }

    #[test]
    fn test_iter_fragments_with_children() {
        let child1 = FragmentNode::new_block(
            Rect::from_xywh(0.0, 0.0, 50.0, 50.0),
            vec![],
        );
        let child2 = FragmentNode::new_block(
            Rect::from_xywh(0.0, 50.0, 50.0, 50.0),
            vec![],
        );
        let parent = FragmentNode::new_block(
            Rect::from_xywh(0.0, 0.0, 100.0, 100.0),
            vec![child1, child2],
        );

        let fragments: Vec<_> = parent.iter_fragments().collect();
        assert_eq!(fragments.len(), 3); // parent + 2 children
        // First should be parent (pre-order)
        assert_eq!(fragments[0].bounds, parent.bounds);
    }

    // FragmentTree tests
    #[test]
    fn test_fragment_tree_creation() {
        let root = FragmentNode::new_block(
            Rect::from_xywh(0.0, 0.0, 800.0, 600.0),
            vec![],
        );
        let tree = FragmentTree::new(root);

        assert_eq!(tree.viewport_size().width, 800.0);
        assert_eq!(tree.viewport_size().height, 600.0);
    }

    #[test]
    fn test_fragment_tree_hit_test() {
        let child = FragmentNode::new_block(
            Rect::from_xywh(100.0, 100.0, 50.0, 50.0),
            vec![],
        );
        let root = FragmentNode::new_block(
            Rect::from_xywh(0.0, 0.0, 800.0, 600.0),
            vec![child],
        );
        let tree = FragmentTree::new(root);

        let hits = tree.hit_test(Point::new(120.0, 120.0));
        assert_eq!(hits.len(), 2); // child and root
    }

    #[test]
    fn test_fragment_tree_count() {
        let child1 = FragmentNode::new_block(
            Rect::from_xywh(0.0, 0.0, 100.0, 100.0),
            vec![],
        );
        let child2 = FragmentNode::new_block(
            Rect::from_xywh(0.0, 100.0, 100.0, 100.0),
            vec![],
        );
        let root = FragmentNode::new_block(
            Rect::from_xywh(0.0, 0.0, 800.0, 600.0),
            vec![child1, child2],
        );
        let tree = FragmentTree::new(root);

        assert_eq!(tree.fragment_count(), 3);
    }

    // Edge case tests
    #[test]
    fn test_empty_tree_traversal() {
        let fragment = FragmentNode::new_block(Rect::from_xywh(0.0, 0.0, 100.0, 100.0), vec![]);

        let fragments: Vec<_> = fragment.iter_fragments().collect();
        assert_eq!(fragments.len(), 1);
    }

    #[test]
    fn test_is_leaf() {
        let leaf = FragmentNode::new_block(Rect::from_xywh(0.0, 0.0, 100.0, 100.0), vec![]);
        assert!(leaf.is_leaf());

        let child = FragmentNode::new_block(Rect::from_xywh(0.0, 0.0, 50.0, 50.0), vec![]);
        let parent = FragmentNode::new_block(
            Rect::from_xywh(0.0, 0.0, 100.0, 100.0),
            vec![child],
        );
        assert!(!parent.is_leaf());
    }
}
```

### Step 7: Documentation and Verification (Estimated: 30min)

**Commands:**

```bash
# Run tests
cargo test tree::fragment_tree

# Check clippy
cargo clippy -- -D warnings

# Format code
cargo fmt

# Generate documentation
cargo doc --no-deps --open
```

## Testing Requirements

### Unit Tests

**Expected:** 20+ tests covering:
- All fragment constructors
- Bounding box computation
- Translation
- Hit testing (simple and complex)
- Tree traversal
- Edge cases

## Output Artifacts

### Code Files

1. **`src/tree/fragment_tree.rs`**
   - FragmentContent enum
   - FragmentNode struct with all methods
   - FragmentTree wrapper
   - Comprehensive tests (~25 tests)

### Notes File

Create: **`outputs/notes/W2.T03-notes.md`**

```markdown
# Task W2.T03 Output Notes

## Implementation Summary

Implemented fragment tree for representing layout results:
- **FragmentContent enum**: 5 variants (Block, Inline, Text, Line, Replaced)
- **FragmentNode struct**: Positioned boxes with bounds, content, children
- **FragmentTree wrapper**: Tree-level operations
- **Geometric methods**: bounding_box(), translate(), hit testing
- **Tree traversal**: Iterator in paint order

Fragments are the output of layout with definite positions and sizes.

## API Contracts

### Public Types

```rust
#[derive(Debug, Clone)]
pub enum FragmentContent {
    Block { box_id: Option<usize> },
    Inline { box_id: Option<usize>, fragment_index: usize },
    Text { text: String, box_id: Option<usize>, baseline_offset: f32 },
    Line { baseline: f32 },
    Replaced { replaced_type: ReplacedType, box_id: Option<usize> },
}

#[derive(Debug, Clone)]
pub struct FragmentNode {
    pub bounds: Rect,
    pub content: FragmentContent,
    pub children: Vec<FragmentNode>,
}

#[derive(Debug, Clone)]
pub struct FragmentTree {
    pub root: FragmentNode,
}
```

### Key Methods

```rust
impl FragmentNode {
    // Constructors
    pub fn new_block(bounds: Rect, children: Vec<FragmentNode>) -> Self;
    pub fn new_text(bounds: Rect, text: String, baseline_offset: f32) -> Self;
    pub fn new_line(bounds: Rect, baseline: f32, children: Vec<FragmentNode>) -> Self;

    // Geometric
    pub fn bounding_box(&self) -> Rect;
    pub fn translate(&self, offset: Point) -> Self;
    pub fn contains_point(&self, point: Point) -> bool;
    pub fn fragments_at_point(&self, point: Point) -> Vec<&FragmentNode>;

    // Tree
    pub fn iter_fragments(&self) -> FragmentIterator;
    pub fn children(&self) -> impl Iterator<Item = &FragmentNode>;
}

impl FragmentTree {
    pub fn new(root: FragmentNode) -> Self;
    pub fn hit_test(&self, point: Point) -> Vec<&FragmentNode>;
    pub fn fragment_count(&self) -> usize;
}
```

## Decisions Made

### Decision 1: Fragments Store Rect Directly

**Choice:** FragmentNode has `bounds: Rect` field
**Rationale:**
- Fragments always have position and size
- Rect is the natural representation
- Avoids Option<Rect> complexity
- Efficient (Rect is Copy)

**Impact:** All fragments must be positioned when created

### Decision 2: Clone for Tree Modification

**Choice:** translate() returns new tree (clones)
**Rationale:**
- Fragments are typically created once per layout
- Cloning is simpler than mutation
- Enables immutable API
- Fragment trees not huge (< 10k nodes typically)

**Alternatives Considered:** Mutable translate_mut() → rejected, complicates ownership

### Decision 3: box_id as Optional

**Choice:** box_id: Option<usize> for linking to source
**Rationale:**
- Not all fragments come from boxes (anonymous)
- usize is placeholder (will use better ID later)
- Optional allows generated fragments

**Future:** Replace with Arc<BoxNode> or proper ID type

## Spec Interpretations

### Fragment Splitting

**Spec says:** Inline boxes can split across lines
**Interpretation:** One inline box → multiple inline fragments
**Implementation:** fragment_index tracks which split this is
**Test coverage:** Not tested yet (needs inline layout)

## Discoveries & Gotchas

### Discovery 1: Hit Testing Order Matters

**What:** fragments_at_point returns in reverse paint order
**Why it matters:** Topmost (last painted) should be first hit
**Recommendation:** Paint uses forward order, hit test uses reverse

### Gotcha 1: Bounding Box vs Bounds

**Problem:** bounding_box() includes children, bounds doesn't
**Solution:** Use bounds for this fragment, bounding_box() for subtree
**Warning:** Don't confuse these when computing overflow

### Gotcha 2: Relative Coordinates

**Problem:** Child bounds are relative to parent
**Solution:** Use translate() to convert to absolute coordinates
**Example:** Child at (10, 10) in parent at (100, 100) is at (110, 110) absolute

## Performance Notes

### Performance Characteristics
- Clone is O(n) for tree size
- Hit testing is O(depth × overlaps)
- Tree traversal is O(n)
- bounding_box is O(n) with caching potential

### Optimization Opportunities
- Cache bounding boxes if fragments immutable
- Use spatial index for hit testing (quadtree)
- Consider arena allocation for fragments

## Recommendations for Downstream Tasks

### For Task W3.T04 (Block Layout):
- Create FragmentNode for each positioned block
- Use new_block() constructor
- Set bounds after computing position and size
- Add children in document order

### For Task W4.T12 (Inline Layout):
- Create line fragments with new_line()
- Create text fragments with new_text()
- Set baseline_offset for proper text alignment
- Handle inline box splitting with fragment_index

### For Task W5.T01 (Paint):
- Use iter_fragments() for paint order
- Paint in forward order (depth-first)
- Use bounds for clipping
- Use content type to dispatch paint method

### For Task W6.T02 (Hit Testing):
- Use hit_test() on FragmentTree
- Check topmost fragment first (reverse paint order)
- Use box_id to link back to DOM

## Open Questions

None - fragment design is straightforward.

## Test Coverage

### What's Tested
- ✅ All constructors
- ✅ Bounding box computation
- ✅ Translation
- ✅ Hit testing (single and nested)
- ✅ Tree traversal
- ✅ FragmentTree operations

### Test Statistics
- Unit tests: 25 tests
- All tests pass: ✅
- Coverage: All public methods

## Code Quality
- ✅ Clippy passes
- ✅ Rustfmt applied
- ✅ Full documentation
- ✅ Examples in rustdoc

## References Used
1. W1.T01-notes.md (Geometry types)
2. CSS 2.1 Section 9 (Visual formatting)
3. CSS Fragmentation Module Level 3

---

**Task completed:** [DATE]
**Time taken:** 5 hours
**Tests passing:** 25/25
```

## Common Pitfalls to Avoid

### Pitfall 1: Forgetting to Position Fragments

**Wrong:** Creating fragment without setting bounds
**Right:** Always set bounds when creating fragment

### Pitfall 2: Confusing Bounds and Bounding Box

**Wrong:** Using bounds for subtree size
**Right:** Use bounds for this fragment, bounding_box() for subtree

### Pitfall 3: Wrong Hit Test Order

**Wrong:** Returning fragments in paint order
**Right:** Return in reverse paint order (topmost first)

## Verification Checklist

- [ ] All objectives met
- [ ] FragmentContent enum complete
- [ ] FragmentNode with all methods
- [ ] FragmentTree wrapper
- [ ] Geometric methods working
- [ ] Hit testing correct
- [ ] Tests pass: `cargo test tree::fragment_tree`
- [ ] Clippy clean
- [ ] Documentation complete
- [ ] Notes file created

## Time Tracking

- **Module setup:** 15min
- **FragmentContent enum:** 1hr
- **FragmentNode struct:** 1.5hrs
- **Geometric methods:** 1.5hrs
- **FragmentTree:** 30min
- **Testing:** 1.5hrs
- **Documentation:** 30min
- **Total:** 4-6 hours

## Getting Help

If stuck:
1. **W1.T01-notes.md**: Geometry API details
2. **CSS 2.1 Visual formatting**: Box and fragment concepts
3. **WebRender fragments**: Reference implementation
