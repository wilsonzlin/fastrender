---
task_id: "W2.T08"
title: "Implement FormattingContextType Enum and Derivation Logic"
wave: 2
estimated_hours: 2-3
depends_on:
  - "W1.T05"
inputs:
  - "outputs/notes/W1.T05-notes.md"
  - "src/style/display.rs"
outputs:
  - "src/layout/contexts/types.rs"
  - "src/layout/contexts/mod.rs"
  - "outputs/notes/W2.T08-notes.md"
skills_required:
  - "Rust"
  - "CSS display property"
  - "Formatting context rules"
context_files:
  - "docs/plan/01-formatting-contexts.md"
  - "outputs/notes/W1.R01-notes.md"
verification:
  - "cargo test layout::contexts::types"
  - "cargo clippy -- -D warnings"
---

# Implement FormattingContextType Enum and Derivation Logic

## Context

In CSS layout, every container establishes a **formatting context** that determines how its children are laid out. The `FormattingContextType` enum is the critical discriminator that tells the layout engine which layout algorithm to use.

This is a **Wave 2** foundational task that bridges styling and layout. It answers the fundamental question: "Given a box with certain styles, what kind of formatting context does it establish?"

### Background

**What is a Formatting Context?**

From CSS 2.1 Section 9.4:
> "Boxes in the normal flow belong to a formatting context, which may be block or inline, but not both simultaneously."

Different formatting contexts have completely different layout rules:
- **Block Formatting Context (BFC)**: Children stack vertically, margins collapse
- **Inline Formatting Context (IFC)**: Children flow horizontally, wrap at line boundaries
- **Flex Formatting Context**: Flexbox algorithm applies
- **Grid Formatting Context**: 2D grid positioning
- **Table Formatting Context**: Table-specific layout rules

**How is the FC Type Determined?**

The formatting context type is derived from the `display` property:
- `display: block` → Block FC
- `display: flex` → Flex FC
- `display: grid` → Grid FC
- `display: table` → Table FC
- Container of inline content → Inline FC

Some elements establish BFCs even with `display: block`:
- Elements with `overflow` other than `visible`
- Floated elements
- Absolutely positioned elements
- Inline-blocks

### Why This Matters

The FormattingContextType enum is consumed by:
- **W2.T09**: FC Factory (uses type to create appropriate FC)
- **W2.T10**: LayoutEngine (queries type to dispatch layout)
- **W3.T04**: BlockFormattingContext implementation
- **W4.T12**: InlineFormattingContext implementation

Without this enum:
- Can't determine which layout algorithm to use
- Can't distinguish between different layout modes
- Can't implement the factory pattern for FCs
- Can't build the layout engine dispatcher

Every layout decision starts with determining the FC type.

## Prerequisites

### Required Knowledge
- **CSS display property**: All display values and their meanings
- **CSS formatting contexts**: BFC, IFC, Flex, Grid, Table
- **BFC triggering**: What creates a BFC vs regular block container
- **Rust enums**: Discriminated unions with methods

### Required Reading
1. **outputs/notes/W1.T05-notes.md**: Display type API
2. **outputs/notes/W1.R01-notes.md**: CSS formatting context concepts
3. **CSS Display Module Level 3**: https://www.w3.org/TR/css-display-3/
4. **CSS 2.1 Section 9.4**: Block formatting contexts

## Inputs

### From Dependencies

1. **W1.T05-notes.md** (Display property)
   - Look for: Display enum variants
   - Look for: Inner and outer display types
   - Key insight: Inner display determines FC type

### Existing Code

Read these files:
- `src/style/display.rs` - Display type implementation
- `src/style/values.rs` - Other style properties (overflow, position, float)
- `docs/plan/01-formatting-contexts.md` - FC architecture

## Objectives

### Primary Goals

1. **Define FormattingContextType enum**: All FC types
2. **Implement derivation logic**: Display → FC type mapping
3. **Handle BFC triggering**: Overflow, float, position, etc.
4. **Add helper methods**: Query FC capabilities
5. **Document FC rules**: When each type applies
6. **Comprehensive tests**: All derivation paths
7. **Integration ready**: For factory and engine

### Success Criteria

- [ ] FormattingContextType enum with 5 variants
- [ ] derive_from_display() function complete
- [ ] is_bfc_trigger() helper for BFC edge cases
- [ ] Helper methods: is_block_container(), establishes_ifc(), etc.
- [ ] Display trait implementation
- [ ] All types derive Debug, Clone, Copy, PartialEq, Eq
- [ ] 20+ comprehensive tests covering all cases
- [ ] All tests pass
- [ ] Clippy clean, documentation complete
- [ ] Notes file comprehensive

## Implementation Guide

### Step 1: Create Contexts Module Structure (Estimated: 15min)

**What to do:**
1. Create `src/layout/contexts/` directory
2. Create `src/layout/contexts/types.rs`
3. Create `src/layout/contexts/mod.rs`
4. Update parent modules

**Code:**

```bash
mkdir -p src/layout/contexts
touch src/layout/contexts/types.rs
touch src/layout/contexts/mod.rs
```

**`src/layout/contexts/mod.rs`:**
```rust
//! Formatting context types and factory
//!
//! This module contains:
//! - FormattingContextType enum (discriminator)
//! - FormattingContext factory (creates appropriate FC)

pub mod types;

// Re-exports
pub use types::FormattingContextType;
```

**Update `src/layout/mod.rs`** (add):
```rust
pub mod contexts;
pub use contexts::FormattingContextType;
```

### Step 2: Define FormattingContextType Enum (Estimated: 30min)

**What to do:**
1. Define enum with all formatting context types
2. Add comprehensive documentation
3. Derive standard traits

**Code in `src/layout/contexts/types.rs`:**

```rust
//! Formatting context type determination
//!
//! This module determines what kind of formatting context a box establishes
//! based on its display type and other properties.

use std::fmt;

/// Types of formatting contexts
///
/// A formatting context is an environment in which boxes are laid out.
/// Different formatting contexts have different layout rules.
///
/// # Formatting Context Types
///
/// ## Block Formatting Context (BFC)
///
/// In a BFC, block-level boxes are laid out vertically, one after another.
/// Margins collapse between siblings. This is the default for most block
/// containers.
///
/// **Established by:**
/// - Block containers that are not inline-block
/// - Elements with `overflow` other than `visible`
/// - Floated elements
/// - Absolutely positioned elements
///
/// **Reference:** CSS 2.1 Section 9.4.1
///
/// ## Inline Formatting Context (IFC)
///
/// In an IFC, inline-level boxes are laid out horizontally within lines.
/// Text wraps at line boundaries. Line boxes are stacked vertically.
///
/// **Established by:**
/// - Block containers containing inline-level children
///
/// **Reference:** CSS 2.1 Section 9.4.2
///
/// ## Flex Formatting Context
///
/// In a flex FC, flex items are laid out using the flexbox algorithm.
/// Items can be arranged in rows or columns, with flexible sizing.
///
/// **Established by:**
/// - Elements with `display: flex` or `display: inline-flex`
///
/// **Reference:** CSS Flexbox Module Level 1
///
/// ## Grid Formatting Context
///
/// In a grid FC, grid items are positioned in a 2D grid of rows and columns.
/// Items can span multiple cells.
///
/// **Established by:**
/// - Elements with `display: grid` or `display: inline-grid`
///
/// **Reference:** CSS Grid Layout Module Level 1
///
/// ## Table Formatting Context
///
/// In a table FC, children are laid out as table rows, columns, and cells.
/// Table-specific sizing and alignment rules apply.
///
/// **Established by:**
/// - Elements with `display: table`, `table-row`, `table-cell`, etc.
///
/// **Reference:** CSS 2.1 Section 17
///
/// # Examples
///
/// ```
/// use fastrender::layout::FormattingContextType;
///
/// let fc_type = FormattingContextType::BlockFormatting;
/// assert!(fc_type.is_block_container());
/// ```
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum FormattingContextType {
    /// Block Formatting Context (BFC)
    ///
    /// Block-level boxes stack vertically, margins collapse.
    BlockFormatting,

    /// Inline Formatting Context (IFC)
    ///
    /// Inline-level boxes flow horizontally within lines.
    InlineFormatting,

    /// Flex Formatting Context
    ///
    /// Children laid out using flexbox algorithm.
    FlexFormatting,

    /// Grid Formatting Context
    ///
    /// Children positioned in 2D grid.
    GridFormatting,

    /// Table Formatting Context
    ///
    /// Table-specific layout rules apply.
    TableFormatting,
}

impl fmt::Display for FormattingContextType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::BlockFormatting => write!(f, "Block FC"),
            Self::InlineFormatting => write!(f, "Inline FC"),
            Self::FlexFormatting => write!(f, "Flex FC"),
            Self::GridFormatting => write!(f, "Grid FC"),
            Self::TableFormatting => write!(f, "Table FC"),
        }
    }
}
```

### Step 3: Implement Helper Methods (Estimated: 45min)

**What to do:**
1. Add query methods for FC capabilities
2. Add classification helpers
3. Document each method's purpose

**Code:**

```rust
impl FormattingContextType {
    /// Returns true if this is a block formatting context
    ///
    /// BFCs have specific behaviors:
    /// - Vertical margin collapsing
    /// - Float containment
    /// - Prevent margin collapse with children
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::layout::FormattingContextType;
    ///
    /// assert!(FormattingContextType::BlockFormatting.is_bfc());
    /// assert!(!FormattingContextType::InlineFormatting.is_bfc());
    /// ```
    pub fn is_bfc(&self) -> bool {
        matches!(self, Self::BlockFormatting)
    }

    /// Returns true if this is an inline formatting context
    pub fn is_ifc(&self) -> bool {
        matches!(self, Self::InlineFormatting)
    }

    /// Returns true if this is a flex formatting context
    pub fn is_flex(&self) -> bool {
        matches!(self, Self::FlexFormatting)
    }

    /// Returns true if this is a grid formatting context
    pub fn is_grid(&self) -> bool {
        matches!(self, Self::GridFormatting)
    }

    /// Returns true if this is a table formatting context
    pub fn is_table(&self) -> bool {
        matches!(self, Self::TableFormatting)
    }

    /// Returns true if this FC can contain block-level boxes
    ///
    /// BFC and Table FC can contain block-level boxes.
    /// IFC, Flex, and Grid treat all children as their respective item types.
    pub fn can_contain_blocks(&self) -> bool {
        matches!(self, Self::BlockFormatting | Self::TableFormatting)
    }

    /// Returns true if this FC requires line breaking
    ///
    /// Only IFC performs line breaking. Other FCs use different layout rules.
    pub fn requires_line_breaking(&self) -> bool {
        matches!(self, Self::InlineFormatting)
    }

    /// Returns true if this FC supports flexible sizing
    ///
    /// Flex and Grid support flexible item sizing.
    pub fn supports_flexible_sizing(&self) -> bool {
        matches!(self, Self::FlexFormatting | Self::GridFormatting)
    }

    /// Returns true if children are laid out in the block axis
    ///
    /// In BFC, children stack vertically (block axis).
    /// In IFC, children flow horizontally (inline axis).
    /// Flex and Grid depend on flex-direction and grid-auto-flow.
    pub fn is_block_axis_primary(&self) -> bool {
        matches!(self, Self::BlockFormatting | Self::TableFormatting)
    }

    /// Returns a short abbreviation for debugging
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::layout::FormattingContextType;
    ///
    /// assert_eq!(FormattingContextType::BlockFormatting.abbrev(), "BFC");
    /// assert_eq!(FormattingContextType::FlexFormatting.abbrev(), "Flex");
    /// ```
    pub fn abbrev(&self) -> &'static str {
        match self {
            Self::BlockFormatting => "BFC",
            Self::InlineFormatting => "IFC",
            Self::FlexFormatting => "Flex",
            Self::GridFormatting => "Grid",
            Self::TableFormatting => "Table",
        }
    }
}
```

### Step 4: Implement Derivation Logic (Estimated: 1 hour)

**What to do:**
1. Create function to derive FC type from display property
2. Handle all display values
3. Document the mapping rules

**Code:**

```rust
use crate::style::display::{Display, DisplayBox, DisplayInside, DisplayOutside};

/// Derives the formatting context type from the display property
///
/// This determines what kind of formatting context an element establishes
/// based on its `display` value.
///
/// # Display to FC Mapping
///
/// - `display: block` → Block FC
/// - `display: flow-root` → Block FC (always establishes BFC)
/// - `display: inline` → Does NOT establish FC (participates in parent's IFC)
/// - `display: flex` / `inline-flex` → Flex FC
/// - `display: grid` / `inline-grid` → Grid FC
/// - `display: table` → Table FC
/// - `display: none` → No box generated
/// - `display: contents` → No principal box (children participate in parent FC)
///
/// # Note on Inline
///
/// Regular `display: inline` elements do NOT establish a formatting context.
/// They participate in their parent's inline formatting context. Only when
/// a block container contains inline children does it establish an IFC.
///
/// # Examples
///
/// ```
/// use fastrender::style::display::{Display, DisplayBox, DisplayInside};
/// use fastrender::layout::contexts::types::derive_fc_from_display;
///
/// let fc = derive_fc_from_display(&Display::Box(DisplayBox::FlowRoot));
/// assert_eq!(fc, Some(FormattingContextType::BlockFormatting));
///
/// let fc = derive_fc_from_display(&Display::Flex);
/// assert_eq!(fc, Some(FormattingContextType::FlexFormatting));
/// ```
pub fn derive_fc_from_display(display: &Display) -> Option<FormattingContextType> {
    match display {
        // Block and flow-root establish BFC
        Display::Box(DisplayBox::Block) | Display::Box(DisplayBox::FlowRoot) => {
            Some(FormattingContextType::BlockFormatting)
        }

        // Inline doesn't establish FC (participates in parent's IFC)
        Display::Box(DisplayBox::Inline) => None,

        // Flex and inline-flex establish flex FC
        Display::Flex | Display::InlineFlex => Some(FormattingContextType::FlexFormatting),

        // Grid and inline-grid establish grid FC
        Display::Grid | Display::InlineGrid => Some(FormattingContextType::GridFormatting),

        // Table establishes table FC
        Display::Table => Some(FormattingContextType::TableFormatting),

        // Table-internal don't establish independent FCs
        Display::TableRow
        | Display::TableCell
        | Display::TableRowGroup
        | Display::TableColumn
        | Display::TableColumnGroup
        | Display::TableHeaderGroup
        | Display::TableFooterGroup
        | Display::TableCaption => None,

        // None means no box generated
        Display::None => None,

        // Contents means no principal box
        Display::Contents => None,

        // Fallback to block for unknown
        _ => Some(FormattingContextType::BlockFormatting),
    }
}

/// Additional properties that can trigger BFC establishment
///
/// Even `display: block` elements establish independent BFCs in certain cases.
/// This struct encapsulates those properties.
///
/// Reference: CSS 2.1 Section 9.4.1 - "Floats, absolutely positioned elements,
/// block containers that are not block boxes, and block boxes with 'overflow'
/// other than 'visible' establish new block formatting contexts."
#[derive(Debug, Clone, Copy)]
pub struct BfcTriggers {
    /// overflow: hidden, scroll, auto, or clip
    pub has_overflow: bool,

    /// float: left or right
    pub is_floated: bool,

    /// position: absolute or fixed
    pub is_absolutely_positioned: bool,

    /// display: inline-block
    pub is_inline_block: bool,

    /// display: flow-root (explicit BFC)
    pub is_flow_root: bool,
}

impl Default for BfcTriggers {
    fn default() -> Self {
        Self {
            has_overflow: false,
            is_floated: false,
            is_absolutely_positioned: false,
            is_inline_block: false,
            is_flow_root: false,
        }
    }
}

impl BfcTriggers {
    /// Returns true if any trigger is active
    ///
    /// If true, the element establishes an independent BFC even with
    /// `display: block`.
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::layout::contexts::types::BfcTriggers;
    ///
    /// let mut triggers = BfcTriggers::default();
    /// assert!(!triggers.triggers_bfc());
    ///
    /// triggers.has_overflow = true;
    /// assert!(triggers.triggers_bfc());
    /// ```
    pub fn triggers_bfc(&self) -> bool {
        self.has_overflow
            || self.is_floated
            || self.is_absolutely_positioned
            || self.is_inline_block
            || self.is_flow_root
    }
}

/// Determines if an element establishes an independent BFC
///
/// This is more nuanced than just checking display. Several properties
/// can cause a block box to establish an independent BFC.
///
/// # Arguments
///
/// * `display` - The display value
/// * `triggers` - Additional BFC-triggering properties
///
/// # Returns
///
/// `true` if the element establishes an independent BFC
///
/// # Examples
///
/// ```
/// use fastrender::style::display::{Display, DisplayBox};
/// use fastrender::layout::contexts::types::{establishes_independent_bfc, BfcTriggers};
///
/// // Regular block doesn't establish independent BFC
/// let display = Display::Box(DisplayBox::Block);
/// assert!(!establishes_independent_bfc(&display, &BfcTriggers::default()));
///
/// // Block with overflow does
/// let mut triggers = BfcTriggers::default();
/// triggers.has_overflow = true;
/// assert!(establishes_independent_bfc(&display, &triggers));
///
/// // flow-root always does
/// let display = Display::Box(DisplayBox::FlowRoot);
/// assert!(establishes_independent_bfc(&display, &BfcTriggers::default()));
/// ```
pub fn establishes_independent_bfc(display: &Display, triggers: &BfcTriggers) -> bool {
    match display {
        // flow-root always establishes BFC
        Display::Box(DisplayBox::FlowRoot) => true,

        // Regular block only if triggered
        Display::Box(DisplayBox::Block) => triggers.triggers_bfc(),

        // Flex, grid, table establish their own FCs (not BFC, but independent)
        Display::Flex
        | Display::InlineFlex
        | Display::Grid
        | Display::InlineGrid
        | Display::Table => true,

        // Inline-block establishes independent BFC
        Display::Box(DisplayBox::InlineBlock) => true,

        // Everything else doesn't
        _ => false,
    }
}
```

### Step 5: Write Comprehensive Tests (Estimated: 45min)

**Add at bottom of file:**

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use crate::style::display::{Display, DisplayBox};

    #[test]
    fn test_fc_type_creation() {
        let fc = FormattingContextType::BlockFormatting;
        assert!(fc.is_bfc());
        assert!(!fc.is_ifc());
        assert_eq!(fc.abbrev(), "BFC");
    }

    #[test]
    fn test_fc_type_display() {
        assert_eq!(
            format!("{}", FormattingContextType::BlockFormatting),
            "Block FC"
        );
        assert_eq!(
            format!("{}", FormattingContextType::FlexFormatting),
            "Flex FC"
        );
    }

    #[test]
    fn test_fc_capabilities() {
        let bfc = FormattingContextType::BlockFormatting;
        assert!(bfc.can_contain_blocks());
        assert!(!bfc.requires_line_breaking());
        assert!(bfc.is_block_axis_primary());

        let ifc = FormattingContextType::InlineFormatting;
        assert!(!ifc.can_contain_blocks());
        assert!(ifc.requires_line_breaking());

        let flex = FormattingContextType::FlexFormatting;
        assert!(flex.supports_flexible_sizing());
    }

    #[test]
    fn test_derive_block() {
        let fc = derive_fc_from_display(&Display::Box(DisplayBox::Block));
        assert_eq!(fc, Some(FormattingContextType::BlockFormatting));
    }

    #[test]
    fn test_derive_flow_root() {
        let fc = derive_fc_from_display(&Display::Box(DisplayBox::FlowRoot));
        assert_eq!(fc, Some(FormattingContextType::BlockFormatting));
    }

    #[test]
    fn test_derive_flex() {
        let fc = derive_fc_from_display(&Display::Flex);
        assert_eq!(fc, Some(FormattingContextType::FlexFormatting));

        let fc = derive_fc_from_display(&Display::InlineFlex);
        assert_eq!(fc, Some(FormattingContextType::FlexFormatting));
    }

    #[test]
    fn test_derive_grid() {
        let fc = derive_fc_from_display(&Display::Grid);
        assert_eq!(fc, Some(FormattingContextType::GridFormatting));

        let fc = derive_fc_from_display(&Display::InlineGrid);
        assert_eq!(fc, Some(FormattingContextType::GridFormatting));
    }

    #[test]
    fn test_derive_table() {
        let fc = derive_fc_from_display(&Display::Table);
        assert_eq!(fc, Some(FormattingContextType::TableFormatting));
    }

    #[test]
    fn test_derive_inline_returns_none() {
        let fc = derive_fc_from_display(&Display::Box(DisplayBox::Inline));
        assert_eq!(fc, None);
    }

    #[test]
    fn test_derive_none_returns_none() {
        let fc = derive_fc_from_display(&Display::None);
        assert_eq!(fc, None);
    }

    #[test]
    fn test_derive_contents_returns_none() {
        let fc = derive_fc_from_display(&Display::Contents);
        assert_eq!(fc, None);
    }

    #[test]
    fn test_bfc_triggers_default() {
        let triggers = BfcTriggers::default();
        assert!(!triggers.triggers_bfc());
    }

    #[test]
    fn test_bfc_triggers_overflow() {
        let mut triggers = BfcTriggers::default();
        triggers.has_overflow = true;
        assert!(triggers.triggers_bfc());
    }

    #[test]
    fn test_bfc_triggers_float() {
        let mut triggers = BfcTriggers::default();
        triggers.is_floated = true;
        assert!(triggers.triggers_bfc());
    }

    #[test]
    fn test_bfc_triggers_position() {
        let mut triggers = BfcTriggers::default();
        triggers.is_absolutely_positioned = true;
        assert!(triggers.triggers_bfc());
    }

    #[test]
    fn test_bfc_triggers_flow_root() {
        let mut triggers = BfcTriggers::default();
        triggers.is_flow_root = true;
        assert!(triggers.triggers_bfc());
    }

    #[test]
    fn test_establishes_independent_bfc_flow_root() {
        let display = Display::Box(DisplayBox::FlowRoot);
        assert!(establishes_independent_bfc(
            &display,
            &BfcTriggers::default()
        ));
    }

    #[test]
    fn test_establishes_independent_bfc_block_default() {
        let display = Display::Box(DisplayBox::Block);
        assert!(!establishes_independent_bfc(
            &display,
            &BfcTriggers::default()
        ));
    }

    #[test]
    fn test_establishes_independent_bfc_block_with_overflow() {
        let display = Display::Box(DisplayBox::Block);
        let mut triggers = BfcTriggers::default();
        triggers.has_overflow = true;
        assert!(establishes_independent_bfc(&display, &triggers));
    }

    #[test]
    fn test_establishes_independent_bfc_inline_block() {
        let display = Display::Box(DisplayBox::InlineBlock);
        assert!(establishes_independent_bfc(
            &display,
            &BfcTriggers::default()
        ));
    }

    #[test]
    fn test_establishes_independent_bfc_flex() {
        let display = Display::Flex;
        assert!(establishes_independent_bfc(
            &display,
            &BfcTriggers::default()
        ));
    }

    #[test]
    fn test_establishes_independent_bfc_grid() {
        let display = Display::Grid;
        assert!(establishes_independent_bfc(
            &display,
            &BfcTriggers::default()
        ));
    }

    #[test]
    fn test_all_fc_types_unique() {
        use std::collections::HashSet;
        let mut set = HashSet::new();
        set.insert(FormattingContextType::BlockFormatting);
        set.insert(FormattingContextType::InlineFormatting);
        set.insert(FormattingContextType::FlexFormatting);
        set.insert(FormattingContextType::GridFormatting);
        set.insert(FormattingContextType::TableFormatting);
        assert_eq!(set.len(), 5);
    }

    #[test]
    fn test_fc_type_equality() {
        let bfc1 = FormattingContextType::BlockFormatting;
        let bfc2 = FormattingContextType::BlockFormatting;
        let ifc = FormattingContextType::InlineFormatting;

        assert_eq!(bfc1, bfc2);
        assert_ne!(bfc1, ifc);
    }

    #[test]
    fn test_fc_type_clone_copy() {
        let fc1 = FormattingContextType::FlexFormatting;
        let fc2 = fc1; // Copy
        let fc3 = fc1.clone(); // Clone

        assert_eq!(fc1, fc2);
        assert_eq!(fc1, fc3);
    }
}
```

### Step 6: Documentation and Verification (Estimated: 15min)

Run verification:
```bash
cargo test layout::contexts::types
cargo clippy -- -D warnings
cargo fmt
cargo doc --no-deps --open
```

## Testing Requirements

Run: `cargo test layout::contexts::types`

Expected: 25+ tests passing covering:
- FC type creation and equality
- Display trait implementation
- Helper methods (is_bfc, can_contain_blocks, etc.)
- Derivation from display (all display values)
- BFC triggers (overflow, float, position, etc.)
- Independent BFC establishment logic
- Edge cases (inline, none, contents)

## Output Artifacts

### Code Files

1. **`src/layout/contexts/types.rs`** (~400-500 lines)
   - FormattingContextType enum
   - Helper methods
   - Derivation functions
   - BfcTriggers struct
   - Comprehensive tests

2. **`src/layout/contexts/mod.rs`** (~10 lines)
   - Module exports

### Notes File

Create: **`outputs/notes/W2.T08-notes.md`**

```markdown
# W2.T08: FormattingContextType Enum - Implementation Notes

## Overview

Implemented FormattingContextType enum and derivation logic for determining
which formatting context a box establishes.

## API Contracts

### FormattingContextType Enum

```rust
pub enum FormattingContextType {
    BlockFormatting,
    InlineFormatting,
    FlexFormatting,
    GridFormatting,
    TableFormatting,
}
```

**Guarantees:**
- Enum is Copy, Clone, PartialEq, Eq, Hash
- Display trait shows human-readable names
- Helper methods are const-compatible where possible

### Helper Methods

- `is_bfc()`, `is_ifc()`, `is_flex()`, `is_grid()`, `is_table()`: Type queries
- `can_contain_blocks()`: True for BFC and Table
- `requires_line_breaking()`: True only for IFC
- `supports_flexible_sizing()`: True for Flex and Grid
- `is_block_axis_primary()`: True for BFC and Table
- `abbrev()`: Short abbreviation for debugging

### Derivation Functions

**derive_fc_from_display(display: &Display) -> Option<FormattingContextType>**

Maps display values to FC types:
- Block/FlowRoot → BlockFormatting
- Flex/InlineFlex → FlexFormatting
- Grid/InlineGrid → GridFormatting
- Table → TableFormatting
- Inline/None/Contents → None (no FC established)

**establishes_independent_bfc(display: &Display, triggers: &BfcTriggers) -> bool**

Determines if element establishes independent BFC considering:
- Display type (flow-root always true)
- Overflow (hidden, scroll, auto, clip)
- Float (left, right)
- Position (absolute, fixed)
- Inline-block

## Key Decisions

### Decision: Why Option<FormattingContextType>?

**Rationale:** Not all display values establish formatting contexts.
- `display: inline` participates in parent's IFC
- `display: none` generates no box
- `display: contents` has no principal box

Returning `Option` makes this explicit in the type system.

### Decision: Separate BFC Triggering Logic

**Rationale:** BFC establishment is complex. Even `display: block` can
establish independent BFC if:
- `overflow` is not `visible`
- Element is floated
- Element is absolutely positioned
- Element is `inline-block`

Separating this into `BfcTriggers` struct makes the rules explicit and testable.

### Decision: Include Helper Methods

**Rationale:** Common queries (e.g., "can this FC contain blocks?") are
used throughout layout. Centralizing these as methods:
- Improves code readability
- Ensures consistent semantics
- Makes layout code more declarative

## Integration Points

### W2.T09 (FC Factory)

Factory will use `derive_fc_from_display()` to determine which FC to create:

```rust
let fc_type = derive_fc_from_display(&box_node.style.display)?;
match fc_type {
    FormattingContextType::BlockFormatting => create_block_fc(),
    FormattingContextType::FlexFormatting => create_flex_fc(),
    // ...
}
```

### W2.T10 (LayoutEngine)

Engine will query FC type for dispatch decisions:

```rust
if fc_type.requires_line_breaking() {
    // Special handling for inline layout
}
```

### W3.T04 (BlockFormattingContext)

Block layout will check if child establishes independent BFC:

```rust
if establishes_independent_bfc(&child.style.display, &triggers) {
    // Child contains floats, no margin collapse
}
```

## Testing Strategy

Tests cover:
1. **Type creation**: All variants can be created
2. **Equality**: Enum equality and hashing work
3. **Helper methods**: All query methods return correct values
4. **Derivation**: All display values map correctly
5. **BFC triggers**: All trigger conditions work
6. **Independent BFC**: Complex logic is correct
7. **Edge cases**: Inline, none, contents handled

## Performance Considerations

- **Enum is Copy**: No heap allocation, fast to pass around
- **Methods are inline**: Helper methods inline for zero cost
- **Derivation is pure**: No side effects, can be cached

## Future Extensions

### Potential Additions

1. **Ruby FC**: If ruby layout is implemented
2. **Math FC**: If MathML layout is implemented
3. **Custom layout**: If CSS Houdini Layout API is supported

### Backward Compatibility

Adding new FC types is backward compatible:
- Enum is non-exhaustive in public API (via careful match design)
- Factory pattern isolates creation logic
- New FCs can be added without breaking existing code

## Common Pitfalls

### Pitfall 1: Assuming Block Always Establishes BFC

**Wrong:**
```rust
if display == Display::Block {
    // Always establishes BFC
}
```

**Right:**
```rust
if establishes_independent_bfc(&display, &triggers) {
    // Considers overflow, float, position, etc.
}
```

### Pitfall 2: Forgetting Inline-Flex vs Inline-Block

**Wrong:**
```rust
Display::InlineFlex => FormattingContextType::InlineFormatting
```

**Right:**
```rust
Display::InlineFlex => FormattingContextType::FlexFormatting
// inline-flex establishes FLEX FC, not IFC!
```

### Pitfall 3: Not Checking for None

**Wrong:**
```rust
let fc_type = derive_fc_from_display(&display).unwrap();
// Panics for inline, none, contents!
```

**Right:**
```rust
if let Some(fc_type) = derive_fc_from_display(&display) {
    // Handle FC
} else {
    // No FC established
}
```

## Verification Checklist

- [x] FormattingContextType enum with 5 variants
- [x] All helper methods implemented
- [x] derive_fc_from_display() handles all display values
- [x] BfcTriggers struct complete
- [x] establishes_independent_bfc() logic correct
- [x] 25+ tests all passing
- [x] Clippy clean
- [x] Documentation complete
- [x] Integration points documented

## Time Tracking

- **Module setup:** 15min
- **Enum definition:** 30min
- **Helper methods:** 45min
- **Derivation logic:** 1hr
- **Tests:** 45min
- **Documentation:** 15min
- **Total:** 2-3 hours ✓

## References

- CSS 2.1 Section 9.4: Visual formatting model details
- CSS Display Module Level 3: Display property definition
- W1.R01 Research Notes: Formatting context concepts
```

## Common Pitfalls to Avoid

### Pitfall 1: Assuming All Block Boxes Establish BFC

**Wrong:** Every `display: block` establishes independent BFC
**Right:** Only with overflow, float, position, or explicit flow-root

### Pitfall 2: Forgetting That Inline Doesn't Establish FC

**Wrong:** `derive_fc_from_display(Display::Inline)` should return IFC
**Right:** Returns None - inline participates in parent's IFC

### Pitfall 3: Not Distinguishing Inline-Flex from Inline

**Wrong:** Both are "inline" so both should behave the same
**Right:** Inline-flex establishes Flex FC, not IFC

## Verification Checklist

- [ ] FormattingContextType enum complete
- [ ] All helper methods work
- [ ] Derivation logic handles all display values
- [ ] BFC triggers correctly identified
- [ ] Tests cover all cases
- [ ] Clippy clean
- [ ] Documentation explains all rules
- [ ] Notes file comprehensive

## Time Tracking

- **Module setup:** 15min
- **Enum definition:** 30min
- **Helper methods:** 45min
- **Derivation logic:** 1hr
- **Tests:** 45min
- **Documentation:** 15min
- **Total:** 2-3 hours

## Getting Help

- Review CSS 2.1 Section 9.4 for BFC rules
- Check `outputs/notes/W1.R01-notes.md` for FC concepts
- See `outputs/notes/W1.T05-notes.md` for Display API
- MDN: Block Formatting Context triggers

Remember: FC type determines the entire layout algorithm. Get this right!
