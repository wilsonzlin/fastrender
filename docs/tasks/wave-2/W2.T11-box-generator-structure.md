---
task_id: "W2.T11"
title: "Implement Box Generator Structure (DOM to BoxTree)"
wave: 2
estimated_hours: 6-8
depends_on:
  - "W2.T01"
  - "W2.T02"
inputs:
  - "outputs/notes/W2.T01-notes.md"
  - "outputs/notes/W2.T02-notes.md"
  - "src/tree/box_tree.rs"
outputs:
  - "src/tree/box_generation.rs"
  - "outputs/notes/W2.T11-notes.md"
skills_required:
  - "Rust"
  - "Tree transformations"
  - "CSS box generation rules"
  - "Pattern matching"
context_files:
  - "docs/plan/01-box-generation.md"
  - "outputs/notes/W1.R01-notes.md"
verification:
  - "cargo test tree::box_generation"
  - "cargo clippy -- -D warnings"
---

# Implement Box Generator Structure (DOM to BoxTree)

## Context

The **BoxGenerator** is the bridge between styled DOM and layout. It implements the **CSS box generation algorithm** that transforms a DOM tree with computed styles into a BoxTree ready for layout.

This is one of the most **complex** tasks in Wave 2. Box generation involves:
- Deciding which elements generate boxes (display: none doesn't)
- Handling display: contents (element is transparent to box tree)
- Creating anonymous boxes where needed
- Determining box types from display values
- Preserving document order
- Handling text nodes

### Background

**What is Box Generation?**

From CSS 2.1 Section 9.2:
> "The display property determines the type of box(es) an element generates. The values block, inline-block, and inline cause an element to generate a principal box."

Box generation rules:
1. **display: none** → No box generated
2. **display: contents** → No principal box, children participate in parent's formatting context
3. **display: block** → Block box
4. **display: inline** → Inline box
5. **display: flex** → Block-level flex container
6. **Text nodes** → Text boxes (always inline-level)
7. **Anonymous boxes** → Generated for mixed inline/block content

**Why a Generator?**

We separate box generation from layout because:
- **Single responsibility**: Box generation is complex enough to be its own concern
- **Testability**: Can test box tree structure without implementing layout
- **Reusability**: Same box tree can be laid out multiple times (e.g., resize)
- **Clarity**: Clear boundary between "what boxes exist" and "where they go"

**Current Scope (Wave 2)**

In Wave 2, we implement the **basic structure**:
- Core BoxGenerator struct
- Simple box generation (no anonymous box insertion yet)
- Handle display: none and display: contents
- Generate box types from display values
- Text box creation
- Extensibility for Wave 3 enhancements

Full anonymous box insertion comes in Wave 3 when we have real layout algorithms.

### Why This Matters

The BoxGenerator is consumed by:
- **Public API**: Application calls `generator.generate(dom_tree)`
- **W3.T04**: BlockFormattingContext needs proper box trees
- **W4.T12**: InlineFormattingContext needs inline boxes
- **Future**: Incremental updates (re-generate changed subtrees)

Without the generator:
- Can't transform DOM to layout-ready structure
- Must manually construct box trees for testing
- Can't handle display: none or display: contents
- Can't implement CSS box generation rules

The generator is the first step in the rendering pipeline.

## Prerequisites

### Required Knowledge
- **CSS display property**: All display values
- **CSS box generation**: Section 9.2 of CSS 2.1
- **Tree algorithms**: Tree traversal and transformation
- **Anonymous boxes**: When and why they're created

### Required Reading
1. **outputs/notes/W2.T01-notes.md**: BoxNode API
2. **outputs/notes/W2.T02-notes.md**: BoxType variants (if separate task)
3. **CSS 2.1 Section 9.2**: Box generation
4. **outputs/notes/W1.R01-notes.md**: Formatting context concepts
5. **docs/plan/01-box-generation.md**: Box generation architecture

## Inputs

### From Dependencies

1. **W2.T01-notes.md** (BoxNode)
   - Look for: Constructor methods (new_block, new_inline, new_text)
   - Look for: How to build box hierarchies
   - Key insight: BoxNode API for construction

2. **Existing Code (if W2.T02 exists)**
   - Look for: BoxType enum and variants
   - Look for: How to create each box type

### Existing Code

Read:
- `src/tree/box_tree.rs` - BoxNode, BoxType, FormattingContextType
- `src/style/display.rs` - Display enum (from W1.T05)
- `src/style/values.rs` - Other style properties

## Objectives

### Primary Goals

1. **Define DOMNode placeholder**: Simple DOM representation for testing
2. **Define BoxGenerator struct**: Main box generation orchestrator
3. **Implement generate()**: Top-level DOM → BoxTree transformation
4. **Implement generate_box_for_element()**: Element → BoxNode
5. **Handle display: none**: Skip elements
6. **Handle display: contents**: Transparent elements
7. **Generate text boxes**: Text nodes → TextBox
8. **Determine box types**: Display → BoxType mapping
9. **Preserve hierarchy**: Maintain document order
10. **Comprehensive tests**: All box generation paths
11. **Extensibility**: Prepare for anonymous box insertion (Wave 3)

### Success Criteria

- [ ] DOMNode struct for testing (simple representation)
- [ ] BoxGenerator struct complete
- [ ] generate() method works end-to-end
- [ ] generate_box_for_element() handles all display values
- [ ] display: none skipped correctly
- [ ] display: contents handled (children adopted by parent)
- [ ] Text boxes created from text nodes
- [ ] Box type derivation correct for all display values
- [ ] Document order preserved
- [ ] Placeholder for anonymous box insertion
- [ ] 25+ comprehensive tests
- [ ] All tests pass
- [ ] Clippy clean
- [ ] Notes file comprehensive

## Implementation Guide

### Step 1: Define DOMNode Placeholder (Estimated: 30min)

**Create `src/tree/box_generation.rs`:**

```rust
//! Box generation - transforms styled DOM into BoxTree
//!
//! Implements the CSS box generation algorithm that determines what boxes
//! are created from DOM elements.

use crate::tree::{BoxTree, BoxNode, BoxType, FormattingContextType};
use crate::tree::box_tree::{DebugInfo, ComputedStyle};
use crate::layout::contexts::types::{derive_fc_from_display, BfcTriggers};
use crate::style::display::Display;
use std::sync::Arc;

/// Simplified DOM node representation
///
/// This is a placeholder for the real DOM implementation.
/// In a real browser engine, this would be the actual DOM node.
///
/// # Note
///
/// This simplified version is used for:
/// - Testing box generation in isolation
/// - Wave 2 development (before real DOM exists)
/// - Documentation examples
///
/// In production, replace with actual DOM node types.
#[derive(Debug, Clone)]
pub struct DOMNode {
    /// Element tag name (None for text nodes)
    pub tag_name: Option<String>,

    /// Element ID attribute
    pub id: Option<String>,

    /// Element classes
    pub classes: Vec<String>,

    /// Computed style for this element
    ///
    /// In a real implementation, this would be computed from:
    /// - User agent styles
    /// - Author styles (CSS)
    /// - Inline styles
    /// - Inheritance
    pub style: Arc<ComputedStyle>,

    /// Text content (for text nodes)
    pub text: Option<String>,

    /// Child nodes
    pub children: Vec<DOMNode>,
}

impl DOMNode {
    /// Creates a new element node
    ///
    /// # Examples
    ///
    /// ```
    /// use std::sync::Arc;
    /// use fastrender::tree::box_generation::DOMNode;
    /// # use fastrender::tree::box_tree::ComputedStyle;
    ///
    /// let style = Arc::new(ComputedStyle::default());
    /// let div = DOMNode::new_element("div", style, vec![]);
    /// ```
    pub fn new_element(
        tag_name: impl Into<String>,
        style: Arc<ComputedStyle>,
        children: Vec<DOMNode>,
    ) -> Self {
        Self {
            tag_name: Some(tag_name.into()),
            id: None,
            classes: Vec::new(),
            style,
            text: None,
            children,
        }
    }

    /// Creates a new text node
    ///
    /// # Examples
    ///
    /// ```
    /// use std::sync::Arc;
    /// use fastrender::tree::box_generation::DOMNode;
    /// # use fastrender::tree::box_tree::ComputedStyle;
    ///
    /// let style = Arc::new(ComputedStyle::default());
    /// let text = DOMNode::new_text("Hello, world!", style);
    /// ```
    pub fn new_text(text: impl Into<String>, style: Arc<ComputedStyle>) -> Self {
        Self {
            tag_name: None,
            id: None,
            classes: Vec::new(),
            style,
            text: Some(text.into()),
            children: Vec::new(),
        }
    }

    /// Sets element ID (builder pattern)
    pub fn with_id(mut self, id: impl Into<String>) -> Self {
        self.id = Some(id.into());
        self
    }

    /// Adds a class (builder pattern)
    pub fn with_class(mut self, class: impl Into<String>) -> Self {
        self.classes.push(class.into());
        self
    }

    /// Returns true if this is a text node
    pub fn is_text(&self) -> bool {
        self.text.is_some()
    }

    /// Returns true if this is an element node
    pub fn is_element(&self) -> bool {
        self.tag_name.is_some()
    }

    /// Gets the display value from computed style
    ///
    /// In real implementation, this would access style.display.
    /// For now, we'll need to extend ComputedStyle.
    pub fn display(&self) -> Display {
        // TODO: Get from self.style.display when ComputedStyle is complete
        // For now, default to block
        Display::Box(crate::style::display::DisplayBox::Block)
    }
}
```

**Update `src/tree/mod.rs`:**
```rust
pub mod box_tree;
pub mod fragment;  // If exists from W2.T03
pub mod box_generation;

pub use box_tree::{BoxTree, BoxNode, BoxType, FormattingContextType};
pub use box_generation::{DOMNode, BoxGenerator};
```

### Step 2: Implement BoxGenerator Struct (Estimated: 1 hour)

**Add to `src/tree/box_generation.rs`:**

```rust
/// Configuration for box generation
///
/// Controls how boxes are generated from DOM.
#[derive(Debug, Clone)]
pub struct BoxGenerationConfig {
    /// Whether to generate debug info for boxes
    ///
    /// When true, boxes include tag names, IDs, and classes for debugging.
    pub include_debug_info: bool,

    /// Whether to insert anonymous boxes (Wave 3)
    ///
    /// When true, generator inserts anonymous boxes where needed by CSS.
    /// Not implemented in Wave 2 - placeholder for future.
    pub insert_anonymous_boxes: bool,
}

impl BoxGenerationConfig {
    /// Creates default configuration
    pub fn new() -> Self {
        Self {
            include_debug_info: true,
            insert_anonymous_boxes: false, // Not implemented yet
        }
    }

    /// Configuration for production (minimal debug info)
    pub fn production() -> Self {
        Self {
            include_debug_info: false,
            insert_anonymous_boxes: false,
        }
    }

    /// Configuration for development (full debug info)
    pub fn development() -> Self {
        Self {
            include_debug_info: true,
            insert_anonymous_boxes: false,
        }
    }
}

impl Default for BoxGenerationConfig {
    fn default() -> Self {
        Self::new()
    }
}

/// Box generator - transforms DOM tree into Box tree
///
/// Implements the CSS box generation algorithm from CSS 2.1 Section 9.2.
///
/// # Current Implementation (Wave 2)
///
/// - Handles display: none (skip element)
/// - Handles display: contents (skip box, but process children)
/// - Creates boxes for block, inline, flex, grid, table
/// - Creates text boxes
/// - Preserves document order
///
/// # Future Implementation (Wave 3)
///
/// - Anonymous box insertion for mixed inline/block content
/// - Pseudo-element box generation (::before, ::after)
/// - Run-in boxes (if supported)
/// - Ruby boxes (if supported)
///
/// # Examples
///
/// ```
/// use std::sync::Arc;
/// use fastrender::tree::box_generation::{BoxGenerator, DOMNode};
/// # use fastrender::tree::box_tree::ComputedStyle;
///
/// let generator = BoxGenerator::new();
/// let style = Arc::new(ComputedStyle::default());
/// let dom = DOMNode::new_element("div", style, vec![]);
///
/// let box_tree = generator.generate(&dom).unwrap();
/// ```
pub struct BoxGenerator {
    config: BoxGenerationConfig,
}

impl BoxGenerator {
    /// Creates a new box generator with default configuration
    pub fn new() -> Self {
        Self {
            config: BoxGenerationConfig::default(),
        }
    }

    /// Creates a box generator with custom configuration
    pub fn with_config(config: BoxGenerationConfig) -> Self {
        Self { config }
    }
}

impl Default for BoxGenerator {
    fn default() -> Self {
        Self::new()
    }
}
```

### Step 3: Implement Box Generation Logic (Estimated: 3 hours)

**Add to `src/tree/box_generation.rs`:**

```rust
/// Errors that can occur during box generation
#[derive(Debug)]
pub enum BoxGenerationError {
    /// Root element has display: none
    RootDisplayNone,

    /// Root element has display: contents
    RootDisplayContents,

    /// Invalid display value
    InvalidDisplay(String),

    /// Unsupported feature (for future use)
    Unsupported(String),
}

impl std::fmt::Display for BoxGenerationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::RootDisplayNone => write!(f, "Root element has display: none"),
            Self::RootDisplayContents => write!(f, "Root element has display: contents"),
            Self::InvalidDisplay(msg) => write!(f, "Invalid display value: {}", msg),
            Self::Unsupported(msg) => write!(f, "Unsupported feature: {}", msg),
        }
    }
}

impl std::error::Error for BoxGenerationError {}

impl BoxGenerator {
    /// Generates a box tree from a DOM tree
    ///
    /// This is the main entry point for box generation. It transforms
    /// a styled DOM tree into a box tree ready for layout.
    ///
    /// # Arguments
    ///
    /// * `dom_root` - The root of the DOM tree to process
    ///
    /// # Returns
    ///
    /// A BoxTree with the root element's principal box as root
    ///
    /// # Errors
    ///
    /// Returns error if:
    /// - Root element has `display: none`
    /// - Root element has `display: contents`
    /// - Invalid display value
    ///
    /// # Examples
    ///
    /// ```
    /// use std::sync::Arc;
    /// use fastrender::tree::box_generation::{BoxGenerator, DOMNode};
    /// # use fastrender::tree::box_tree::ComputedStyle;
    ///
    /// let generator = BoxGenerator::new();
    /// let style = Arc::new(ComputedStyle::default());
    /// let dom = DOMNode::new_element("div", style, vec![]);
    ///
    /// let box_tree = generator.generate(&dom).unwrap();
    /// ```
    pub fn generate(&self, dom_root: &DOMNode) -> Result<BoxTree, BoxGenerationError> {
        // Root must generate a box
        if self.should_skip_element(dom_root) {
            return Err(BoxGenerationError::RootDisplayNone);
        }

        if self.is_display_contents(dom_root) {
            return Err(BoxGenerationError::RootDisplayContents);
        }

        // Generate box for root
        let root_box = self.generate_box_for_element(dom_root)?;

        Ok(BoxTree::new(root_box))
    }

    /// Generates a box for a single DOM node (element or text)
    ///
    /// This is called recursively for each node in the tree.
    ///
    /// # Arguments
    ///
    /// * `node` - The DOM node to generate a box for
    ///
    /// # Returns
    ///
    /// A BoxNode, or None if no box should be generated (display: none)
    fn generate_box_for_element(&self, node: &DOMNode) -> Result<BoxNode, BoxGenerationError> {
        // Handle text nodes
        if node.is_text() {
            return Ok(self.create_text_box(node));
        }

        // Generate boxes for children first
        let child_boxes = self.generate_child_boxes(node)?;

        // Determine what kind of box to create
        let display = node.display();

        // Derive formatting context type (if any)
        let fc_type = derive_fc_from_display(&display);

        // Create appropriate box type
        let box_node = match &display {
            Display::Box(crate::style::display::DisplayBox::Block)
            | Display::Box(crate::style::display::DisplayBox::FlowRoot) => {
                BoxNode::new_block(
                    node.style.clone(),
                    fc_type.unwrap_or(FormattingContextType::BlockFormatting),
                    child_boxes,
                )
            }

            Display::Box(crate::style::display::DisplayBox::Inline) => {
                BoxNode::new_inline(node.style.clone(), child_boxes)
            }

            Display::Box(crate::style::display::DisplayBox::InlineBlock) => {
                BoxNode::new_inline_block(
                    node.style.clone(),
                    FormattingContextType::BlockFormatting,
                    child_boxes,
                )
            }

            Display::Flex | Display::InlineFlex => {
                BoxNode::new_block(
                    node.style.clone(),
                    FormattingContextType::FlexFormatting,
                    child_boxes,
                )
            }

            Display::Grid | Display::InlineGrid => {
                BoxNode::new_block(
                    node.style.clone(),
                    FormattingContextType::GridFormatting,
                    child_boxes,
                )
            }

            Display::Table => {
                BoxNode::new_block(
                    node.style.clone(),
                    FormattingContextType::TableFormatting,
                    child_boxes,
                )
            }

            // Table-internal boxes (simplified for Wave 2)
            Display::TableRow | Display::TableCell => {
                // For now, treat as block boxes
                // Real implementation would create table-specific box types
                BoxNode::new_block(
                    node.style.clone(),
                    FormattingContextType::BlockFormatting,
                    child_boxes,
                )
            }

            _ => {
                // Fallback to block for unknown/unsupported display values
                BoxNode::new_block(
                    node.style.clone(),
                    FormattingContextType::BlockFormatting,
                    child_boxes,
                )
            }
        };

        // Add debug info if enabled
        if self.config.include_debug_info {
            let debug_info = self.create_debug_info(node);
            Ok(box_node.with_debug_info(debug_info))
        } else {
            Ok(box_node)
        }
    }

    /// Generates boxes for all children of a node
    ///
    /// Handles:
    /// - Skipping display: none children
    /// - Adopting display: contents children's children
    /// - Preserving document order
    fn generate_child_boxes(&self, parent: &DOMNode) -> Result<Vec<BoxNode>, BoxGenerationError> {
        let mut child_boxes = Vec::new();

        for child in &parent.children {
            // Skip display: none
            if self.should_skip_element(child) {
                continue;
            }

            // Handle display: contents - adopt grandchildren
            if self.is_display_contents(child) {
                // For display: contents, skip the element but process its children
                let grandchild_boxes = self.generate_child_boxes(child)?;
                child_boxes.extend(grandchild_boxes);
                continue;
            }

            // Generate box for child
            let child_box = self.generate_box_for_element(child)?;
            child_boxes.push(child_box);
        }

        // Future (Wave 3): Insert anonymous boxes here
        // if self.config.insert_anonymous_boxes {
        //     child_boxes = self.insert_anonymous_boxes(child_boxes);
        // }

        Ok(child_boxes)
    }

    /// Creates a text box from a text node
    fn create_text_box(&self, node: &DOMNode) -> BoxNode {
        let text = node.text.as_ref().unwrap().clone();
        let box_node = BoxNode::new_text(node.style.clone(), text);

        if self.config.include_debug_info {
            let debug_info = DebugInfo::new(Some("text".to_string()), None, vec![]);
            box_node.with_debug_info(debug_info)
        } else {
            box_node
        }
    }

    /// Creates debug info from a DOM node
    fn create_debug_info(&self, node: &DOMNode) -> DebugInfo {
        DebugInfo::new(
            node.tag_name.clone(),
            node.id.clone(),
            node.classes.clone(),
        )
    }

    /// Returns true if element should be skipped (display: none)
    fn should_skip_element(&self, node: &DOMNode) -> bool {
        if node.is_text() {
            return false;
        }

        matches!(node.display(), Display::None)
    }

    /// Returns true if element has display: contents
    fn is_display_contents(&self, node: &DOMNode) -> bool {
        if node.is_text() {
            return false;
        }

        matches!(node.display(), Display::Contents)
    }
}
```

### Step 4: Write Comprehensive Tests (Estimated: 2 hours)

**Add at bottom of file:**

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use crate::style::display::{Display, DisplayBox};

    fn default_style() -> Arc<ComputedStyle> {
        Arc::new(ComputedStyle::default())
    }

    // Helper to create DOM node with specific display
    // (Would use real ComputedStyle with display in production)
    fn dom_with_display(tag: &str, display: Display, children: Vec<DOMNode>) -> DOMNode {
        DOMNode::new_element(tag, default_style(), children)
    }

    #[test]
    fn test_config_creation() {
        let config = BoxGenerationConfig::new();
        assert!(config.include_debug_info);
        assert!(!config.insert_anonymous_boxes);
    }

    #[test]
    fn test_config_production() {
        let config = BoxGenerationConfig::production();
        assert!(!config.include_debug_info);
    }

    #[test]
    fn test_config_development() {
        let config = BoxGenerationConfig::development();
        assert!(config.include_debug_info);
    }

    #[test]
    fn test_generator_creation() {
        let generator = BoxGenerator::new();
        assert!(generator.config.include_debug_info);
    }

    #[test]
    fn test_generator_with_config() {
        let config = BoxGenerationConfig::production();
        let generator = BoxGenerator::with_config(config);
        assert!(!generator.config.include_debug_info);
    }

    #[test]
    fn test_dom_node_element() {
        let dom = DOMNode::new_element("div", default_style(), vec![]);
        assert!(dom.is_element());
        assert!(!dom.is_text());
        assert_eq!(dom.tag_name, Some("div".to_string()));
    }

    #[test]
    fn test_dom_node_text() {
        let dom = DOMNode::new_text("Hello", default_style());
        assert!(dom.is_text());
        assert!(!dom.is_element());
        assert_eq!(dom.text, Some("Hello".to_string()));
    }

    #[test]
    fn test_dom_node_with_id() {
        let dom = DOMNode::new_element("div", default_style(), vec![])
            .with_id("header");
        assert_eq!(dom.id, Some("header".to_string()));
    }

    #[test]
    fn test_dom_node_with_class() {
        let dom = DOMNode::new_element("div", default_style(), vec![])
            .with_class("navbar");
        assert_eq!(dom.classes.len(), 1);
        assert_eq!(dom.classes[0], "navbar");
    }

    #[test]
    fn test_generate_single_block() {
        let generator = BoxGenerator::new();
        let dom = DOMNode::new_element("div", default_style(), vec![]);

        let box_tree = generator.generate(&dom).unwrap();
        assert!(box_tree.root.is_block_level());
        assert_eq!(box_tree.count_boxes(), 1);
    }

    #[test]
    fn test_generate_block_with_text() {
        let generator = BoxGenerator::new();
        let text = DOMNode::new_text("Hello", default_style());
        let dom = DOMNode::new_element("p", default_style(), vec![text]);

        let box_tree = generator.generate(&dom).unwrap();
        assert_eq!(box_tree.count_boxes(), 2); // p + text
        assert_eq!(box_tree.count_text_boxes(), 1);
    }

    #[test]
    fn test_generate_nested_blocks() {
        let generator = BoxGenerator::new();

        let inner = DOMNode::new_element("p", default_style(), vec![]);
        let outer = DOMNode::new_element("div", default_style(), vec![inner]);

        let box_tree = generator.generate(&outer).unwrap();
        assert_eq!(box_tree.count_boxes(), 2); // div + p
        assert_eq!(box_tree.root.children.len(), 1);
    }

    #[test]
    fn test_generate_multiple_children() {
        let generator = BoxGenerator::new();

        let child1 = DOMNode::new_element("p", default_style(), vec![]);
        let child2 = DOMNode::new_element("p", default_style(), vec![]);
        let child3 = DOMNode::new_element("p", default_style(), vec![]);

        let dom = DOMNode::new_element("div", default_style(), vec![child1, child2, child3]);

        let box_tree = generator.generate(&dom).unwrap();
        assert_eq!(box_tree.count_boxes(), 4); // div + 3 p's
        assert_eq!(box_tree.root.children.len(), 3);
    }

    #[test]
    fn test_skip_display_none_child() {
        let generator = BoxGenerator::new();

        // Note: This test is conceptual since we'd need ComputedStyle.display
        // In real implementation, child would have display: none
        let child1 = DOMNode::new_element("p", default_style(), vec![]);
        // let child2 = DOMNode with display: none
        let child3 = DOMNode::new_element("p", default_style(), vec![]);

        let dom = DOMNode::new_element("div", default_style(), vec![child1, child3]);

        let box_tree = generator.generate(&dom).unwrap();
        // With display: none on child2, would have 3 boxes instead of 4
        assert_eq!(box_tree.root.children.len(), 2);
    }

    #[test]
    fn test_text_box_creation() {
        let generator = BoxGenerator::new();
        let text = DOMNode::new_text("Hello, world!", default_style());

        let text_box = generator.create_text_box(&text);

        assert!(text_box.is_text());
        assert_eq!(text_box.text(), Some("Hello, world!"));
    }

    #[test]
    fn test_debug_info_included() {
        let config = BoxGenerationConfig::development();
        let generator = BoxGenerator::with_config(config);

        let dom = DOMNode::new_element("div", default_style(), vec![])
            .with_id("header")
            .with_class("navbar");

        let box_tree = generator.generate(&dom).unwrap();
        assert!(box_tree.root.debug_info.is_some());

        let debug_info = box_tree.root.debug_info.as_ref().unwrap();
        assert_eq!(debug_info.tag_name, Some("div".to_string()));
        assert_eq!(debug_info.id, Some("header".to_string()));
        assert_eq!(debug_info.classes.len(), 1);
    }

    #[test]
    fn test_debug_info_excluded() {
        let config = BoxGenerationConfig::production();
        let generator = BoxGenerator::with_config(config);

        let dom = DOMNode::new_element("div", default_style(), vec![]);

        let box_tree = generator.generate(&dom).unwrap();
        // In production mode, debug info is still added but could be optimized out
        // This test documents current behavior
    }

    #[test]
    fn test_complex_tree_structure() {
        let generator = BoxGenerator::new();

        // Build: div > (p > text, p > text, div > p > text)
        let text1 = DOMNode::new_text("Text 1", default_style());
        let text2 = DOMNode::new_text("Text 2", default_style());
        let text3 = DOMNode::new_text("Text 3", default_style());

        let p1 = DOMNode::new_element("p", default_style(), vec![text1]);
        let p2 = DOMNode::new_element("p", default_style(), vec![text2]);
        let p3 = DOMNode::new_element("p", default_style(), vec![text3]);

        let inner_div = DOMNode::new_element("div", default_style(), vec![p3]);
        let outer_div = DOMNode::new_element("div", default_style(), vec![p1, p2, inner_div]);

        let box_tree = generator.generate(&outer_div).unwrap();

        // div(root) + p + text + p + text + div + p + text = 7 boxes
        assert_eq!(box_tree.count_boxes(), 7);
        assert_eq!(box_tree.count_text_boxes(), 3);
    }

    #[test]
    fn test_inline_box_generation() {
        let generator = BoxGenerator::new();

        let text = DOMNode::new_text("Hello", default_style());
        let span = DOMNode::new_element("span", default_style(), vec![text]);
        let p = DOMNode::new_element("p", default_style(), vec![span]);

        let box_tree = generator.generate(&p).unwrap();

        // p(block) + span(inline) + text = 3 boxes
        assert_eq!(box_tree.count_boxes(), 3);

        // Root is block
        assert!(box_tree.root.is_block_level());

        // First child should be inline
        // Note: Depends on Display implementation in DOMNode
        // assert!(box_tree.root.children[0].is_inline_level());
    }

    #[test]
    fn test_document_order_preserved() {
        let generator = BoxGenerator::new();

        let child1 = DOMNode::new_element("p", default_style(), vec![])
            .with_id("first");
        let child2 = DOMNode::new_element("p", default_style(), vec![])
            .with_id("second");
        let child3 = DOMNode::new_element("p", default_style(), vec![])
            .with_id("third");

        let dom = DOMNode::new_element("div", default_style(), vec![child1, child2, child3]);

        let box_tree = generator.generate(&dom).unwrap();

        // Check order is preserved
        assert_eq!(box_tree.root.children.len(), 3);
        let ids: Vec<_> = box_tree.root.children.iter()
            .filter_map(|c| c.debug_info.as_ref())
            .filter_map(|d| d.id.as_ref())
            .collect();

        assert_eq!(ids, vec!["first", "second", "third"]);
    }

    #[test]
    fn test_mixed_element_and_text_nodes() {
        let generator = BoxGenerator::new();

        let text1 = DOMNode::new_text("Before", default_style());
        let em = DOMNode::new_element("em", default_style(), vec![]);
        let text2 = DOMNode::new_text("After", default_style());

        let p = DOMNode::new_element("p", default_style(), vec![text1, em, text2]);

        let box_tree = generator.generate(&p).unwrap();

        // p + text + em + text = 4 boxes
        assert_eq!(box_tree.count_boxes(), 4);
        assert_eq!(box_tree.count_text_boxes(), 2);
        assert_eq!(box_tree.root.children.len(), 3);
    }

    #[test]
    fn test_generator_reuse() {
        let generator = BoxGenerator::new();

        // Reuse generator for multiple trees
        for i in 0..10 {
            let dom = DOMNode::new_element("div", default_style(), vec![])
                .with_id(format!("div-{}", i));

            let result = generator.generate(&dom);
            assert!(result.is_ok());
        }
    }

    #[test]
    fn test_empty_element() {
        let generator = BoxGenerator::new();
        let dom = DOMNode::new_element("div", default_style(), vec![]);

        let box_tree = generator.generate(&dom).unwrap();
        assert_eq!(box_tree.count_boxes(), 1);
        assert_eq!(box_tree.root.children.len(), 0);
    }

    #[test]
    fn test_deeply_nested_structure() {
        let generator = BoxGenerator::new();

        // Create deeply nested: div > div > div > div > p
        let mut current = DOMNode::new_element("p", default_style(), vec![]);
        for _ in 0..4 {
            current = DOMNode::new_element("div", default_style(), vec![current]);
        }

        let box_tree = generator.generate(&current).unwrap();
        assert_eq!(box_tree.count_boxes(), 5); // 4 divs + 1 p
    }
}
```

### Step 5: Documentation and Verification (Estimated: 30min)

Run verification:
```bash
cargo test tree::box_generation
cargo clippy -- -D warnings
cargo fmt
cargo doc --no-deps --open
```

## Testing Requirements

Run: `cargo test tree::box_generation`

Expected: 25+ tests passing covering:
- Config creation (production, development, default)
- Generator creation
- DOMNode creation (elements, text, with ID/classes)
- Single box generation
- Nested structure generation
- Multiple children
- Text box creation
- Debug info inclusion/exclusion
- Complex tree structures
- Document order preservation
- Mixed element and text nodes
- Deep nesting
- Empty elements

## Output Artifacts

### Code Files

1. **`src/tree/box_generation.rs`** (~700-800 lines)
   - DOMNode placeholder struct
   - BoxGenerationConfig
   - BoxGenerator struct
   - generate() and helper methods
   - Comprehensive tests

### Notes File

Create: **`outputs/notes/W2.T11-notes.md`**

**Key sections:**
- **API Contracts**: BoxGenerator methods and guarantees
- **Decision: DOMNode placeholder**: Why and how to replace
- **Decision: No anonymous boxes yet**: Deferred to Wave 3
- **Decision: Config struct**: Extensibility
- **Recommendations**: How to integrate with real DOM
- **Integration**: How layout engine uses box trees
- **Future**: Anonymous box insertion algorithm (Wave 3)
- **Future**: Pseudo-element generation
- **Migration**: Replacing DOMNode with real DOM

## Common Pitfalls to Avoid

### Pitfall 1: Not Preserving Document Order

**Wrong:** Processing children in arbitrary order
**Right:** Iterate children in document order

### Pitfall 2: Generating Boxes for display: none

**Wrong:** Creating invisible boxes for display: none
**Right:** Skip entirely (no box generated)

### Pitfall 3: Not Handling display: contents

**Wrong:** Creating a box for display: contents
**Right:** Skip element, adopt children

### Pitfall 4: Inserting Anonymous Boxes Prematurely

**Wrong:** Trying to implement full anonymous box logic in Wave 2
**Right:** Add placeholder, implement in Wave 3 with layout algorithms

## Verification Checklist

- [ ] DOMNode placeholder complete
- [ ] BoxGenerator struct complete
- [ ] generate() works end-to-end
- [ ] generate_box_for_element() handles all display values
- [ ] display: none skipped
- [ ] display: contents handled
- [ ] Text boxes created correctly
- [ ] Document order preserved
- [ ] Debug info works
- [ ] 25+ tests all passing
- [ ] Clippy clean
- [ ] Documentation complete
- [ ] Notes file comprehensive

## Time Tracking

- **DOMNode placeholder:** 30min
- **BoxGenerator struct:** 1hr
- **Generation logic:** 3hrs
- **Tests:** 2hrs
- **Documentation:** 30min
- **Total:** 6-8 hours

## Getting Help

- Review CSS 2.1 Section 9.2 for box generation rules
- Check `outputs/notes/W2.T01-notes.md` for BoxNode API
- See `outputs/notes/W1.R01-notes.md` for formatting context concepts
- MDN: CSS display property

Remember: Full anonymous box logic comes in Wave 3. Keep it simple for now!
