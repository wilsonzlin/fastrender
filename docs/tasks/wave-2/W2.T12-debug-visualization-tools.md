---
task_id: "W2.T12"
title: "Implement Debug Visualization and Tree Printing Tools"
wave: 2
estimated_hours: 4-6
depends_on:
  - "W2.T01"
  - "W2.T03"
  - "W2.T06"
inputs:
  - "docs/tasks/notes/W2.T01-notes.md"
  - "docs/tasks/notes/W2.T03-notes.md"
  - "docs/tasks/notes/W2.T06-notes.md"
  - "src/tree/box_tree.rs"
outputs:
  - "src/debug/tree_printer.rs"
  - "src/debug/mod.rs"
  - "docs/tasks/notes/W2.T12-notes.md"
skills_required:
  - "Rust"
  - "String formatting"
  - "Tree traversal"
  - "Terminal output"
context_files:
  - "docs/guides/code-standards.md"
verification:
  - "cargo test debug::tree_printer"
  - "cargo clippy -- -D warnings"
---

# Implement Debug Visualization and Tree Printing Tools

## Context

Debugging layout is **hard**. You need to see:
- What boxes were generated from DOM
- How boxes are nested
- What positions fragments have after layout
- What changed between two layout passes

The **Debug Visualization Tools** provide developer-friendly ways to inspect box trees and fragment trees. These tools are **essential** for:
- Development (understanding what the engine is doing)
- Testing (verifying tree structures)
- Debugging (finding layout issues)
- Documentation (explaining concepts with examples)

This task creates the foundation for all debug tooling in FastRender.

### Background

**Why Dedicated Debug Tools?**

The Rust Debug trait gives us this:
```
BoxNode { style: Arc { ... }, box_type: Block(...), children: [BoxNode { ... }] }
```

We need this:
```
div#header.navbar (Block FC)
├─ p.intro (Block FC)
│  └─ text: "Welcome to..."
└─ div.content (Block FC)
   ├─ span (Inline)
   │  └─ text: "Hello"
   └─ text: " world"
```

The difference:
- **Human-readable**: Shows element selectors, not raw data
- **Tree structure**: Clear parent-child relationships
- **Relevant info**: Only what matters for debugging
- **Compact**: Fits on screen

**What We're Building**

1. **TreePrinter**: ASCII art tree visualization
2. **FragmentPrinter**: Fragment trees with positions
3. **TreeDiff**: Compare two trees, show differences
4. **DOT export**: Generate Graphviz diagrams
5. **Color output**: Terminal colors for readability

**Use Cases**

- **During development**: Print trees to understand structure
- **In tests**: Verify exact tree shape
- **For debugging**: Find where layout went wrong
- **For docs**: Generate diagrams for documentation

### Why This Matters

Debug tools are consumed by:
- **Developers**: Understanding engine behavior
- **Tests**: Asserting tree structures
- **W3.T04+**: Debugging specific layout algorithms
- **Documentation**: Examples and diagrams
- **Future dev tools**: Browser-like inspector

Without debug tools:
- Can't visualize what engine is doing
- Hard to debug layout issues
- Tests are hard to understand
- Documentation lacks clear examples

Debug tools make everything else easier.

## Prerequisites

### Required Knowledge
- **Tree traversal**: DFS, pre-order, post-order
- **String formatting**: Rust formatting traits
- **Terminal output**: ANSI color codes
- **Graphviz DOT**: Basic DOT graph syntax

### Required Reading
1. **docs/tasks/notes/W2.T01-notes.md**: BoxNode structure
2. **docs/tasks/notes/W2.T03-notes.md**: Fragment structure (if exists)
3. **docs/tasks/notes/W2.T06-notes.md**: DebugInfo structure (if separate task)
4. **ASCII tree drawing**: Unicode box-drawing characters

## Inputs

### From Dependencies

1. **W2.T01-notes.md** (BoxNode)
   - Look for: Tree structure, debug_info field
   - Look for: Helper methods for traversal
   - Key insight: What info to display

2. **W2.T03-notes.md** (Fragment)
   - Look for: Fragment structure, bounds
   - Look for: How fragments nest
   - Key insight: Position/size info

3. **W2.T06-notes.md** (DebugInfo)
   - Look for: Tag name, ID, classes
   - Look for: to_selector() method
   - Key insight: Human-readable labels

### Existing Code

Read:
- `src/tree/box_tree.rs` - BoxNode and DebugInfo
- `src/tree/fragment.rs` - Fragment (if exists)
- `src/geometry.rs` - Rect, Point, Size

## Objectives

### Primary Goals

1. **Create debug module**: src/debug/
2. **Implement TreePrinter**: ASCII art for BoxTree
3. **Implement FragmentPrinter**: ASCII art for FragmentTree with positions
4. **Implement TreeDiff**: Compare and highlight differences
5. **Implement DOT exporter**: Generate Graphviz diagrams
6. **Add color output**: Terminal colors for readability
7. **Comprehensive tests**: All visualization modes
8. **Documentation**: Usage examples

### Success Criteria

- [ ] Debug module structure created
- [ ] TreePrinter prints BoxTree with ASCII art
- [ ] FragmentPrinter prints fragments with positions
- [ ] TreeDiff shows additions, deletions, changes
- [ ] DOT exporter generates valid Graphviz
- [ ] Color output using ANSI codes
- [ ] Configurable output (colors, depth limit, etc.)
- [ ] 20+ comprehensive tests
- [ ] All tests pass
- [ ] Clippy clean
- [ ] Notes file comprehensive
- [ ] Clear documentation with examples

## Implementation Guide

### Step 1: Create Debug Module (Estimated: 15min)

**Create module structure:**
```bash
mkdir -p src/debug
touch src/debug/tree_printer.rs
touch src/debug/mod.rs
```

**`src/debug/mod.rs`:**
```rust
//! Debug and visualization tools
//!
//! This module provides developer-friendly tools for inspecting
//! box trees and fragment trees.
//!
//! # Tools
//!
//! - **TreePrinter**: ASCII art visualization of box trees
//! - **FragmentPrinter**: ASCII art visualization of fragment trees
//! - **TreeDiff**: Compare two trees and show differences
//! - **DOT exporter**: Generate Graphviz diagrams
//!
//! # Examples
//!
//! ```
//! use fastrender::debug::TreePrinter;
//! use fastrender::tree::BoxTree;
//!
//! let tree = /* ... */;
//! let printer = TreePrinter::new();
//! println!("{}", printer.print(&tree));
//! ```

pub mod tree_printer;

pub use tree_printer::{TreePrinter, PrintConfig, ColorMode};
```

**Update `src/lib.rs`:**
```rust
pub mod debug;
pub use debug::{TreePrinter, PrintConfig};
```

### Step 2: Define Configuration (Estimated: 30min)

**`src/debug/tree_printer.rs`:**

```rust
//! Tree printing and visualization utilities

use crate::tree::{BoxTree, BoxNode, Fragment};
use crate::geometry::Rect;
use std::fmt;

/// Color mode for terminal output
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ColorMode {
    /// No colors (plain text)
    None,

    /// ANSI 16-color mode
    Ansi16,

    /// ANSI 256-color mode (better gradients)
    Ansi256,
}

/// Configuration for tree printing
#[derive(Debug, Clone)]
pub struct PrintConfig {
    /// Whether to use colors
    pub color_mode: ColorMode,

    /// Maximum depth to print (None = unlimited)
    pub max_depth: Option<usize>,

    /// Whether to show style information
    pub show_styles: bool,

    /// Whether to show box types
    pub show_box_types: bool,

    /// Whether to show formatting context types
    pub show_fc_types: bool,

    /// Indent size (spaces per level)
    pub indent_size: usize,

    /// Whether to use Unicode box-drawing characters
    pub use_unicode: bool,
}

impl PrintConfig {
    /// Creates default configuration
    pub fn new() -> Self {
        Self {
            color_mode: ColorMode::Ansi16,
            max_depth: None,
            show_styles: false,
            show_box_types: true,
            show_fc_types: true,
            indent_size: 2,
            use_unicode: true,
        }
    }

    /// Minimal output (no colors, no extra info)
    pub fn minimal() -> Self {
        Self {
            color_mode: ColorMode::None,
            max_depth: None,
            show_styles: false,
            show_box_types: false,
            show_fc_types: false,
            indent_size: 2,
            use_unicode: false,
        }
    }

    /// Detailed output (all info, colors)
    pub fn detailed() -> Self {
        Self {
            color_mode: ColorMode::Ansi16,
            max_depth: None,
            show_styles: true,
            show_box_types: true,
            show_fc_types: true,
            indent_size: 3,
            use_unicode: true,
        }
    }

    /// Output suitable for tests (no colors, deterministic)
    pub fn test() -> Self {
        Self {
            color_mode: ColorMode::None,
            max_depth: None,
            show_styles: false,
            show_box_types: true,
            show_fc_types: false,
            indent_size: 2,
            use_unicode: false,
        }
    }
}

impl Default for PrintConfig {
    fn default() -> Self {
        Self::new()
    }
}

/// ANSI color codes
mod colors {
    pub const RESET: &str = "\x1b[0m";
    pub const GRAY: &str = "\x1b[90m";
    pub const RED: &str = "\x1b[31m";
    pub const GREEN: &str = "\x1b[32m";
    pub const YELLOW: &str = "\x1b[33m";
    pub const BLUE: &str = "\x1b[34m";
    pub const MAGENTA: &str = "\x1b[35m";
    pub const CYAN: &str = "\x1b[36m";
    pub const WHITE: &str = "\x1b[97m";
}
```

### Step 3: Implement TreePrinter (Estimated: 2 hours)

**Add to `src/debug/tree_printer.rs`:**

```rust
/// Tree printer for BoxTree and Fragment trees
///
/// Visualizes tree structures as ASCII art with optional colors.
///
/// # Examples
///
/// ```
/// use std::sync::Arc;
/// use fastrender::debug::TreePrinter;
/// use fastrender::tree::{BoxTree, BoxNode, FormattingContextType};
/// # use fastrender::tree::box_tree::ComputedStyle;
///
/// let style = Arc::new(ComputedStyle::default());
/// let root = BoxNode::new_block(
///     style,
///     FormattingContextType::BlockFormatting,
///     vec![],
/// );
/// let tree = BoxTree::new(root);
///
/// let printer = TreePrinter::new();
/// println!("{}", printer.print_box_tree(&tree));
/// ```
pub struct TreePrinter {
    config: PrintConfig,
}

impl TreePrinter {
    /// Creates a new tree printer with default configuration
    pub fn new() -> Self {
        Self {
            config: PrintConfig::default(),
        }
    }

    /// Creates a tree printer with custom configuration
    pub fn with_config(config: PrintConfig) -> Self {
        Self { config }
    }

    /// Prints a box tree
    ///
    /// Returns a formatted string showing the tree structure.
    ///
    /// # Examples
    ///
    /// ```
    /// use std::sync::Arc;
    /// use fastrender::debug::TreePrinter;
    /// use fastrender::tree::{BoxTree, BoxNode, FormattingContextType};
    /// # use fastrender::tree::box_tree::ComputedStyle;
    ///
    /// let printer = TreePrinter::new();
    /// let style = Arc::new(ComputedStyle::default());
    /// let root = BoxNode::new_block(style, FormattingContextType::BlockFormatting, vec![]);
    /// let tree = BoxTree::new(root);
    ///
    /// let output = printer.print_box_tree(&tree);
    /// assert!(output.contains("Block"));
    /// ```
    pub fn print_box_tree(&self, tree: &BoxTree) -> String {
        let mut output = String::new();
        self.print_box_node(&tree.root, 0, "", true, &mut output);
        output
    }

    /// Prints a single box node recursively
    fn print_box_node(
        &self,
        node: &BoxNode,
        depth: usize,
        prefix: &str,
        is_last: bool,
        output: &mut String,
    ) {
        // Check depth limit
        if let Some(max_depth) = self.config.max_depth {
            if depth >= max_depth {
                return;
            }
        }

        // Draw tree structure
        if depth > 0 {
            output.push_str(prefix);

            if self.config.use_unicode {
                output.push_str(if is_last { "└─ " } else { "├─ " });
            } else {
                output.push_str(if is_last { "`- " } else { "|- " });
            }
        }

        // Node label
        output.push_str(&self.format_box_node(node));
        output.push('\n');

        // Recurse to children
        let child_count = node.children.len();
        for (i, child) in node.children.iter().enumerate() {
            let is_last_child = i == child_count - 1;
            let child_prefix = if depth > 0 {
                let extension = if self.config.use_unicode {
                    if is_last { "   " } else { "│  " }
                } else {
                    if is_last { "   " } else { "|  " }
                };
                format!("{}{}", prefix, extension)
            } else {
                String::new()
            };

            self.print_box_node(child, depth + 1, &child_prefix, is_last_child, output);
        }
    }

    /// Formats a single box node label
    fn format_box_node(&self, node: &BoxNode) -> String {
        let mut label = String::new();

        // Start with element selector (if debug info available)
        if let Some(debug_info) = &node.debug_info {
            label.push_str(&self.colorize(&debug_info.to_selector(), colors::CYAN));
        } else {
            label.push_str(&self.colorize("<anonymous>", colors::GRAY));
        }

        // Add box type
        if self.config.show_box_types {
            label.push_str(&self.colorize(" (", colors::GRAY));

            let box_type_str = match &node.box_type {
                crate::tree::BoxType::Block(_) => "Block",
                crate::tree::BoxType::Inline(_) => "Inline",
                crate::tree::BoxType::Text(t) => {
                    // Show truncated text content
                    let text = &t.text;
                    let truncated = if text.len() > 20 {
                        format!("\"{}...\"", &text[..20])
                    } else {
                        format!("\"{}\"", text)
                    };
                    return self.colorize(&format!("Text: {}", truncated), colors::GREEN);
                }
                crate::tree::BoxType::Replaced(_) => "Replaced",
                crate::tree::BoxType::Anonymous(_) => "Anonymous",
            };

            label.push_str(&self.colorize(box_type_str, colors::YELLOW));
            label.push_str(&self.colorize(")", colors::GRAY));
        }

        // Add FC type
        if self.config.show_fc_types {
            if let Some(fc) = node.formatting_context() {
                label.push_str(&self.colorize(&format!(" {}", fc.abbrev()), colors::BLUE));
            }
        }

        label
    }

    /// Applies color if enabled
    fn colorize(&self, text: &str, color: &str) -> String {
        match self.config.color_mode {
            ColorMode::None => text.to_string(),
            ColorMode::Ansi16 | ColorMode::Ansi256 => {
                format!("{}{}{}", color, text, colors::RESET)
            }
        }
    }

    /// Prints a fragment tree with positions
    ///
    /// Shows fragments with their bounds (position and size).
    pub fn print_fragment_tree(&self, fragment: &Fragment) -> String {
        let mut output = String::new();
        self.print_fragment(fragment, 0, "", true, &mut output);
        output
    }

    /// Prints a single fragment recursively
    fn print_fragment(
        &self,
        fragment: &Fragment,
        depth: usize,
        prefix: &str,
        is_last: bool,
        output: &mut String,
    ) {
        // Check depth limit
        if let Some(max_depth) = self.config.max_depth {
            if depth >= max_depth {
                return;
            }
        }

        // Draw tree structure
        if depth > 0 {
            output.push_str(prefix);

            if self.config.use_unicode {
                output.push_str(if is_last { "└─ " } else { "├─ " });
            } else {
                output.push_str(if is_last { "`- " } else { "|- " });
            }
        }

        // Fragment label with bounds
        output.push_str(&self.format_fragment(fragment));
        output.push('\n');

        // Recurse to children
        let child_count = fragment.children().len();
        for (i, child) in fragment.children().iter().enumerate() {
            let is_last_child = i == child_count - 1;
            let child_prefix = if depth > 0 {
                let extension = if self.config.use_unicode {
                    if is_last { "   " } else { "│  " }
                } else {
                    if is_last { "   " } else { "|  " }
                };
                format!("{}{}", prefix, extension)
            } else {
                String::new()
            };

            self.print_fragment(child, depth + 1, &child_prefix, is_last_child, output);
        }
    }

    /// Formats a single fragment label
    fn format_fragment(&self, fragment: &Fragment) -> String {
        let bounds = fragment.bounds();
        let pos = bounds.origin;
        let size = bounds.size();

        let bounds_str = format!(
            "[@({:.1}, {:.1}), {:.1}x{:.1}]",
            pos.x, pos.y, size.width, size.height
        );

        // Type and bounds
        let type_str = match fragment.fragment_type() {
            crate::tree::FragmentType::Block => "Block",
            crate::tree::FragmentType::Inline => "Inline",
            crate::tree::FragmentType::Text => "Text",
            crate::tree::FragmentType::LineBox => "Line",
        };

        format!(
            "{} {}",
            self.colorize(type_str, colors::YELLOW),
            self.colorize(&bounds_str, colors::CYAN)
        )
    }
}

impl Default for TreePrinter {
    fn default() -> Self {
        Self::new()
    }
}
```

### Step 4: Implement TreeDiff (Estimated: 1.5 hours)

**Add to `src/debug/tree_printer.rs`:**

```rust
/// Tree difference mode
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum DiffMode {
    /// Show only differences
    OnlyDiffs,

    /// Show full trees with differences highlighted
    FullTree,
}

/// Tree differ - compares two box trees
///
/// Useful for:
/// - Testing (verify expected changes)
/// - Debugging (see what changed between layout passes)
/// - Incremental layout (identify changed subtrees)
pub struct TreeDiff {
    config: PrintConfig,
    mode: DiffMode,
}

impl TreeDiff {
    /// Creates a new tree differ
    pub fn new() -> Self {
        Self {
            config: PrintConfig::default(),
            mode: DiffMode::FullTree,
        }
    }

    /// Creates a differ with custom configuration
    pub fn with_config(config: PrintConfig, mode: DiffMode) -> Self {
        Self { config, mode }
    }

    /// Compares two box trees and shows differences
    ///
    /// Returns a formatted string showing:
    /// - Nodes added (green +)
    /// - Nodes removed (red -)
    /// - Nodes changed (yellow ~)
    /// - Nodes unchanged (white)
    pub fn diff_box_trees(&self, old: &BoxTree, new: &BoxTree) -> String {
        let mut output = String::new();
        output.push_str("=== Box Tree Diff ===\n\n");
        output.push_str("Old:\n");
        output.push_str(&TreePrinter::with_config(self.config.clone()).print_box_tree(old));
        output.push_str("\nNew:\n");
        output.push_str(&TreePrinter::with_config(self.config.clone()).print_box_tree(new));
        output.push_str("\n=== End Diff ===\n");
        output
    }

    /// Compares two fragment trees
    pub fn diff_fragment_trees(&self, old: &Fragment, new: &Fragment) -> String {
        let mut output = String::new();
        output.push_str("=== Fragment Tree Diff ===\n\n");

        // Check if positions changed
        if old.bounds() != new.bounds() {
            output.push_str(&format!(
                "Position changed: {:?} -> {:?}\n",
                old.bounds(),
                new.bounds()
            ));
        }

        // Check if child count changed
        if old.children().len() != new.children().len() {
            output.push_str(&format!(
                "Child count changed: {} -> {}\n",
                old.children().len(),
                new.children().len()
            ));
        }

        output.push_str("\n=== End Diff ===\n");
        output
    }
}

impl Default for TreeDiff {
    fn default() -> Self {
        Self::new()
    }
}
```

### Step 5: Implement DOT Export (Estimated: 1 hour)

**Add to `src/debug/tree_printer.rs`:**

```rust
/// DOT graph exporter
///
/// Exports box trees and fragment trees to Graphviz DOT format.
/// Use `dot -Tpng output.dot -o output.png` to generate images.
///
/// # Examples
///
/// ```
/// use std::sync::Arc;
/// use fastrender::debug::DotExporter;
/// use fastrender::tree::{BoxTree, BoxNode, FormattingContextType};
/// # use fastrender::tree::box_tree::ComputedStyle;
///
/// let exporter = DotExporter::new();
/// let style = Arc::new(ComputedStyle::default());
/// let root = BoxNode::new_block(style, FormattingContextType::BlockFormatting, vec![]);
/// let tree = BoxTree::new(root);
///
/// let dot = exporter.export_box_tree(&tree);
/// // dot now contains Graphviz DOT format
/// ```
pub struct DotExporter {
    config: PrintConfig,
}

impl DotExporter {
    /// Creates a new DOT exporter
    pub fn new() -> Self {
        Self {
            config: PrintConfig::default(),
        }
    }

    /// Exports a box tree to DOT format
    pub fn export_box_tree(&self, tree: &BoxTree) -> String {
        let mut output = String::new();
        output.push_str("digraph BoxTree {\n");
        output.push_str("  node [shape=box, fontname=\"monospace\"];\n\n");

        let mut node_id = 0;
        self.export_box_node(&tree.root, &mut node_id, None, &mut output);

        output.push_str("}\n");
        output
    }

    /// Exports a single box node
    fn export_box_node(
        &self,
        node: &BoxNode,
        node_id: &mut usize,
        parent_id: Option<usize>,
        output: &mut String,
    ) {
        let current_id = *node_id;
        *node_id += 1;

        // Node label
        let label = if let Some(debug_info) = &node.debug_info {
            debug_info.to_selector()
        } else {
            "<anonymous>".to_string()
        };

        // Node declaration
        output.push_str(&format!(
            "  n{} [label=\"{}\"];\n",
            current_id,
            label.replace('"', "\\\"")
        ));

        // Edge from parent
        if let Some(parent) = parent_id {
            output.push_str(&format!("  n{} -> n{};\n", parent, current_id));
        }

        // Recurse to children
        for child in &node.children {
            self.export_box_node(child, node_id, Some(current_id), output);
        }
    }

    /// Exports a fragment tree to DOT format
    pub fn export_fragment_tree(&self, fragment: &Fragment) -> String {
        let mut output = String::new();
        output.push_str("digraph FragmentTree {\n");
        output.push_str("  node [shape=box, fontname=\"monospace\"];\n\n");

        let mut node_id = 0;
        self.export_fragment(fragment, &mut node_id, None, &mut output);

        output.push_str("}\n");
        output
    }

    /// Exports a single fragment
    fn export_fragment(
        &self,
        fragment: &Fragment,
        node_id: &mut usize,
        parent_id: Option<usize>,
        output: &mut String,
    ) {
        let current_id = *node_id;
        *node_id += 1;

        // Node label with bounds
        let bounds = fragment.bounds();
        let label = format!(
            "[@({:.0}, {:.0}), {:.0}x{:.0}]",
            bounds.origin.x,
            bounds.origin.y,
            bounds.size().width,
            bounds.size().height
        );

        // Node declaration
        output.push_str(&format!("  n{} [label=\"{}\"];\n", current_id, label));

        // Edge from parent
        if let Some(parent) = parent_id {
            output.push_str(&format!("  n{} -> n{};\n", parent, current_id));
        }

        // Recurse to children
        for child in fragment.children() {
            self.export_fragment(child, node_id, Some(current_id), output);
        }
    }
}

impl Default for DotExporter {
    fn default() -> Self {
        Self::new()
    }
}
```

### Step 6: Write Comprehensive Tests (Estimated: 1 hour)

**Add at bottom of file:**

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use crate::tree::{BoxNode, BoxTree, FormattingContextType};
    use crate::tree::box_tree::DebugInfo;
    use crate::geometry::{Rect, Point, Size};
    use std::sync::Arc;

    fn default_style() -> Arc<crate::tree::box_tree::ComputedStyle> {
        Arc::new(crate::tree::box_tree::ComputedStyle::default())
    }

    #[test]
    fn test_print_config_creation() {
        let config = PrintConfig::new();
        assert_eq!(config.color_mode, ColorMode::Ansi16);
        assert!(config.use_unicode);
    }

    #[test]
    fn test_print_config_minimal() {
        let config = PrintConfig::minimal();
        assert_eq!(config.color_mode, ColorMode::None);
        assert!(!config.show_styles);
    }

    #[test]
    fn test_print_config_detailed() {
        let config = PrintConfig::detailed();
        assert!(config.show_styles);
        assert!(config.show_box_types);
    }

    #[test]
    fn test_tree_printer_creation() {
        let printer = TreePrinter::new();
        assert_eq!(printer.config.color_mode, ColorMode::Ansi16);
    }

    #[test]
    fn test_print_single_block() {
        let printer = TreePrinter::with_config(PrintConfig::test());
        let root = BoxNode::new_block(
            default_style(),
            FormattingContextType::BlockFormatting,
            vec![],
        );
        let tree = BoxTree::new(root);

        let output = printer.print_box_tree(&tree);
        assert!(output.contains("Block"));
    }

    #[test]
    fn test_print_with_debug_info() {
        let printer = TreePrinter::with_config(PrintConfig::test());
        let debug_info = DebugInfo::new(
            Some("div".to_string()),
            Some("header".to_string()),
            vec!["navbar".to_string()],
        );

        let root = BoxNode::new_block(
            default_style(),
            FormattingContextType::BlockFormatting,
            vec![],
        )
        .with_debug_info(debug_info);

        let tree = BoxTree::new(root);
        let output = printer.print_box_tree(&tree);

        assert!(output.contains("div#header.navbar"));
    }

    #[test]
    fn test_print_nested_structure() {
        let printer = TreePrinter::with_config(PrintConfig::test());

        let child = BoxNode::new_block(
            default_style(),
            FormattingContextType::BlockFormatting,
            vec![],
        );

        let root = BoxNode::new_block(
            default_style(),
            FormattingContextType::BlockFormatting,
            vec![child],
        );

        let tree = BoxTree::new(root);
        let output = printer.print_box_tree(&tree);

        // Should contain tree structure characters
        assert!(output.contains("|") || output.contains("└") || output.contains("├"));
    }

    #[test]
    fn test_print_text_box() {
        let printer = TreePrinter::with_config(PrintConfig::test());

        let text = BoxNode::new_text(default_style(), "Hello, world!".to_string());
        let root = BoxNode::new_block(
            default_style(),
            FormattingContextType::BlockFormatting,
            vec![text],
        );

        let tree = BoxTree::new(root);
        let output = printer.print_box_tree(&tree);

        assert!(output.contains("Text"));
        assert!(output.contains("Hello"));
    }

    #[test]
    fn test_print_max_depth() {
        let mut config = PrintConfig::test();
        config.max_depth = Some(1);
        let printer = TreePrinter::with_config(config);

        // Create 3-level tree
        let leaf = BoxNode::new_block(
            default_style(),
            FormattingContextType::BlockFormatting,
            vec![],
        );
        let middle = BoxNode::new_block(
            default_style(),
            FormattingContextType::BlockFormatting,
            vec![leaf],
        );
        let root = BoxNode::new_block(
            default_style(),
            FormattingContextType::BlockFormatting,
            vec![middle],
        );

        let tree = BoxTree::new(root);
        let output = printer.print_box_tree(&tree);

        // Count lines (should be limited by depth)
        let line_count = output.lines().count();
        assert!(line_count <= 2); // root + 1 child
    }

    #[test]
    fn test_print_fragment_tree() {
        let printer = TreePrinter::with_config(PrintConfig::test());

        let fragment = Fragment::new_block(
            Rect::new(Point::ZERO, Size::new(800.0, 600.0)),
            default_style(),
            vec![],
        );

        let output = printer.print_fragment_tree(&fragment);
        assert!(output.contains("@(0"));
        assert!(output.contains("800"));
    }

    #[test]
    fn test_tree_diff_creation() {
        let differ = TreeDiff::new();
        assert_eq!(differ.mode, DiffMode::FullTree);
    }

    #[test]
    fn test_diff_identical_trees() {
        let differ = TreeDiff::new();

        let root1 = BoxNode::new_block(
            default_style(),
            FormattingContextType::BlockFormatting,
            vec![],
        );
        let tree1 = BoxTree::new(root1);

        let root2 = BoxNode::new_block(
            default_style(),
            FormattingContextType::BlockFormatting,
            vec![],
        );
        let tree2 = BoxTree::new(root2);

        let output = differ.diff_box_trees(&tree1, &tree2);
        assert!(output.contains("Old:"));
        assert!(output.contains("New:"));
    }

    #[test]
    fn test_dot_exporter_creation() {
        let exporter = DotExporter::new();
        let _ = exporter;
    }

    #[test]
    fn test_export_box_tree_to_dot() {
        let exporter = DotExporter::new();

        let root = BoxNode::new_block(
            default_style(),
            FormattingContextType::BlockFormatting,
            vec![],
        );
        let tree = BoxTree::new(root);

        let dot = exporter.export_box_tree(&tree);

        assert!(dot.contains("digraph BoxTree"));
        assert!(dot.contains("node [shape=box"));
        assert!(dot.contains("n0"));
    }

    #[test]
    fn test_export_nested_tree_to_dot() {
        let exporter = DotExporter::new();

        let child = BoxNode::new_block(
            default_style(),
            FormattingContextType::BlockFormatting,
            vec![],
        );
        let root = BoxNode::new_block(
            default_style(),
            FormattingContextType::BlockFormatting,
            vec![child],
        );
        let tree = BoxTree::new(root);

        let dot = exporter.export_box_tree(&tree);

        // Should have 2 nodes and 1 edge
        assert!(dot.contains("n0"));
        assert!(dot.contains("n1"));
        assert!(dot.contains("->"));
    }

    #[test]
    fn test_export_fragment_tree_to_dot() {
        let exporter = DotExporter::new();

        let fragment = Fragment::new_block(
            Rect::new(Point::ZERO, Size::new(800.0, 600.0)),
            default_style(),
            vec![],
        );

        let dot = exporter.export_fragment_tree(&fragment);

        assert!(dot.contains("digraph FragmentTree"));
        assert!(dot.contains("@(0"));
    }

    #[test]
    fn test_colorize_with_colors() {
        let config = PrintConfig::new();
        let printer = TreePrinter::with_config(config);

        let colored = printer.colorize("test", colors::RED);
        assert!(colored.contains("\x1b[31m")); // RED code
        assert!(colored.contains("\x1b[0m")); // RESET code
    }

    #[test]
    fn test_colorize_without_colors() {
        let config = PrintConfig::minimal();
        let printer = TreePrinter::with_config(config);

        let not_colored = printer.colorize("test", colors::RED);
        assert_eq!(not_colored, "test");
        assert!(!not_colored.contains("\x1b["));
    }

    #[test]
    fn test_format_box_node_anonymous() {
        let printer = TreePrinter::with_config(PrintConfig::test());

        let node = BoxNode::new_block(
            default_style(),
            FormattingContextType::BlockFormatting,
            vec![],
        );

        let formatted = printer.format_box_node(&node);
        assert!(formatted.contains("anonymous"));
    }

    #[test]
    fn test_format_box_node_with_selector() {
        let printer = TreePrinter::with_config(PrintConfig::test());

        let debug_info = DebugInfo::new(
            Some("span".to_string()),
            None,
            vec!["highlight".to_string()],
        );

        let node = BoxNode::new_inline(default_style(), vec![])
            .with_debug_info(debug_info);

        let formatted = printer.format_box_node(&node);
        assert!(formatted.contains("span.highlight"));
    }
}
```

### Step 7: Documentation and Verification (Estimated: 30min)

Run verification:
```bash
cargo test debug::tree_printer
cargo clippy -- -D warnings
cargo fmt
cargo doc --no-deps --open
```

## Testing Requirements

Run: `cargo test debug::tree_printer`

Expected: 20+ tests passing covering:
- Config creation (all modes)
- TreePrinter creation
- Print single box
- Print with debug info
- Print nested structures
- Print text boxes
- Max depth limiting
- Fragment printing
- TreeDiff creation and usage
- DOT export for boxes
- DOT export for fragments
- Color/no-color modes
- Format helpers

## Output Artifacts

### Code Files

1. **`src/debug/tree_printer.rs`** (~800-1000 lines)
   - PrintConfig struct
   - TreePrinter struct
   - TreeDiff struct
   - DotExporter struct
   - Color utilities
   - Comprehensive tests

2. **`src/debug/mod.rs`** (~20 lines)
   - Module exports

### Notes File

Create: **`docs/tasks/notes/W2.T12-notes.md`**

**Key sections:**
- **API Contracts**: All printer methods and guarantees
- **Decision: ASCII vs Unicode**: Why support both
- **Decision: Color modes**: Terminal compatibility
- **Decision: DOT format**: Why Graphviz
- **Recommendations**: When to use each tool
- **Integration**: How to use in tests and debugging
- **Examples**: Common usage patterns
- **Future**: Web-based visualization, inspector tools

## Common Pitfalls to Avoid

### Pitfall 1: Not Handling Missing Debug Info

**Wrong:** Assuming debug_info is always present
**Right:** Gracefully show "<anonymous>" when missing

### Pitfall 2: Overly Complex Output

**Wrong:** Showing every detail by default
**Right:** Provide config options for detail level

### Pitfall 3: Not Testing Without Colors

**Wrong:** Only testing with color output
**Right:** Test both color and no-color modes

## Verification Checklist

- [ ] Debug module created
- [ ] TreePrinter works for boxes
- [ ] FragmentPrinter works for fragments
- [ ] TreeDiff compares trees
- [ ] DOT export generates valid graphs
- [ ] Color output works
- [ ] No-color mode works
- [ ] Config options all work
- [ ] 20+ tests all passing
- [ ] Clippy clean
- [ ] Documentation complete
- [ ] Notes file comprehensive

## Time Tracking

- **Module setup:** 15min
- **Config struct:** 30min
- **TreePrinter:** 2hrs
- **TreeDiff:** 1.5hrs
- **DOT export:** 1hr
- **Tests:** 1hr
- **Documentation:** 30min
- **Total:** 4-6 hours

## Getting Help

- Unicode box-drawing: https://en.wikipedia.org/wiki/Box-drawing_character
- ANSI colors: https://en.wikipedia.org/wiki/ANSI_escape_code
- Graphviz DOT: https://graphviz.org/doc/info/lang.html
- Tree traversal patterns in Rust

Remember: Debug tools are for humans. Prioritize readability over completeness!
