---
task_id: "W2.T04"
title: "Implement LayoutConstraints"
wave: 2
estimated_hours: 3-4
depends_on:
  - "W1.T01"
  - "W1.T03"
inputs:
  - "outputs/notes/W1.T01-notes.md"
  - "outputs/notes/W1.T03-notes.md"
  - "src/geometry.rs"
  - "src/style/values.rs"
outputs:
  - "src/layout/constraints.rs"
  - "src/layout/mod.rs"
  - "outputs/notes/W2.T04-notes.md"
skills_required:
  - "Rust"
  - "CSS layout concepts"
  - "Constraint systems"
context_files:
  - "docs/plan/01-type-system.md"
verification:
  - "cargo test layout::constraints"
  - "cargo clippy -- -D warnings"
  - "cargo fmt --check"
---

# Implement LayoutConstraints

## Context

Every layout algorithm needs to know what space is available for sizing boxes. This task implements **LayoutConstraints** - the input to formatting contexts that describes available space and sizing requirements.

LayoutConstraints answers:
- "How much space do I have to work with?"
- "Is my width definite (100px) or indefinite (auto)?"
- "Should I size to min-content or max-content?"

This is a **Wave 2** task that depends on:
- **W1.T01**: Geometry types (Size) - constraints use dimensions
- **W1.T03**: Length types - for specifying constraint values

### Background

**CSS Sizing:**

CSS sizing has several modes:
1. **Definite size**: Exact dimension given (width: 100px)
2. **Indefinite size**: Size is unconstrained (width: auto)
3. **Min-content size**: Smallest size that doesn't overflow
4. **Max-content size**: Largest size without wrapping
5. **Fit-content size**: Between min and max, with available space limit

**Constraint Propagation:**

Layout is recursive. Each formatting context:
1. Receives constraints from parent
2. Computes child constraints
3. Calls child layout with new constraints
4. Uses child results to determine own size

Example cascade:
```
Viewport (800×600)
  → Block container gets LayoutConstraints { width: Definite(800), height: Indefinite }
    → Child block gets LayoutConstraints { width: Definite(760), height: Indefinite }
      (parent width minus margins)
```

**Available Space:**

CSS Sizing Level 3 defines AvailableSpace:
- **Definite(value)**: Specific size available
- **Indefinite**: No constraint, size to content
- **MinContent**: Size to minimum without overflow
- **MaxContent**: Size to maximum without wrapping
- **FitContent(limit)**: Prefer max-content but clamp to limit

**Why This Matters:**

LayoutConstraints are used by:
- **W2.T07**: FormattingContext trait (takes constraints as input)
- **W3.T04**: Block layout (uses constraints to size blocks)
- **W4.T12**: Inline layout (uses constraints for line width)
- **W4.T15**: Flex layout (distributes available space)

Without LayoutConstraints:
- Can't communicate available space to children
- Can't implement auto sizing
- Can't handle flexible layouts
- Can't respect container queries

Every layout pass uses constraints.

## Prerequisites

### Required Knowledge
- **CSS sizing**: Definite vs indefinite, intrinsic sizes
- **Rust enums**: Discriminated unions
- **CSS box model**: How available space is computed

### Required Reading
1. **CSS Sizing Module Level 3**: https://www.w3.org/TR/css-sizing-3/
   - Section 2: Sizing Properties
   - Section 4: Intrinsic Sizes
2. **outputs/notes/W1.T01-notes.md**: Size type API
3. **outputs/notes/W1.T03-notes.md**: Length types

## Inputs

### From Dependencies

**W1.T01-notes.md** (Geometry):
- Use `Size` for definite dimensions
- f32 for all measurements
- Keep consistent with geometry precision

**W1.T03-notes.md** (Length types):
- Constraints may need to be resolved from percentages
- Use f32 for resolved values
- Remember percentage resolution context

**Key insights:**
```rust
// Constraints use f32 for consistency
pub struct LayoutConstraints {
    pub available_width: AvailableSpace,
    pub available_height: AvailableSpace,
}

// AvailableSpace uses f32 for definite values
pub enum AvailableSpace {
    Definite(f32),
    // ...
}
```

## Objectives

### Primary Goals

1. **Implement AvailableSpace enum**: All space modes
2. **Implement LayoutConstraints struct**: Width and height constraints
3. **Add constraint operations**: Shrinking, clamping, querying
4. **Add helper constructors**: Common constraint patterns
5. **Comprehensive tests**: All operations, edge cases

### Success Criteria

- [ ] AvailableSpace enum with 4 variants (Definite, Indefinite, MinContent, MaxContent)
- [ ] LayoutConstraints struct with available_width and available_height
- [ ] Helper constructors: new(), definite(), indefinite(), fit_content()
- [ ] Methods: with_width(), with_height() for modifications
- [ ] Methods: shrink_width_by(), shrink_height_by() for insets
- [ ] Methods: is_width_definite(), is_height_definite() for queries
- [ ] Method: clamp_size() to constrain results
- [ ] All types derive Debug, Clone, Copy (where possible), PartialEq
- [ ] 20+ comprehensive tests covering all operations
- [ ] All tests pass
- [ ] Clippy clean, full documentation

## Implementation Guide

### Step 1: Create Layout Module (Estimated: 15min)

**What to do:**
1. Create `src/layout/` directory
2. Create `src/layout/constraints.rs`
3. Create `src/layout/mod.rs`
4. Update `src/lib.rs`

**Code:**

```bash
mkdir -p src/layout
touch src/layout/constraints.rs
touch src/layout/mod.rs
```

Update `src/lib.rs`:
```rust
pub mod layout;
```

Create `src/layout/mod.rs`:
```rust
//! Layout algorithms and supporting types
//!
//! This module contains the layout engine implementation:
//! - Constraint types
//! - Formatting contexts
//! - Layout algorithms (block, inline, flex, grid)

pub mod constraints;

// Re-exports
pub use constraints::{AvailableSpace, LayoutConstraints};
```

### Step 2: Implement AvailableSpace Enum (Estimated: 1 hour)

**What to do:**
1. Define enum with all space modes
2. Add helper methods
3. Document thoroughly

**Code in `src/layout/constraints.rs`:**

```rust
//! Layout constraints
//!
//! Constraints describe the available space for layout. Every layout algorithm
//! takes constraints as input to determine sizing.
//!
//! # Available Space
//!
//! CSS defines several modes for available space:
//! - **Definite**: Specific size is available
//! - **Indefinite**: No constraint, size to content
//! - **MinContent**: Size to minimum without overflow
//! - **MaxContent**: Size to maximum without wrapping
//!
//! Reference: CSS Sizing Module Level 3, Section 2.4
//! https://www.w3.org/TR/css-sizing-3/#available
//!
//! # Examples
//!
//! ```
//! use fastrender::layout::{AvailableSpace, LayoutConstraints};
//!
//! let constraints = LayoutConstraints::new(
//!     AvailableSpace::Definite(800.0),
//!     AvailableSpace::Indefinite,
//! );
//!
//! assert!(constraints.is_width_definite());
//! assert!(!constraints.is_height_definite());
//! ```

use std::fmt;

/// Available space for layout
///
/// Represents how much space is available in a particular dimension.
/// Used to communicate constraints from parent to child during layout.
///
/// # Variants
///
/// - **Definite**: Specific amount of space available
/// - **Indefinite**: No constraint, size to content
/// - **MinContent**: Size to minimum without overflow
/// - **MaxContent**: Size to maximum without wrapping
///
/// Reference: CSS Sizing Level 3, Section 2.4
///
/// # Examples
///
/// ```
/// use fastrender::layout::AvailableSpace;
///
/// let definite = AvailableSpace::Definite(100.0);
/// assert!(definite.is_definite());
/// assert_eq!(definite.to_option(), Some(100.0));
///
/// let indefinite = AvailableSpace::Indefinite;
/// assert!(!indefinite.is_definite());
/// assert_eq!(indefinite.to_option(), None);
/// ```
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum AvailableSpace {
    /// Specific amount of space available (in CSS pixels)
    ///
    /// Example: Parent is 800px wide, so child has Definite(800.0) available
    Definite(f32),

    /// No constraint on size, should size to content
    ///
    /// Example: Height is usually indefinite, size based on content
    Indefinite,

    /// Size to minimum content without overflow
    ///
    /// Used for: Calculating intrinsic sizes, shrink-to-fit
    MinContent,

    /// Size to maximum content without wrapping
    ///
    /// Used for: Calculating intrinsic sizes, preferred widths
    MaxContent,
}

impl AvailableSpace {
    /// Returns true if this is a definite space
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::layout::AvailableSpace;
    ///
    /// assert!(AvailableSpace::Definite(100.0).is_definite());
    /// assert!(!AvailableSpace::Indefinite.is_definite());
    /// ```
    pub fn is_definite(self) -> bool {
        matches!(self, Self::Definite(_))
    }

    /// Returns true if this is indefinite space
    pub fn is_indefinite(self) -> bool {
        matches!(self, Self::Indefinite)
    }

    /// Returns true if this is min-content sizing
    pub fn is_min_content(self) -> bool {
        matches!(self, Self::MinContent)
    }

    /// Returns true if this is max-content sizing
    pub fn is_max_content(self) -> bool {
        matches!(self, Self::MaxContent)
    }

    /// Returns the definite value if available, otherwise None
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::layout::AvailableSpace;
    ///
    /// assert_eq!(AvailableSpace::Definite(100.0).to_option(), Some(100.0));
    /// assert_eq!(AvailableSpace::Indefinite.to_option(), None);
    /// ```
    pub fn to_option(self) -> Option<f32> {
        match self {
            Self::Definite(value) => Some(value),
            _ => None,
        }
    }

    /// Returns the definite value, or a default if not definite
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::layout::AvailableSpace;
    ///
    /// assert_eq!(AvailableSpace::Definite(100.0).or_else(50.0), 100.0);
    /// assert_eq!(AvailableSpace::Indefinite.or_else(50.0), 50.0);
    /// ```
    pub fn or_else(self, default: f32) -> f32 {
        match self {
            Self::Definite(value) => value,
            _ => default,
        }
    }

    /// Subtracts a value from definite space, returning new space
    ///
    /// If space is not definite, returns unchanged.
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::layout::AvailableSpace;
    ///
    /// let space = AvailableSpace::Definite(100.0);
    /// let shrunk = space.shrink_by(20.0);
    /// assert_eq!(shrunk, AvailableSpace::Definite(80.0));
    ///
    /// let indefinite = AvailableSpace::Indefinite;
    /// assert_eq!(indefinite.shrink_by(20.0), AvailableSpace::Indefinite);
    /// ```
    pub fn shrink_by(self, amount: f32) -> Self {
        match self {
            Self::Definite(value) => Self::Definite((value - amount).max(0.0)),
            other => other,
        }
    }

    /// Maps a definite value, leaving other variants unchanged
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::layout::AvailableSpace;
    ///
    /// let space = AvailableSpace::Definite(100.0);
    /// let doubled = space.map(|v| v * 2.0);
    /// assert_eq!(doubled, AvailableSpace::Definite(200.0));
    /// ```
    pub fn map<F>(self, f: F) -> Self
    where
        F: FnOnce(f32) -> f32,
    {
        match self {
            Self::Definite(value) => Self::Definite(f(value)),
            other => other,
        }
    }

    /// Clamps a definite value between min and max
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::layout::AvailableSpace;
    ///
    /// let space = AvailableSpace::Definite(150.0);
    /// let clamped = space.clamp(50.0, 100.0);
    /// assert_eq!(clamped, AvailableSpace::Definite(100.0));
    /// ```
    pub fn clamp(self, min: f32, max: f32) -> Self {
        self.map(|v| v.clamp(min, max))
    }
}

impl fmt::Display for AvailableSpace {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Definite(value) => write!(f, "{}px", value),
            Self::Indefinite => write!(f, "auto"),
            Self::MinContent => write!(f, "min-content"),
            Self::MaxContent => write!(f, "max-content"),
        }
    }
}
```

### Step 3: Implement LayoutConstraints Struct (Estimated: 1.5 hours)

**What to do:**
1. Define struct with width and height constraints
2. Add constructors
3. Add modification methods
4. Add query methods

**Code:**

```rust
/// Layout constraints describing available space
///
/// Constraints specify how much space is available in each dimension.
/// Every layout algorithm takes constraints as input.
///
/// # Examples
///
/// ```
/// use fastrender::layout::{AvailableSpace, LayoutConstraints};
///
/// // Fixed width, flexible height (common for blocks)
/// let constraints = LayoutConstraints::new(
///     AvailableSpace::Definite(800.0),
///     AvailableSpace::Indefinite,
/// );
///
/// // Shrink for margins/padding
/// let inner = constraints.shrink_width_by(40.0);
/// assert_eq!(inner.available_width, AvailableSpace::Definite(760.0));
/// ```
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct LayoutConstraints {
    /// Available space in the inline direction (width for horizontal-tb)
    pub available_width: AvailableSpace,

    /// Available space in the block direction (height for horizontal-tb)
    pub available_height: AvailableSpace,
}

impl LayoutConstraints {
    /// Creates new constraints with the given available space
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::layout::{AvailableSpace, LayoutConstraints};
    ///
    /// let constraints = LayoutConstraints::new(
    ///     AvailableSpace::Definite(800.0),
    ///     AvailableSpace::Definite(600.0),
    /// );
    ///
    /// assert!(constraints.is_width_definite());
    /// assert!(constraints.is_height_definite());
    /// ```
    pub const fn new(available_width: AvailableSpace, available_height: AvailableSpace) -> Self {
        Self {
            available_width,
            available_height,
        }
    }

    /// Creates constraints with definite width and height
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::layout::LayoutConstraints;
    ///
    /// let constraints = LayoutConstraints::definite(800.0, 600.0);
    /// assert!(constraints.is_width_definite());
    /// assert!(constraints.is_height_definite());
    /// ```
    pub const fn definite(width: f32, height: f32) -> Self {
        Self::new(
            AvailableSpace::Definite(width),
            AvailableSpace::Definite(height),
        )
    }

    /// Creates constraints with definite width and indefinite height
    ///
    /// This is the most common constraint for block layout.
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::layout::LayoutConstraints;
    ///
    /// let constraints = LayoutConstraints::definite_width(800.0);
    /// assert!(constraints.is_width_definite());
    /// assert!(constraints.is_height_indefinite());
    /// ```
    pub const fn definite_width(width: f32) -> Self {
        Self::new(
            AvailableSpace::Definite(width),
            AvailableSpace::Indefinite,
        )
    }

    /// Creates constraints with indefinite dimensions
    ///
    /// Used for sizing to content in both dimensions.
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::layout::LayoutConstraints;
    ///
    /// let constraints = LayoutConstraints::indefinite();
    /// assert!(!constraints.is_width_definite());
    /// assert!(!constraints.is_height_definite());
    /// ```
    pub const fn indefinite() -> Self {
        Self::new(AvailableSpace::Indefinite, AvailableSpace::Indefinite)
    }

    /// Creates constraints for min-content sizing
    ///
    /// Used to compute the minimum size needed.
    pub const fn min_content() -> Self {
        Self::new(AvailableSpace::MinContent, AvailableSpace::MinContent)
    }

    /// Creates constraints for max-content sizing
    ///
    /// Used to compute the preferred size.
    pub const fn max_content() -> Self {
        Self::new(AvailableSpace::MaxContent, AvailableSpace::MaxContent)
    }

    // Modification methods (builder pattern)

    /// Returns new constraints with the specified width
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::layout::{AvailableSpace, LayoutConstraints};
    ///
    /// let constraints = LayoutConstraints::indefinite()
    ///     .with_width(AvailableSpace::Definite(800.0));
    ///
    /// assert!(constraints.is_width_definite());
    /// ```
    pub const fn with_width(mut self, width: AvailableSpace) -> Self {
        self.available_width = width;
        self
    }

    /// Returns new constraints with the specified height
    pub const fn with_height(mut self, height: AvailableSpace) -> Self {
        self.available_height = height;
        self
    }

    /// Shrinks the available width by the given amount
    ///
    /// Used for accounting for margins, padding, and borders.
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::layout::{AvailableSpace, LayoutConstraints};
    ///
    /// let outer = LayoutConstraints::definite_width(800.0);
    /// let inner = outer.shrink_width_by(40.0); // 20px margins on each side
    ///
    /// assert_eq!(inner.available_width, AvailableSpace::Definite(760.0));
    /// ```
    pub fn shrink_width_by(mut self, amount: f32) -> Self {
        self.available_width = self.available_width.shrink_by(amount);
        self
    }

    /// Shrinks the available height by the given amount
    pub fn shrink_height_by(mut self, amount: f32) -> Self {
        self.available_height = self.available_height.shrink_by(amount);
        self
    }

    /// Shrinks both dimensions by the given amounts
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::layout::LayoutConstraints;
    ///
    /// let outer = LayoutConstraints::definite(800.0, 600.0);
    /// let inner = outer.shrink_by(40.0, 30.0);
    ///
    /// // Width: 800 - 40 = 760
    /// // Height: 600 - 30 = 570
    /// ```
    pub fn shrink_by(self, width: f32, height: f32) -> Self {
        self.shrink_width_by(width).shrink_height_by(height)
    }

    // Query methods

    /// Returns true if width is definite
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::layout::LayoutConstraints;
    ///
    /// let constraints = LayoutConstraints::definite_width(800.0);
    /// assert!(constraints.is_width_definite());
    /// ```
    pub fn is_width_definite(&self) -> bool {
        self.available_width.is_definite()
    }

    /// Returns true if height is definite
    pub fn is_height_definite(&self) -> bool {
        self.available_height.is_definite()
    }

    /// Returns true if width is indefinite
    pub fn is_width_indefinite(&self) -> bool {
        self.available_width.is_indefinite()
    }

    /// Returns true if height is indefinite
    pub fn is_height_indefinite(&self) -> bool {
        self.available_height.is_indefinite()
    }

    /// Returns true if both dimensions are definite
    pub fn is_fully_definite(&self) -> bool {
        self.is_width_definite() && self.is_height_definite()
    }

    /// Returns the definite width, if any
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::layout::LayoutConstraints;
    ///
    /// let constraints = LayoutConstraints::definite_width(800.0);
    /// assert_eq!(constraints.definite_width(), Some(800.0));
    /// ```
    pub fn definite_width(&self) -> Option<f32> {
        self.available_width.to_option()
    }

    /// Returns the definite height, if any
    pub fn definite_height(&self) -> Option<f32> {
        self.available_height.to_option()
    }

    /// Clamps a size to fit within definite constraints
    ///
    /// If constraints are indefinite, returns the size unchanged.
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::layout::LayoutConstraints;
    /// use fastrender::geometry::Size;
    ///
    /// let constraints = LayoutConstraints::definite(800.0, 600.0);
    /// let size = Size::new(1000.0, 400.0);
    /// let clamped = constraints.clamp_size(size);
    ///
    /// assert_eq!(clamped.width, 800.0); // Clamped to constraint
    /// assert_eq!(clamped.height, 400.0); // Within constraint
    /// ```
    pub fn clamp_size(&self, size: crate::geometry::Size) -> crate::geometry::Size {
        let width = if let Some(max_width) = self.definite_width() {
            size.width.min(max_width)
        } else {
            size.width
        };

        let height = if let Some(max_height) = self.definite_height() {
            size.height.min(max_height)
        } else {
            size.height
        };

        crate::geometry::Size::new(width, height)
    }
}

impl fmt::Display for LayoutConstraints {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "Constraints(w: {}, h: {})",
            self.available_width, self.available_height
        )
    }
}

impl Default for LayoutConstraints {
    /// Default constraints are indefinite in both dimensions
    fn default() -> Self {
        Self::indefinite()
    }
}
```

### Step 4: Write Comprehensive Tests (Estimated: 1 hour)

**Code:**

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use crate::geometry::Size;

    // AvailableSpace tests
    #[test]
    fn test_available_space_is_definite() {
        assert!(AvailableSpace::Definite(100.0).is_definite());
        assert!(!AvailableSpace::Indefinite.is_definite());
        assert!(!AvailableSpace::MinContent.is_definite());
        assert!(!AvailableSpace::MaxContent.is_definite());
    }

    #[test]
    fn test_available_space_to_option() {
        assert_eq!(AvailableSpace::Definite(100.0).to_option(), Some(100.0));
        assert_eq!(AvailableSpace::Indefinite.to_option(), None);
        assert_eq!(AvailableSpace::MinContent.to_option(), None);
    }

    #[test]
    fn test_available_space_or_else() {
        assert_eq!(AvailableSpace::Definite(100.0).or_else(50.0), 100.0);
        assert_eq!(AvailableSpace::Indefinite.or_else(50.0), 50.0);
        assert_eq!(AvailableSpace::MinContent.or_else(50.0), 50.0);
    }

    #[test]
    fn test_available_space_shrink_by() {
        assert_eq!(
            AvailableSpace::Definite(100.0).shrink_by(20.0),
            AvailableSpace::Definite(80.0)
        );
        assert_eq!(
            AvailableSpace::Indefinite.shrink_by(20.0),
            AvailableSpace::Indefinite
        );
    }

    #[test]
    fn test_available_space_shrink_by_negative() {
        // Shrinking should never go below 0
        assert_eq!(
            AvailableSpace::Definite(10.0).shrink_by(20.0),
            AvailableSpace::Definite(0.0)
        );
    }

    #[test]
    fn test_available_space_map() {
        let space = AvailableSpace::Definite(100.0);
        let doubled = space.map(|v| v * 2.0);
        assert_eq!(doubled, AvailableSpace::Definite(200.0));

        let indefinite = AvailableSpace::Indefinite;
        let mapped = indefinite.map(|v| v * 2.0);
        assert_eq!(mapped, AvailableSpace::Indefinite);
    }

    #[test]
    fn test_available_space_clamp() {
        assert_eq!(
            AvailableSpace::Definite(150.0).clamp(50.0, 100.0),
            AvailableSpace::Definite(100.0)
        );
        assert_eq!(
            AvailableSpace::Definite(25.0).clamp(50.0, 100.0),
            AvailableSpace::Definite(50.0)
        );
        assert_eq!(
            AvailableSpace::Definite(75.0).clamp(50.0, 100.0),
            AvailableSpace::Definite(75.0)
        );
    }

    // LayoutConstraints constructor tests
    #[test]
    fn test_constraints_new() {
        let constraints = LayoutConstraints::new(
            AvailableSpace::Definite(800.0),
            AvailableSpace::Indefinite,
        );

        assert_eq!(constraints.available_width, AvailableSpace::Definite(800.0));
        assert_eq!(constraints.available_height, AvailableSpace::Indefinite);
    }

    #[test]
    fn test_constraints_definite() {
        let constraints = LayoutConstraints::definite(800.0, 600.0);

        assert!(constraints.is_width_definite());
        assert!(constraints.is_height_definite());
        assert_eq!(constraints.definite_width(), Some(800.0));
        assert_eq!(constraints.definite_height(), Some(600.0));
    }

    #[test]
    fn test_constraints_definite_width() {
        let constraints = LayoutConstraints::definite_width(800.0);

        assert!(constraints.is_width_definite());
        assert!(constraints.is_height_indefinite());
    }

    #[test]
    fn test_constraints_indefinite() {
        let constraints = LayoutConstraints::indefinite();

        assert!(!constraints.is_width_definite());
        assert!(!constraints.is_height_definite());
        assert!(constraints.is_width_indefinite());
        assert!(constraints.is_height_indefinite());
    }

    #[test]
    fn test_constraints_min_content() {
        let constraints = LayoutConstraints::min_content();

        assert!(constraints.available_width.is_min_content());
        assert!(constraints.available_height.is_min_content());
    }

    #[test]
    fn test_constraints_max_content() {
        let constraints = LayoutConstraints::max_content();

        assert!(constraints.available_width.is_max_content());
        assert!(constraints.available_height.is_max_content());
    }

    // Builder pattern tests
    #[test]
    fn test_constraints_with_width() {
        let constraints = LayoutConstraints::indefinite()
            .with_width(AvailableSpace::Definite(800.0));

        assert!(constraints.is_width_definite());
        assert!(constraints.is_height_indefinite());
    }

    #[test]
    fn test_constraints_with_height() {
        let constraints = LayoutConstraints::indefinite()
            .with_height(AvailableSpace::Definite(600.0));

        assert!(constraints.is_width_indefinite());
        assert!(constraints.is_height_definite());
    }

    // Shrinking tests
    #[test]
    fn test_constraints_shrink_width_by() {
        let outer = LayoutConstraints::definite_width(800.0);
        let inner = outer.shrink_width_by(40.0);

        assert_eq!(inner.available_width, AvailableSpace::Definite(760.0));
    }

    #[test]
    fn test_constraints_shrink_height_by() {
        let outer = LayoutConstraints::definite(800.0, 600.0);
        let inner = outer.shrink_height_by(30.0);

        assert_eq!(inner.available_height, AvailableSpace::Definite(570.0));
    }

    #[test]
    fn test_constraints_shrink_by() {
        let outer = LayoutConstraints::definite(800.0, 600.0);
        let inner = outer.shrink_by(40.0, 30.0);

        assert_eq!(inner.available_width, AvailableSpace::Definite(760.0));
        assert_eq!(inner.available_height, AvailableSpace::Definite(570.0));
    }

    #[test]
    fn test_constraints_shrink_indefinite() {
        let outer = LayoutConstraints::indefinite();
        let inner = outer.shrink_by(40.0, 30.0);

        // Shrinking indefinite should remain indefinite
        assert!(inner.is_width_indefinite());
        assert!(inner.is_height_indefinite());
    }

    // Query tests
    #[test]
    fn test_is_fully_definite() {
        assert!(LayoutConstraints::definite(800.0, 600.0).is_fully_definite());
        assert!(!LayoutConstraints::definite_width(800.0).is_fully_definite());
        assert!(!LayoutConstraints::indefinite().is_fully_definite());
    }

    // clamp_size tests
    #[test]
    fn test_clamp_size_within_bounds() {
        let constraints = LayoutConstraints::definite(800.0, 600.0);
        let size = Size::new(400.0, 300.0);
        let clamped = constraints.clamp_size(size);

        assert_eq!(clamped.width, 400.0);
        assert_eq!(clamped.height, 300.0);
    }

    #[test]
    fn test_clamp_size_exceeds_width() {
        let constraints = LayoutConstraints::definite(800.0, 600.0);
        let size = Size::new(1000.0, 300.0);
        let clamped = constraints.clamp_size(size);

        assert_eq!(clamped.width, 800.0);
        assert_eq!(clamped.height, 300.0);
    }

    #[test]
    fn test_clamp_size_exceeds_height() {
        let constraints = LayoutConstraints::definite(800.0, 600.0);
        let size = Size::new(400.0, 800.0);
        let clamped = constraints.clamp_size(size);

        assert_eq!(clamped.width, 400.0);
        assert_eq!(clamped.height, 600.0);
    }

    #[test]
    fn test_clamp_size_indefinite() {
        let constraints = LayoutConstraints::indefinite();
        let size = Size::new(1000.0, 800.0);
        let clamped = constraints.clamp_size(size);

        // No clamping for indefinite
        assert_eq!(clamped.width, 1000.0);
        assert_eq!(clamped.height, 800.0);
    }

    #[test]
    fn test_clamp_size_partial_definite() {
        let constraints = LayoutConstraints::definite_width(800.0);
        let size = Size::new(1000.0, 800.0);
        let clamped = constraints.clamp_size(size);

        assert_eq!(clamped.width, 800.0); // Clamped
        assert_eq!(clamped.height, 800.0); // Not clamped
    }

    // Display tests
    #[test]
    fn test_available_space_display() {
        assert_eq!(format!("{}", AvailableSpace::Definite(100.0)), "100px");
        assert_eq!(format!("{}", AvailableSpace::Indefinite), "auto");
        assert_eq!(format!("{}", AvailableSpace::MinContent), "min-content");
        assert_eq!(format!("{}", AvailableSpace::MaxContent), "max-content");
    }

    #[test]
    fn test_constraints_display() {
        let constraints = LayoutConstraints::definite_width(800.0);
        let display = format!("{}", constraints);
        assert!(display.contains("800px"));
        assert!(display.contains("auto"));
    }

    // Default test
    #[test]
    fn test_constraints_default() {
        let constraints = LayoutConstraints::default();
        assert!(constraints.is_width_indefinite());
        assert!(constraints.is_height_indefinite());
    }
}
```

### Step 5: Documentation and Verification (Estimated: 30min)

**Commands:**

```bash
# Run tests
cargo test layout::constraints

# Check clippy
cargo clippy -- -D warnings

# Format code
cargo fmt

# Generate documentation
cargo doc --no-deps --open
```

## Testing Requirements

### Unit Tests

**Expected:** 20+ tests covering:
- All AvailableSpace operations
- All LayoutConstraints constructors
- Shrinking operations
- Query methods
- Size clamping
- Edge cases

## Output Artifacts

### Code Files

1. **`src/layout/constraints.rs`**
   - AvailableSpace enum
   - LayoutConstraints struct
   - Comprehensive tests (~35 tests)

### Notes File

Create: **`outputs/notes/W2.T04-notes.md`**

```markdown
# Task W2.T04 Output Notes

## Implementation Summary

Implemented layout constraints system:
- **AvailableSpace enum**: 4 variants (Definite, Indefinite, MinContent, MaxContent)
- **LayoutConstraints struct**: Width and height constraints
- **Helper methods**: Constructors, shrinking, querying, clamping
- **Comprehensive tests**: 35+ tests covering all operations

Constraints describe available space for layout algorithms.

## API Contracts

### Public Types

```rust
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum AvailableSpace {
    Definite(f32),
    Indefinite,
    MinContent,
    MaxContent,
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub struct LayoutConstraints {
    pub available_width: AvailableSpace,
    pub available_height: AvailableSpace,
}
```

### Key Methods

```rust
impl AvailableSpace {
    pub fn is_definite(self) -> bool;
    pub fn to_option(self) -> Option<f32>;
    pub fn shrink_by(self, amount: f32) -> Self;
    pub fn map<F>(self, f: F) -> Self;
}

impl LayoutConstraints {
    pub const fn new(width: AvailableSpace, height: AvailableSpace) -> Self;
    pub const fn definite(width: f32, height: f32) -> Self;
    pub const fn definite_width(width: f32) -> Self;
    pub fn shrink_width_by(self, amount: f32) -> Self;
    pub fn shrink_by(self, width: f32, height: f32) -> Self;
    pub fn is_width_definite(&self) -> bool;
    pub fn clamp_size(&self, size: Size) -> Size;
}
```

## Decisions Made

### Decision 1: Copy for LayoutConstraints

**Choice:** LayoutConstraints derives Copy
**Rationale:**
- Small type (2 enums, ~16 bytes)
- Frequently passed to functions
- Immutable by design
- No allocation needed

**Impact:** Can pass by value efficiently

### Decision 2: Builder Pattern for Modifications

**Choice:** Methods return new constraints (not &mut self)
**Rationale:**
- Encourages immutability
- Allows method chaining
- Clearer API
- Matches Rust idioms

**Example:** `constraints.shrink_width_by(20).shrink_height_by(10)`

### Decision 3: Separate Min/Max Content

**Choice:** MinContent and MaxContent as separate variants
**Rationale:**
- CSS defines these as distinct sizing modes
- Different algorithms for each
- Not a simple numeric comparison
- Clearer than bool flag

## Spec Interpretations

### Available Space

**Spec says:** CSS Sizing Level 3 defines available space modes
**Interpretation:** Implemented as enum with 4 variants
**Reasoning:** Direct mapping from spec to code
**Test coverage:** All variants tested

## Discoveries & Gotchas

### Discovery 1: Shrinking Indefinite

**What:** Shrinking indefinite space remains indefinite
**Why it matters:** Margins/padding don't make indefinite definite
**Recommendation:** Always check result after shrinking

### Gotcha 1: Percentage Resolution

**Problem:** Constraints don't resolve percentages
**Solution:** Layout algorithms must resolve based on constraint value
**Warning:** Percentage of indefinite is special case (usually treated as auto)

### Gotcha 2: Min/Max Content vs Intrinsic

**Problem:** Min/max content constraints trigger special sizing
**Solution:** Layout algorithms must have separate code paths
**Example:** Text doesn't wrap for max-content, wraps to min for min-content

## Performance Notes

### Performance Characteristics
- All operations O(1)
- No allocations
- Copy is fast (small type)
- Pattern matching optimized by compiler

## Recommendations for Downstream Tasks

### For Task W2.T07 (FormattingContext):
- Take LayoutConstraints as first parameter
- Return Size or Rect
- Use definite_width() to check if width is known
- Shrink constraints for child margins/padding

### For Task W3.T04 (Block Layout):
- Use definite_width() for width computation
- Height usually indefinite (size to content)
- Shrink by padding/border before child layout
- Clamp child sizes with clamp_size()

### For Task W4.T12 (Inline Layout):
- Use definite_width for line width
- Create constraints for child inline boxes
- Min/max content for intrinsic width calculation

### For Task W4.T15 (Flex Layout):
- Use constraints to determine flex basis
- MinContent/MaxContent for flex sizing algorithm
- Distribute available definite space to flex items

## Open Questions

None - constraints design is well-defined by CSS spec.

## Test Coverage

### What's Tested
- ✅ All AvailableSpace variants and methods
- ✅ All LayoutConstraints constructors
- ✅ Builder pattern methods
- ✅ Shrinking operations
- ✅ Query methods
- ✅ Size clamping
- ✅ Edge cases (negative shrink, indefinite operations)

### Test Statistics
- Unit tests: 35 tests
- All tests pass: ✅
- Coverage: All public methods

## Code Quality
- ✅ Clippy passes
- ✅ Rustfmt applied
- ✅ Full documentation
- ✅ Display trait implemented

## References Used
1. CSS Sizing Module Level 3: https://www.w3.org/TR/css-sizing-3/
2. W1.T01-notes.md (Geometry types)
3. W1.T03-notes.md (Length types)

---

**Task completed:** [DATE]
**Time taken:** 3.5 hours
**Tests passing:** 35/35
```

## Common Pitfalls to Avoid

### Pitfall 1: Forgetting to Shrink Constraints

**Wrong:** Passing parent constraints directly to child
**Right:** Shrink by margins, padding, borders first

### Pitfall 2: Treating Indefinite as Zero

**Wrong:** `constraints.definite_width().unwrap_or(0.0)`
**Right:** Check with `is_width_definite()`, use sizing algorithm if not

### Pitfall 3: Not Handling Min/Max Content

**Wrong:** Ignoring MinContent/MaxContent variants
**Right:** Implement separate sizing logic for intrinsic sizes

## Verification Checklist

- [ ] All objectives met
- [ ] AvailableSpace enum complete
- [ ] LayoutConstraints complete
- [ ] All helper methods working
- [ ] Tests pass: `cargo test layout::constraints`
- [ ] Clippy clean
- [ ] Documentation complete
- [ ] Notes file created

## Time Tracking

- **Module setup:** 15min
- **AvailableSpace enum:** 1hr
- **LayoutConstraints struct:** 1.5hrs
- **Testing:** 1hr
- **Documentation:** 30min
- **Total:** 3-4 hours

## Getting Help

If stuck:
1. **CSS Sizing Level 3**: Definitive spec for available space
2. **W1.T01-notes.md**: Size type usage
3. **Flexbox spec**: Good examples of constraint propagation
