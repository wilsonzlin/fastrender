---
task_id: "W2.T07"
title: "Define FormattingContext Trait and Infrastructure"
wave: 2
estimated_hours: 4-6
depends_on:
  - "W2.T01"
  - "W2.T03"
  - "W2.T04"
  - "W1.R01"
inputs:
  - "docs/tasks/notes/W2.T01-notes.md"
  - "docs/tasks/notes/W2.T03-notes.md"
  - "docs/tasks/notes/W2.T04-notes.md"
  - "docs/tasks/notes/W1.R01-notes.md"
  - "src/tree/box_tree.rs"
outputs:
  - "src/layout/formatting_context.rs"
  - "src/layout/constraints.rs"
  - "src/layout/mod.rs"
  - "docs/tasks/notes/W2.T07-notes.md"
skills_required:
  - "Rust traits"
  - "Generic programming"
  - "CSS layout algorithms"
context_files:
  - "docs/core/formatting-contexts.md"
  - "docs/tasks/notes/W1.R01-notes.md"
verification:
  - "cargo test layout::formatting_context"
  - "cargo clippy -- -D warnings"
---

# Define FormattingContext Trait and Infrastructure

## Context

The FormattingContext trait is the **core abstraction** of the entire layout system. Every layout algorithm (block, inline, flex, grid, table) implements this trait, providing a uniform interface for the layout engine.

This is the most important architectural decision in FastRender V2. Get this trait wrong and every layout implementation will suffer.

### Background

**What is a Formatting Context?**

From CSS 2.1 Section 9.4:
> "Boxes in the normal flow belong to a formatting context, which may be block or inline, but not both simultaneously."

A formatting context is an environment with specific layout rules:
- **Block FC**: Boxes stack vertically, margins collapse
- **Inline FC**: Boxes flow horizontally, wrap at line boundaries
- **Flex FC**: Boxes use flexbox algorithm
- **Grid FC**: Boxes positioned in 2D grid
- **Table FC**: Table-specific layout rules

**Why a Trait?**

We need polymorphism: the layout engine doesn't care whether it's laying out blocks or flex items - it just calls `layout()` on the appropriate FormattingContext implementation.

Benefits:
- **Modularity**: Each FC is independently implementable
- **Extensibility**: New FCs can be added without modifying core
- **Testability**: Each FC can be tested in isolation
- **Parallelization**: Different FCs can be implemented concurrently

### Why This Matters

The FormattingContext trait is consumed by:
- **W2.T10**: LayoutEngine (dispatches to appropriate FC)
- **W3.T04**: BlockFormattingContext implementation
- **W4.T12**: InlineFormattingContext implementation
- **W3.T08**: FlexFormattingContext wrapper
- **W3.T06**: TableFormattingContext implementation

Without this trait:
- Can't implement layout algorithms
- Can't switch between different layout modes
- Can't handle nested formatting contexts
- Can't build the layout engine

Every layout implementation in Waves 3-4 depends on this trait.

## Prerequisites

### Required Knowledge
- **Rust traits**: Associated types, trait objects, trait bounds
- **CSS formatting contexts**: Understanding of BFC vs IFC vs Flex
- **Layout constraints**: Available space, percentage bases

### Required Reading
1. **docs/tasks/notes/W1.R01-notes.md**: CSS formatting context concepts
2. **docs/tasks/notes/W2.T01-notes.md**: BoxNode API
3. **docs/tasks/notes/W2.T03-notes.md**: FragmentNode API
4. **docs/tasks/notes/W2.T04-notes.md**: LayoutConstraints API
5. **Rust Book Chapter 10.2**: Traits

## Inputs

### From Dependencies

1. **W2.T01-notes.md** (BoxNode)
   - Look for: BoxNode API, what data is available
   - Look for: FormattingContextType enum
   - Key insight: BoxNode tells us which FC to use

2. **W2.T03-notes.md** (FragmentNode)
   - Look for: Fragment API, what must be produced
   - Look for: How to construct fragments
   - Key insight: layout() returns Fragment

3. **W2.T04-notes.md** (LayoutConstraints)
   - Look for: Available space, percentage bases
   - Look for: How to pass context to layout
   - Key insight: Constraints are input to layout

4. **W1.R01-notes.md** (CSS Research)
   - Look for: BFC vs IFC differences
   - Look for: Common operations across all FCs
   - Key insight: What operations ALL FCs must support

### Existing Code

Read:
- `src/tree/box_tree.rs` - BoxNode types
- `src/tree/fragment.rs` - Fragment types (from W2.T03)
- `src/layout/constraints.rs` - LayoutConstraints (from W2.T04)

## Objectives

### Primary Goals

1. **Define FormattingContext trait**: Core layout abstraction
2. **Define LayoutConstraints**: Input to layout (available space, bases)
3. **Define AvailableSpace**: Definite | MinContent | MaxContent
4. **Define IntrinsicSizingMode**: For intrinsic size queries
5. **Create module structure**: layout module organization
6. **Document trait contract**: What implementers must do
7. **Write trait-level tests**: Test trait requirements

### Success Criteria

- [ ] FormattingContext trait with layout() method
- [ ] LayoutConstraints struct complete
- [ ] AvailableSpace enum (Definite, MinContent, MaxContent)
- [ ] Intrinsic sizing support (min-content, max-content)
- [ ] Trait documentation explains contract
- [ ] Example stub implementation for testing
- [ ] Integration with BoxNode and Fragment
- [ ] All tests pass
- [ ] Clippy clean
- [ ] Notes file comprehensive

## Implementation Guide

### Step 1: Create Layout Module (Estimated: 30min)

```bash
mkdir -p src/layout
touch src/layout/formatting_context.rs
touch src/layout/constraints.rs
touch src/layout/mod.rs
```

**`src/layout/mod.rs`:**
```rust
//! Layout system
//!
//! This module contains the layout engine and formatting context implementations.

pub mod formatting_context;
pub mod constraints;

pub use formatting_context::{FormattingContext, IntrinsicSizingMode};
pub use constraints::{LayoutConstraints, AvailableSpace};
```

### Step 2: Define AvailableSpace and Constraints (Estimated: 1.5 hours)

**`src/layout/constraints.rs`:**
```rust
//! Layout constraints and available space
//!
//! This module defines how available space is communicated to layout algorithms.

use crate::geometry::Size;

/// Available space in a dimension
///
/// CSS layout can have three types of available space:
/// 1. **Definite**: Fixed size (width: 800px)
/// 2. **MinContent**: Shrink to minimum content size
/// 3. **MaxContent**: Expand to maximum content size
///
/// Reference: CSS Sizing Module Level 3
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum AvailableSpace {
    /// Definite size
    Definite(f32),
    
    /// Shrink to minimum content size
    MinContent,
    
    /// Expand to maximum content size
    MaxContent,
}

impl AvailableSpace {
    pub fn is_definite(&self) -> bool {
        matches!(self, Self::Definite(_))
    }
    
    pub fn definite_value(&self) -> Option<f32> {
        match self {
            Self::Definite(v) => Some(*v),
            _ => None,
        }
    }
}

/// Layout constraints passed to formatting contexts
///
/// Contains all the information a layout algorithm needs about available space
/// and sizing context.
#[derive(Debug, Clone, Copy)]
pub struct LayoutConstraints {
    /// Available width
    pub available_width: AvailableSpace,
    
    /// Available height
    pub available_height: AvailableSpace,
    
    /// Percentage base for width (containing block width)
    pub percentage_base_width: f32,
    
    /// Percentage base for height (containing block height)
    pub percentage_base_height: f32,
}

impl LayoutConstraints {
    pub fn new(width: AvailableSpace, height: AvailableSpace) -> Self {
        Self {
            available_width: width,
            available_height: height,
            percentage_base_width: 0.0,
            percentage_base_height: 0.0,
        }
    }
    
    pub fn with_definite_size(width: f32, height: f32) -> Self {
        Self {
            available_width: AvailableSpace::Definite(width),
            available_height: AvailableSpace::Definite(height),
            percentage_base_width: width,
            percentage_base_height: height,
        }
    }
}
```

### Step 3: Define FormattingContext Trait (Estimated: 2 hours)

**`src/layout/formatting_context.rs`:**
```rust
//! Formatting Context trait - core layout abstraction
//!
//! All layout algorithms implement this trait.

use crate::tree::{BoxNode, Fragment};
use crate::layout::constraints::{LayoutConstraints, AvailableSpace};
use crate::geometry::Size;

/// Intrinsic sizing mode for querying content-based sizes
#[derive(Debug, Clone, Copy)]
pub enum IntrinsicSizingMode {
    /// Minimum content size (narrowest possible without overflow)
    MinContent,
    
    /// Maximum content size (widest without line breaking)
    MaxContent,
}

/// Common trait for all formatting contexts
///
/// This trait abstracts the layout algorithm. Every formatting context
/// (block, inline, flex, grid, table) implements this trait.
///
/// # Contract
///
/// Implementers must:
/// 1. Take a BoxNode and LayoutConstraints
/// 2. Recursively layout children using appropriate child FCs
/// 3. Return a positioned Fragment tree
/// 4. Handle both definite and indefinite sizing
/// 5. Support intrinsic size queries
///
/// # Example Implementation
///
/// See W3.T04 (BlockFormattingContext) for a complete implementation.
pub trait FormattingContext: Send + Sync {
    /// Lays out a box within this formatting context
    ///
    /// # Arguments
    /// * `box_node` - The box to layout
    /// * `constraints` - Available space and percentage bases
    ///
    /// # Returns
    /// A positioned fragment tree
    ///
    /// # Errors
    /// Returns error if layout cannot proceed (e.g., circular dependencies)
    fn layout(
        &self,
        box_node: &BoxNode,
        constraints: &LayoutConstraints,
    ) -> Result<Fragment, LayoutError>;
    
    /// Computes intrinsic size for a box
    ///
    /// Used when parent needs to know content-based size before layout.
    ///
    /// # Arguments
    /// * `box_node` - The box to measure
    /// * `mode` - MinContent or MaxContent
    ///
    /// # Returns
    /// Intrinsic size in the inline axis
    fn compute_intrinsic_inline_size(
        &self,
        box_node: &BoxNode,
        mode: IntrinsicSizingMode,
    ) -> Result<f32, LayoutError>;
}

/// Layout errors
#[derive(Debug)]
pub enum LayoutError {
    /// Box type not supported by this FC
    UnsupportedBoxType(String),
    
    /// Circular dependency in sizing
    CircularDependency,
    
    /// Missing required context
    MissingContext(String),
}

impl std::fmt::Display for LayoutError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::UnsupportedBoxType(msg) => write!(f, "Unsupported box type: {}", msg),
            Self::CircularDependency => write!(f, "Circular dependency in layout"),
            Self::MissingContext(msg) => write!(f, "Missing context: {}", msg),
        }
    }
}

impl std::error::Error for LayoutError {}
```

### Step 4: Create Stub Implementation for Testing (Estimated: 1 hour)

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use crate::tree::{BoxNode, Fragment, FormattingContextType};
    use crate::geometry::{Rect, Size, Point};
    use std::sync::Arc;
    
    // Stub FC for testing trait requirements
    struct StubFormattingContext;
    
    impl FormattingContext for StubFormattingContext {
        fn layout(
            &self,
            box_node: &BoxNode,
            constraints: &LayoutConstraints,
        ) -> Result<Fragment, LayoutError> {
            // Stub: just return empty fragment
            Ok(Fragment::new_block(
                Rect::new(Point::ZERO, Size::new(100.0, 50.0)),
                box_node.style.clone(),
                vec![],
            ))
        }
        
        fn compute_intrinsic_inline_size(
            &self,
            _box_node: &BoxNode,
            _mode: IntrinsicSizingMode,
        ) -> Result<f32, LayoutError> {
            Ok(100.0)
        }
    }
    
    #[test]
    fn test_stub_fc_implements_trait() {
        let fc = StubFormattingContext;
        let style = Arc::new(crate::tree::box_tree::ComputedStyle::default());
        let box_node = BoxNode::new_block(
            style,
            FormattingContextType::Block,
            vec![],
        );
        
        let constraints = LayoutConstraints::with_definite_size(800.0, 600.0);
        let fragment = fc.layout(&box_node, &constraints).unwrap();
        
        assert_eq!(fragment.size().width, 100.0);
    }
    
    #[test]
    fn test_intrinsic_sizing() {
        let fc = StubFormattingContext;
        let style = Arc::new(crate::tree::box_tree::ComputedStyle::default());
        let box_node = BoxNode::new_block(
            style,
            FormattingContextType::Block,
            vec![],
        );
        
        let min_size = fc.compute_intrinsic_inline_size(
            &box_node,
            IntrinsicSizingMode::MinContent,
        ).unwrap();
        
        assert_eq!(min_size, 100.0);
    }
}
```

## Testing Requirements

Run: `cargo test layout::formatting_context`

Expected: Tests verify trait can be implemented and used.

## Output Artifacts

### Code Files

1. **`src/layout/formatting_context.rs`** (~200 lines)
2. **`src/layout/constraints.rs`** (~100 lines)
3. **`src/layout/mod.rs`** (~20 lines)

### Notes File

Create: **`docs/tasks/notes/W2.T07-notes.md`**

Key sections:
- **API Contract**: Exact trait requirements
- **Decision: Send + Sync bounds**: Why trait objects need these
- **Decision: Result return**: Why layout can fail
- **Recommendations**: How to implement for each FC type
- **Integration**: How W2.T10 (LayoutEngine) will use this
- **Critical**: How to handle recursive layout

## Common Pitfalls

### Pitfall 1: Forgetting Recursive Layout

**Wrong:** Only layout the box itself
**Right:** Must recursively layout all children using appropriate child FCs

### Pitfall 2: Not Handling Indefinite Sizes

**Wrong:** Assume width/height are always definite
**Right:** Handle AvailableSpace::MinContent and MaxContent

### Pitfall 3: Not Supporting Intrinsic Sizing

**Wrong:** Only implement layout()
**Right:** Must also implement compute_intrinsic_inline_size()

## Verification Checklist

- [ ] Trait compiles
- [ ] Stub implementation works
- [ ] Tests pass
- [ ] Documentation explains contract
- [ ] Notes file complete

## Time Tracking

- **Module setup:** 30min
- **Constraints:** 1.5hrs
- **Trait definition:** 2hrs
- **Tests:** 1hr
- **Documentation:** 1hr
- **Total:** 4-6 hours

Remember: This trait is the foundation of all layout. Get it right!
