---
task_id: "W2.T06"
title: "Implement DebugInfo Types"
wave: 2
estimated_hours: 2-3
depends_on:
  - "W2.T01"
inputs:
  - "src/tree/box_tree.rs"
outputs:
  - "src/tree/debug.rs"
  - "docs/tasks/notes/W2.T06-notes.md"
skills_required:
  - "Rust"
  - "String formatting"
  - "Tree visualization"
context_files:
  - "docs/core/type-system.md"
verification:
  - "cargo test tree::debug"
  - "cargo clippy -- -D warnings"
  - "cargo fmt --check"
---

# Implement DebugInfo Types

## Context

When debugging layout issues or developing FastRender, we need to know which DOM element generated which box/fragment. This task implements **DebugInfo** - metadata attached to boxes and fragments that links back to source elements and provides developer-friendly output.

DebugInfo includes:
- Element tag name (div, span, p)
- Element ID and classes
- Source location in DOM
- Pretty-printed tree visualization

This is a **Wave 2** task depending on:
- **W2.T01**: BoxNode type (DebugInfo attaches to BoxNode)

### Background

**Why Debug Information?**

Without debug info:
```
BoxNode (Block) at [0, 0, 800, 600]
  └─ BoxNode (Block) at [10, 10, 100, 50]
```

With debug info:
```
BoxNode (Block) div#header.navbar at [0, 0, 800, 600]
  └─ BoxNode (Block) div.logo at [10, 10, 100, 50]
```

Much easier to understand what's happening!

**Use Cases:**

1. **Layout debugging**: "Why is this box positioned here?"
2. **Error messages**: "Invalid style on div#main"
3. **Dev tools**: Inspector showing box tree
4. **Testing**: Assert on element selectors
5. **Logging**: Trace layout algorithms

**Optional vs Required:**

DebugInfo is **optional**:
- In release builds, can be omitted (save memory)
- In debug builds, always included
- Can be toggled via feature flag

**Pretty Printing:**

Tree visualization helps understand structure:
```
div#app.container
├─ header.site-header
│  ├─ h1.title "FastRender"
│  └─ nav.menu
│     ├─ a.link "Home"
│     └─ a.link "Docs"
└─ main#content
   └─ p.text "Hello world"
```

### Why This Matters

DebugInfo is used by:
- **W3.T04+**: Layout algorithms (error messages)
- **W5.T01**: Paint (debug overlays)
- **W6.T03**: Developer tools (inspector)
- **Tests**: All tests use DebugInfo for assertions

Without DebugInfo:
- Can't debug layout issues
- Error messages are cryptic
- Testing is harder
- No dev tools possible

Every developer working on FastRender uses DebugInfo daily.

## Prerequisites

### Required Knowledge
- **Rust Option**: Optional fields
- **String formatting**: Display trait
- **Tree traversal**: Recursive pretty printing

### Required Reading
1. **W2.T01 code**: BoxNode structure
2. **Rust Display trait**: For pretty printing

## Inputs

### From Dependencies

**W2.T01 (BoxNode)**:
- DebugInfo attaches to BoxNode
- Should be `Option<DebugInfo>` (optional)
- May also attach to FragmentNode

**Key insight:**
```rust
pub struct BoxNode {
    // ... other fields ...
    pub debug_info: Option<DebugInfo>,
}
```

## Objectives

### Primary Goals

1. **Define DebugInfo struct**: Element metadata
2. **Add selector formatting**: CSS selector-like strings
3. **Add tree printing**: Pretty-printed tree visualization
4. **Add convenience methods**: Easy creation from DOM attributes
5. **Comprehensive tests**: All formatting and printing

### Success Criteria

- [ ] DebugInfo struct with tag_name, id, classes, dom_path fields
- [ ] to_selector() method returns CSS selector string
- [ ] to_string() returns readable representation
- [ ] Tree printer that outputs indented tree structure
- [ ] Helper constructors for common cases
- [ ] Works with BoxNode and FragmentNode
- [ ] All types derive Debug, Clone
- [ ] 15+ tests covering all functionality
- [ ] All tests pass
- [ ] Clippy clean, full documentation

## Implementation Guide

### Step 1: Create Debug Module (Estimated: 15min)

**What to do:**
1. Create `src/tree/debug.rs`
2. Update `src/tree/mod.rs`

**Code:**

Update `src/tree/mod.rs`:
```rust
pub mod box_tree;
pub mod box_type;
pub mod fragment_tree;
pub mod debug;

pub use debug::{DebugInfo, TreePrinter};
```

Create `src/tree/debug.rs`:
```rust
//! Debug information for boxes and fragments
//!
//! This module provides debug metadata that links boxes/fragments back to
//! source DOM elements. This is invaluable for debugging layout issues and
//! implementing developer tools.
//!
//! # Debug Information
//!
//! DebugInfo contains:
//! - Element tag name (div, span, p)
//! - Element ID
//! - Element classes
//! - DOM tree path
//!
//! # Usage
//!
//! ```
//! use fastrender::tree::DebugInfo;
//!
//! let info = DebugInfo::new(
//!     Some("div".to_string()),
//!     Some("header".to_string()),
//!     vec!["navbar".to_string(), "sticky".to_string()],
//! );
//!
//! assert_eq!(info.to_selector(), "div#header.navbar.sticky");
//! ```
//!
//! # Tree Printing
//!
//! TreePrinter outputs a pretty-printed tree structure for debugging.

use std::fmt;
```

### Step 2: Implement DebugInfo Struct (Estimated: 1 hour)

**What to do:**
1. Define struct with all fields
2. Add constructors
3. Add formatting methods

**Code:**

```rust
/// Debug information linking a box to its source DOM element
///
/// This information is optional and used only for debugging and dev tools.
/// In release builds, this can be omitted to save memory.
///
/// # Examples
///
/// ```
/// use fastrender::tree::DebugInfo;
///
/// let info = DebugInfo::new(
///     Some("div".to_string()),
///     Some("main".to_string()),
///     vec!["container".to_string()],
/// );
///
/// assert_eq!(info.tag_name.as_deref(), Some("div"));
/// assert_eq!(info.id.as_deref(), Some("main"));
/// assert_eq!(info.to_selector(), "div#main.container");
/// ```
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct DebugInfo {
    /// Element tag name (if from element)
    ///
    /// Examples: "div", "span", "p", "button"
    /// None for text nodes or anonymous boxes
    pub tag_name: Option<String>,

    /// Element ID attribute
    ///
    /// The value of the `id` attribute, if present
    pub id: Option<String>,

    /// Element class names
    ///
    /// List of classes from the `class` attribute
    pub classes: Vec<String>,

    /// DOM tree path for this element
    ///
    /// String representation of the path from root to this element
    /// Example: "html > body > div#main > p"
    pub dom_path: Option<String>,
}

impl DebugInfo {
    /// Creates debug info from element attributes
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::tree::DebugInfo;
    ///
    /// let info = DebugInfo::new(
    ///     Some("div".to_string()),
    ///     Some("header".to_string()),
    ///     vec!["navbar".to_string()],
    /// );
    ///
    /// assert!(info.tag_name.is_some());
    /// assert!(info.id.is_some());
    /// assert_eq!(info.classes.len(), 1);
    /// ```
    pub fn new(
        tag_name: Option<String>,
        id: Option<String>,
        classes: Vec<String>,
    ) -> Self {
        Self {
            tag_name,
            id,
            classes,
            dom_path: None,
        }
    }

    /// Creates debug info for a text node
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::tree::DebugInfo;
    ///
    /// let info = DebugInfo::text("Hello world");
    /// assert_eq!(info.to_selector(), "#text");
    /// ```
    pub fn text(content: &str) -> Self {
        Self {
            tag_name: Some(format!("#text({})", Self::truncate(content, 20))),
            id: None,
            classes: Vec::new(),
            dom_path: None,
        }
    }

    /// Creates debug info for an anonymous box
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::tree::DebugInfo;
    ///
    /// let info = DebugInfo::anonymous("block");
    /// assert_eq!(info.to_selector(), "#anonymous(block)");
    /// ```
    pub fn anonymous(box_type: &str) -> Self {
        Self {
            tag_name: Some(format!("#anonymous({})", box_type)),
            id: None,
            classes: Vec::new(),
            dom_path: None,
        }
    }

    /// Adds the DOM path to this debug info
    ///
    /// Builder-style method for convenience.
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::tree::DebugInfo;
    ///
    /// let info = DebugInfo::new(
    ///     Some("div".to_string()),
    ///     None,
    ///     vec![],
    /// ).with_dom_path("html > body > div");
    ///
    /// assert!(info.dom_path.is_some());
    /// ```
    pub fn with_dom_path(mut self, path: impl Into<String>) -> Self {
        self.dom_path = Some(path.into());
        self
    }

    /// Formats as a CSS selector-like string
    ///
    /// Format: `tag#id.class1.class2`
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::tree::DebugInfo;
    ///
    /// let info = DebugInfo::new(
    ///     Some("div".to_string()),
    ///     Some("header".to_string()),
    ///     vec!["navbar".to_string(), "fixed".to_string()],
    /// );
    ///
    /// assert_eq!(info.to_selector(), "div#header.navbar.fixed");
    /// ```
    pub fn to_selector(&self) -> String {
        let mut result = String::new();

        // Add tag name
        if let Some(tag) = &self.tag_name {
            result.push_str(tag);
        }

        // Add ID
        if let Some(id) = &self.id {
            result.push('#');
            result.push_str(id);
        }

        // Add classes
        for class in &self.classes {
            result.push('.');
            result.push_str(class);
        }

        // If nothing was added, return generic
        if result.is_empty() {
            result.push_str("#unknown");
        }

        result
    }

    /// Returns a short description for logging
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::tree::DebugInfo;
    ///
    /// let info = DebugInfo::new(
    ///     Some("div".to_string()),
    ///     Some("main".to_string()),
    ///     vec![],
    /// );
    ///
    /// assert_eq!(info.short_description(), "div#main");
    /// ```
    pub fn short_description(&self) -> String {
        if let Some(tag) = &self.tag_name {
            if let Some(id) = &self.id {
                format!("{}#{}", tag, id)
            } else if !self.classes.is_empty() {
                format!("{}.{}", tag, self.classes[0])
            } else {
                tag.clone()
            }
        } else {
            "#unknown".to_string()
        }
    }

    /// Truncates a string to a maximum length
    fn truncate(s: &str, max_len: usize) -> String {
        if s.len() <= max_len {
            s.to_string()
        } else {
            format!("{}...", &s[..max_len])
        }
    }
}

impl fmt::Display for DebugInfo {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.to_selector())
    }
}
```

### Step 3: Implement Tree Printer (Estimated: 1 hour)

**What to do:**
1. Create TreePrinter struct
2. Add methods for printing trees
3. Handle indentation and branches

**Code:**

```rust
/// Pretty-prints tree structures for debugging
///
/// Outputs an indented tree structure showing the hierarchy of boxes or fragments.
///
/// # Examples
///
/// ```
/// use fastrender::tree::{BoxNode, DebugInfo, TreePrinter};
/// use fastrender::geometry::Rect;
/// use std::sync::Arc;
/// # use fastrender::tree::box_tree::ComputedStyle;
///
/// let style = Arc::new(ComputedStyle::default());
/// let child = BoxNode::new_block(style.clone(), Default::default(), vec![])
///     .with_debug_info(DebugInfo::new(
///         Some("div".to_string()),
///         Some("child".to_string()),
///         vec![],
///     ));
///
/// let parent = BoxNode::new_block(style, Default::default(), vec![child])
///     .with_debug_info(DebugInfo::new(
///         Some("div".to_string()),
///         Some("parent".to_string()),
///         vec![],
///     ));
///
/// let output = TreePrinter::print_box_tree(&parent);
/// // Output:
/// // div#parent (Block)
/// // └─ div#child (Block)
/// ```
pub struct TreePrinter;

impl TreePrinter {
    /// Prints a box tree with debug information
    ///
    /// Returns a string with indented tree structure.
    pub fn print_box_tree(node: &crate::tree::BoxNode) -> String {
        let mut output = String::new();
        Self::print_box_node(node, "", true, &mut output);
        output
    }

    /// Prints a single box node with indentation
    fn print_box_node(
        node: &crate::tree::BoxNode,
        prefix: &str,
        is_last: bool,
        output: &mut String,
    ) {
        // Print this node
        let branch = if is_last { "└─ " } else { "├─ " };
        let debug_str = node
            .debug_info
            .as_ref()
            .map(|d| d.to_selector())
            .unwrap_or_else(|| "#unknown".to_string());

        let box_type = match &node.box_type {
            crate::tree::BoxType::Block(_) => "Block",
            crate::tree::BoxType::Inline(_) => "Inline",
            crate::tree::BoxType::Text(text) => &format!("Text({})", truncate(&text.text, 20)),
            crate::tree::BoxType::Replaced(_) => "Replaced",
            crate::tree::BoxType::Anonymous(_) => "Anonymous",
        };

        output.push_str(prefix);
        if !prefix.is_empty() {
            output.push_str(branch);
        }
        output.push_str(&format!("{} ({})\n", debug_str, box_type));

        // Print children
        let child_prefix = if prefix.is_empty() {
            String::new()
        } else {
            format!("{}{}", prefix, if is_last { "   " } else { "│  " })
        };

        let child_count = node.children.len();
        for (i, child) in node.children.iter().enumerate() {
            let is_last_child = i == child_count - 1;
            Self::print_box_node(child, &child_prefix, is_last_child, output);
        }
    }

    /// Prints a fragment tree with debug information
    pub fn print_fragment_tree(node: &crate::tree::FragmentNode) -> String {
        let mut output = String::new();
        Self::print_fragment_node(node, "", true, &mut output);
        output
    }

    /// Prints a single fragment node with indentation
    fn print_fragment_node(
        node: &crate::tree::FragmentNode,
        prefix: &str,
        is_last: bool,
        output: &mut String,
    ) {
        // Print this node
        let branch = if is_last { "└─ " } else { "├─ " };

        let content_type = match &node.content {
            crate::tree::FragmentContent::Block { .. } => "Block",
            crate::tree::FragmentContent::Inline { .. } => "Inline",
            crate::tree::FragmentContent::Text { text, .. } => {
                &format!("Text({})", truncate(text, 20))
            }
            crate::tree::FragmentContent::Line { .. } => "Line",
            crate::tree::FragmentContent::Replaced { .. } => "Replaced",
        };

        output.push_str(prefix);
        if !prefix.is_empty() {
            output.push_str(branch);
        }
        output.push_str(&format!(
            "{} @ [{:.0}, {:.0}, {:.0}×{:.0}]\n",
            content_type,
            node.bounds.x(),
            node.bounds.y(),
            node.bounds.width(),
            node.bounds.height()
        ));

        // Print children
        let child_prefix = if prefix.is_empty() {
            String::new()
        } else {
            format!("{}{}", prefix, if is_last { "   " } else { "│  " })
        };

        let child_count = node.children.len();
        for (i, child) in node.children.iter().enumerate() {
            let is_last_child = i == child_count - 1;
            Self::print_fragment_node(child, &child_prefix, is_last_child, output);
        }
    }
}

/// Helper function to truncate strings
fn truncate(s: &str, max_len: usize) -> String {
    if s.len() <= max_len {
        s.to_string()
    } else {
        format!("{}...", &s[..max_len])
    }
}
```

### Step 4: Write Comprehensive Tests (Estimated: 45min)

**Code:**

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_debug_info_new() {
        let info = DebugInfo::new(
            Some("div".to_string()),
            Some("main".to_string()),
            vec!["container".to_string()],
        );

        assert_eq!(info.tag_name.as_deref(), Some("div"));
        assert_eq!(info.id.as_deref(), Some("main"));
        assert_eq!(info.classes.len(), 1);
        assert_eq!(info.classes[0], "container");
    }

    #[test]
    fn test_to_selector() {
        let info = DebugInfo::new(
            Some("div".to_string()),
            Some("header".to_string()),
            vec!["navbar".to_string(), "fixed".to_string()],
        );

        assert_eq!(info.to_selector(), "div#header.navbar.fixed");
    }

    #[test]
    fn test_to_selector_tag_only() {
        let info = DebugInfo::new(Some("div".to_string()), None, vec![]);

        assert_eq!(info.to_selector(), "div");
    }

    #[test]
    fn test_to_selector_id_only() {
        let info = DebugInfo::new(None, Some("main".to_string()), vec![]);

        assert_eq!(info.to_selector(), "#main");
    }

    #[test]
    fn test_to_selector_classes_only() {
        let info = DebugInfo::new(
            None,
            None,
            vec!["button".to_string(), "primary".to_string()],
        );

        assert_eq!(info.to_selector(), ".button.primary");
    }

    #[test]
    fn test_to_selector_empty() {
        let info = DebugInfo::new(None, None, vec![]);

        assert_eq!(info.to_selector(), "#unknown");
    }

    #[test]
    fn test_text_debug_info() {
        let info = DebugInfo::text("Hello world");

        let selector = info.to_selector();
        assert!(selector.contains("#text"));
        assert!(selector.contains("Hello world"));
    }

    #[test]
    fn test_text_debug_info_truncated() {
        let long_text = "This is a very long text that should be truncated";
        let info = DebugInfo::text(long_text);

        let selector = info.to_selector();
        assert!(selector.contains("..."));
    }

    #[test]
    fn test_anonymous_debug_info() {
        let info = DebugInfo::anonymous("block");

        assert_eq!(info.to_selector(), "#anonymous(block)");
    }

    #[test]
    fn test_with_dom_path() {
        let info = DebugInfo::new(Some("div".to_string()), None, vec![])
            .with_dom_path("html > body > div");

        assert_eq!(info.dom_path.as_deref(), Some("html > body > div"));
    }

    #[test]
    fn test_short_description() {
        let info1 = DebugInfo::new(
            Some("div".to_string()),
            Some("main".to_string()),
            vec!["container".to_string()],
        );
        assert_eq!(info1.short_description(), "div#main");

        let info2 = DebugInfo::new(
            Some("span".to_string()),
            None,
            vec!["highlight".to_string()],
        );
        assert_eq!(info2.short_description(), "span.highlight");

        let info3 = DebugInfo::new(Some("p".to_string()), None, vec![]);
        assert_eq!(info3.short_description(), "p");
    }

    #[test]
    fn test_display_trait() {
        let info = DebugInfo::new(
            Some("div".to_string()),
            Some("header".to_string()),
            vec!["navbar".to_string()],
        );

        assert_eq!(format!("{}", info), "div#header.navbar");
    }

    #[test]
    fn test_debug_info_clone() {
        let info1 = DebugInfo::new(
            Some("div".to_string()),
            Some("main".to_string()),
            vec![],
        );
        let info2 = info1.clone();

        assert_eq!(info1, info2);
    }

    #[test]
    fn test_tree_printer_single_node() {
        use crate::tree::{BoxNode, FormattingContextType};
        use std::sync::Arc;
        use crate::tree::box_tree::ComputedStyle;

        let style = Arc::new(ComputedStyle::default());
        let node = BoxNode::new_block(style, FormattingContextType::Block, vec![])
            .with_debug_info(DebugInfo::new(
                Some("div".to_string()),
                Some("main".to_string()),
                vec![],
            ));

        let output = TreePrinter::print_box_tree(&node);
        assert!(output.contains("div#main"));
        assert!(output.contains("Block"));
    }

    #[test]
    fn test_tree_printer_with_children() {
        use crate::tree::{BoxNode, FormattingContextType};
        use std::sync::Arc;
        use crate::tree::box_tree::ComputedStyle;

        let style = Arc::new(ComputedStyle::default());
        let child = BoxNode::new_block(style.clone(), FormattingContextType::Block, vec![])
            .with_debug_info(DebugInfo::new(
                Some("div".to_string()),
                Some("child".to_string()),
                vec![],
            ));

        let parent = BoxNode::new_block(style, FormattingContextType::Block, vec![child])
            .with_debug_info(DebugInfo::new(
                Some("div".to_string()),
                Some("parent".to_string()),
                vec![],
            ));

        let output = TreePrinter::print_box_tree(&parent);
        assert!(output.contains("div#parent"));
        assert!(output.contains("div#child"));
        assert!(output.contains("└─")); // Branch character
    }
}
```

### Step 5: Documentation and Verification (Estimated: 30min)

**Commands:**

```bash
cargo test tree::debug
cargo clippy -- -D warnings
cargo fmt
cargo doc --no-deps --open
```

## Testing Requirements

### Unit Tests

**Expected:** 15+ tests covering:
- DebugInfo creation
- Selector formatting
- Tree printing
- Edge cases

## Output Artifacts

### Code Files

1. **`src/tree/debug.rs`**
   - DebugInfo struct
   - TreePrinter implementation
   - Tests (~17 tests)
   - ~400-500 lines total

### Notes File

Create: **`docs/tasks/notes/W2.T06-notes.md`**

```markdown
# Task W2.T06 Output Notes

## Implementation Summary

Implemented debug information system:
- **DebugInfo struct**: Element metadata (tag, id, classes, path)
- **Selector formatting**: CSS selector-like strings
- **Tree printer**: Pretty-printed tree visualization
- **Helper methods**: Text, anonymous, path builders
- **Comprehensive tests**: 17+ tests covering all functionality

DebugInfo links boxes/fragments to source DOM elements.

## API Contracts

### Public Types

```rust
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct DebugInfo {
    pub tag_name: Option<String>,
    pub id: Option<String>,
    pub classes: Vec<String>,
    pub dom_path: Option<String>,
}
```

### Key Methods

```rust
impl DebugInfo {
    pub fn new(tag: Option<String>, id: Option<String>, classes: Vec<String>) -> Self;
    pub fn text(content: &str) -> Self;
    pub fn anonymous(box_type: &str) -> Self;
    pub fn to_selector(&self) -> String;
    pub fn short_description(&self) -> String;
}

impl TreePrinter {
    pub fn print_box_tree(node: &BoxNode) -> String;
    pub fn print_fragment_tree(node: &FragmentNode) -> String;
}
```

## Decisions Made

### Decision 1: Optional by Design

**Choice:** DebugInfo is `Option<DebugInfo>` on nodes
**Rationale:**
- Not needed in release builds
- Saves memory
- Can be toggled via feature flags
- Only used for debugging

**Impact:** Always check `if let Some(debug) = &node.debug_info`

### Decision 2: String Storage

**Choice:** Store strings, not indexes/IDs
**Rationale:**
- Simpler API
- Self-contained
- No lifetime issues
- Cost acceptable (debug only)

**Alternatives Considered:** Interned strings → rejected for simplicity

### Decision 3: CSS Selector Format

**Choice:** Use CSS selector syntax (div#id.class)
**Rationale:**
- Familiar to web developers
- Concise
- Matches DevTools output
- Easy to parse visually

## Spec Interpretations

N/A - This is debugging infrastructure, not CSS spec.

## Discoveries & Gotchas

### Discovery 1: Tree Printing Unicode

**What:** Using box-drawing characters (├─ └─ │)
**Why it matters:** Makes trees much more readable
**Recommendation:** Ensure terminal supports UTF-8

### Gotcha 1: String Allocation

**Problem:** DebugInfo allocates strings
**Solution:** Only create in debug builds
**Warning:** Don't create DebugInfo in hot paths

### Gotcha 2: Text Truncation

**Problem:** Long text makes output unreadable
**Solution:** Truncate to 20 chars with "..."
**Example:** "This is very long..." instead of full text

## Performance Notes

### Performance Characteristics
- DebugInfo creation allocates
- Printing allocates strings
- Not performance-critical (debug only)
- Keep out of hot paths

### Optimization Opportunities
- Use feature flag to compile out in release
- Could intern tag names
- Could use Cow<str> instead of String

## Recommendations for Downstream Tasks

### For Task W2.T01 (BoxNode):
- Include `Option<DebugInfo>` field
- Add `.with_debug_info()` builder method

### For Task W3.T01 (Box Generation):
- Create DebugInfo from DOM element attributes
- Set dom_path during traversal
- Use DebugInfo::text() for text nodes
- Use DebugInfo::anonymous() for anonymous boxes

### For Task W3.T04+ (Layout):
- Include DebugInfo in error messages
- Use TreePrinter for debugging output
- Example: `eprintln!("Layout error at {}: ...", node.debug_info.to_selector())`

### For Task W6.T03 (Dev Tools):
- Use to_selector() for inspector
- Use TreePrinter for tree view
- Link back to DOM via dom_path

## Open Questions

None - debug info design is straightforward.

## Test Coverage

### What's Tested
- ✅ All constructors
- ✅ Selector formatting (all combinations)
- ✅ Tree printing (single and nested)
- ✅ Edge cases (empty, truncation)

### Test Statistics
- Unit tests: 17 tests
- All tests pass: ✅

## Code Quality
- ✅ Clippy passes
- ✅ Rustfmt applied
- ✅ Full documentation
- ✅ Display trait implemented

## References Used
1. W2.T01 BoxNode implementation
2. CSS selectors syntax (informal)

---

**Task completed:** [DATE]
**Time taken:** 2.5 hours
**Tests passing:** 17/17
```

## Common Pitfalls to Avoid

### Pitfall 1: Forgetting Optional

**Wrong:** Making DebugInfo required
**Right:** Always `Option<DebugInfo>` on nodes

### Pitfall 2: Creating in Hot Paths

**Wrong:** Creating DebugInfo during layout inner loops
**Right:** Create once during box generation

### Pitfall 3: Long Strings

**Wrong:** Storing full text content
**Right:** Truncate to reasonable length

## Verification Checklist

- [ ] All objectives met
- [ ] DebugInfo struct complete
- [ ] TreePrinter working
- [ ] Tests pass: `cargo test tree::debug`
- [ ] Clippy clean
- [ ] Documentation complete
- [ ] Notes file created

## Time Tracking

- **Module setup:** 15min
- **DebugInfo struct:** 1hr
- **TreePrinter:** 1hr
- **Testing:** 45min
- **Documentation:** 30min
- **Total:** 2-3 hours

## Getting Help

If stuck:
1. **W2.T01 code**: See how DebugInfo attaches to BoxNode
2. **Rust Display trait**: For formatting
3. **Tree printing examples**: Many Rust crates do this
