---
task_id: "W2.T05"
title: "Implement ComputedStyle Struct"
wave: 2
estimated_hours: 6-8
depends_on:
  - "W1.T03"
  - "W1.T04"
  - "W1.T05"
  - "W1.T06"
inputs:
  - "outputs/notes/W1.T03-notes.md"
  - "outputs/notes/W1.T04-notes.md"
  - "outputs/notes/W1.T05-notes.md"
  - "outputs/notes/W1.T06-notes.md"
  - "src/style/values.rs"
  - "src/style/color.rs"
  - "src/style/display.rs"
  - "src/style/position.rs"
outputs:
  - "src/style/computed.rs"
  - "outputs/notes/W2.T05-notes.md"
skills_required:
  - "Rust structs"
  - "CSS properties"
  - "Memory layout"
context_files:
  - "docs/plan/01-type-system.md"
verification:
  - "cargo test style::computed"
  - "cargo clippy -- -D warnings"
  - "cargo fmt --check"
---

# Implement ComputedStyle Struct

## Context

Every box in the box tree needs to know its computed styles - the final resolved values of all CSS properties after cascade, inheritance, and computation. This task implements **ComputedStyle** - the central struct containing all style information for a box.

ComputedStyle represents the "computed values" stage of CSS value processing:
1. **Specified values**: What the CSS says (`width: 2em`)
2. **Computed values**: Partially resolved (`width: 32px` if font-size is 16px)
3. **Used values**: Final after layout (`width: 320px` after resolving percentages)

This is a **Wave 2** task depending on:
- **W1.T03**: Length types - for dimensional properties
- **W1.T04**: Color types - for color properties
- **W1.T05**: Display enum - for display property
- **W1.T06**: Position enum - for position property

### Background

**CSS Properties:**

CSS defines hundreds of properties. For FastRender V2, we'll implement the most important ~50 properties:
- **Box model**: width, height, margin, padding, border
- **Positioning**: position, top, right, bottom, left, z-index
- **Display**: display, visibility
- **Color**: color, background-color, border-color
- **Text**: font-family, font-size, font-weight, line-height
- **Layout**: flex/grid properties (subset)

**Computed Value Definition:**

Per CSS spec, computed values are:
- Absolute lengths (em → px using font-size)
- Absolute colors (inherit → actual color)
- Keywords resolved where possible
- Percentages kept (resolved during layout)

**Why a Single Struct:**

Options considered:
1. **Enum per property**: Too verbose, hard to access
2. **HashMap**: Slow, no type safety
3. **Single struct**: Fast, type-safe, clear ✅

### Why This Matters

ComputedStyle is used by:
- **W2.T01**: BoxNode stores Arc<ComputedStyle>
- **W3.T04**: Block layout reads box model properties
- **W4.T12**: Inline layout reads text properties
- **W5.T01**: Paint reads color and visual properties

Without ComputedStyle:
- Can't store resolved styles
- Can't implement cascade
- Can't do layout (no dimensions)
- Can't paint (no colors)

Every box has a ComputedStyle. It's the most frequently accessed type.

## Prerequisites

### Required Knowledge
- **CSS properties**: Understanding major CSS properties
- **CSS cascade**: How values are resolved
- **Rust structs**: Large struct design
- **Memory layout**: Struct size considerations

### Required Reading
1. **CSS Cascading and Inheritance**: https://www.w3.org/TR/css-cascade-3/
2. **CSS Values**: Specified vs Computed values
3. **outputs/notes/W1.T03-W1.T06**: All value type notes
4. **docs/plan/01-type-system.md**: ComputedStyle design

## Inputs

### From Dependencies

**W1.T03-notes.md** (Length types):
- Use `Length` and `LengthOrAuto` for dimensional properties
- Remember which properties allow auto
- Note percentage resolution contexts

**W1.T04-notes.md** (Color types):
- Use `Color` for all color properties
- Consider using Rgba internally for performance

**W1.T05-notes.md** (Display enum):
- Use `Display` for display property
- Link Display value to box generation

**W1.T06-notes.md** (Position enum):
- Use `Position` for position property
- Remember positioning scheme implications

**Key insights:**
- ComputedStyle should be fairly large (~200-400 bytes)
- Use Arc<ComputedStyle> for sharing (already in W2.T01 design)
- Group related properties together
- Consider adding helper methods for common queries

## Objectives

### Primary Goals

1. **Define ComputedStyle struct**: 50+ CSS properties
2. **Group properties logically**: Box model, positioning, display, colors, text, etc.
3. **Add default implementation**: Sensible defaults for all properties
4. **Add helper methods**: Query groups of properties
5. **Add builder methods**: Easy construction for tests
6. **Comprehensive tests**: Default values, helper methods

### Success Criteria

- [ ] ComputedStyle struct with ~50 properties organized into logical groups
- [ ] All properties use appropriate value types (Length, Color, Display, etc.)
- [ ] Default implementation with CSS initial values
- [ ] Helper methods for box model (margin_*, padding_*, border_*)
- [ ] Helper methods for positioning (offset_*, inset_*)
- [ ] Helper methods for text (is_bold, is_italic, etc.)
- [ ] Helper methods for display queries
- [ ] Builder pattern for test construction
- [ ] All properties documented with CSS spec references
- [ ] All types derive Debug, Clone
- [ ] 15+ tests covering defaults and helpers
- [ ] All tests pass
- [ ] Clippy clean
- [ ] Full rustdoc documentation

## Implementation Guide

### Step 1: Plan Property Groups (Estimated: 30min)

**What to do:**
1. List all properties to implement
2. Group by category
3. Choose appropriate types

**Property groups:**
```
Box Model:
- width, height, min-width, max-width, min-height, max-height
- margin-*, padding-*, border-width-*, border-color-*, border-style-*

Positioning:
- position, top, right, bottom, left, z-index

Display:
- display, visibility, opacity

Colors:
- color, background-color

Text:
- font-family, font-size, font-weight, font-style, line-height, text-align

Flexbox (subset):
- flex-direction, flex-wrap, justify-content, align-items

Grid (subset):
- grid-template-columns, grid-template-rows (placeholder)
```

### Step 2: Create ComputedStyle Struct (Estimated: 2 hours)

**What to do:**
1. Create `src/style/computed.rs`
2. Define struct with all properties
3. Document each property

**Code:**

Update `src/style/mod.rs`:
```rust
pub mod color;
pub mod display;
pub mod position;
pub mod values;
pub mod computed;

pub use computed::ComputedStyle;
```

Create `src/style/computed.rs`:

```rust
//! Computed style values
//!
//! This module provides the ComputedStyle struct which contains resolved
//! CSS property values for a single element.
//!
//! # Computed Values
//!
//! Computed values are partially resolved:
//! - Relative units (em, rem) → absolute (px)
//! - inherit keyword → inherited value
//! - Percentages kept (resolved during layout)
//! - Colors fully resolved
//!
//! Reference: CSS Cascading and Inheritance Level 3
//! https://www.w3.org/TR/css-cascade-3/
//!
//! # Example
//!
//! ```
//! use fastrender::style::ComputedStyle;
//!
//! let style = ComputedStyle::default();
//! assert_eq!(style.font_size, 16.0); // Default font size
//! ```

use crate::geometry::EdgeOffsets;
use crate::style::{Color, Display, Length, LengthOrAuto};

use std::sync::Arc;

/// Computed CSS styles for an element
///
/// Contains all resolved CSS property values. Properties are grouped
/// by category for better organization.
///
/// # Memory Layout
///
/// This struct is designed to be wrapped in Arc and shared between
/// BoxNode and fragments. Size is ~200-300 bytes.
///
/// # Property Groups
///
/// - **Box model**: Dimensions, margin, padding, border
/// - **Positioning**: position, offsets, z-index
/// - **Display**: display, visibility, opacity
/// - **Colors**: Text and background colors
/// - **Text**: Font properties, line-height, text-align
/// - **Flexbox**: Flex container and item properties
///
/// # Examples
///
/// ```
/// use fastrender::style::ComputedStyle;
///
/// let mut style = ComputedStyle::default();
/// // Modify as needed
/// // Then wrap in Arc for sharing
/// let shared = std::sync::Arc::new(style);
/// ```
#[derive(Debug, Clone)]
pub struct ComputedStyle {
    // ===== BOX MODEL =====

    /// Width property
    ///
    /// CSS: `width`
    /// Initial: auto
    /// Percentages: relative to containing block width
    pub width: LengthOrAuto,

    /// Height property
    ///
    /// CSS: `height`
    /// Initial: auto
    /// Percentages: relative to containing block height
    pub height: LengthOrAuto,

    /// Minimum width
    ///
    /// CSS: `min-width`
    /// Initial: 0
    pub min_width: Length,

    /// Maximum width
    ///
    /// CSS: `max-width`
    /// Initial: none (represented as f32::INFINITY)
    pub max_width: Length,

    /// Minimum height
    ///
    /// CSS: `min-height`
    /// Initial: 0
    pub min_height: Length,

    /// Maximum height
    ///
    /// CSS: `max-height`
    /// Initial: none
    pub max_height: Length,

    /// Margin on all sides
    ///
    /// CSS: `margin-top`, `margin-right`, `margin-bottom`, `margin-left`
    /// Initial: 0
    /// Note: Auto margins are handled during layout
    pub margin: EdgeOffsets,

    /// Padding on all sides
    ///
    /// CSS: `padding-*`
    /// Initial: 0
    /// Note: Padding cannot be auto or negative
    pub padding: EdgeOffsets,

    /// Border width on all sides
    ///
    /// CSS: `border-*-width`
    /// Initial: medium (3px)
    pub border_width: EdgeOffsets,

    /// Border color on all sides
    ///
    /// CSS: `border-*-color`
    /// Initial: currentColor
    pub border_color: BorderColors,

    // ===== POSITIONING =====

    /// Positioning scheme
    ///
    /// CSS: `position`
    /// Initial: static
    pub position: Position,

    /// Top offset for positioned elements
    ///
    /// CSS: `top`
    /// Initial: auto
    pub top: LengthOrAuto,

    /// Right offset
    ///
    /// CSS: `right`
    /// Initial: auto
    pub right: LengthOrAuto,

    /// Bottom offset
    ///
    /// CSS: `bottom`
    /// Initial: auto
    pub bottom: LengthOrAuto,

    /// Left offset
    ///
    /// CSS: `left`
    /// Initial: auto
    pub left: LengthOrAuto,

    /// Z-index for stacking contexts
    ///
    /// CSS: `z-index`
    /// Initial: auto (None)
    pub z_index: Option<i32>,

    // ===== DISPLAY =====

    /// Display type
    ///
    /// CSS: `display`
    /// Initial: inline
    pub display: Display,

    /// Visibility
    ///
    /// CSS: `visibility`
    /// Initial: visible
    pub visibility: Visibility,

    /// Opacity
    ///
    /// CSS: `opacity`
    /// Initial: 1.0
    /// Range: 0.0 to 1.0
    pub opacity: f32,

    // ===== COLORS =====

    /// Text color
    ///
    /// CSS: `color`
    /// Initial: black (ish, depends on UA)
    pub color: Color,

    /// Background color
    ///
    /// CSS: `background-color`
    /// Initial: transparent
    pub background_color: Color,

    // ===== TEXT =====

    /// Font family names
    ///
    /// CSS: `font-family`
    /// Initial: depends on UA
    pub font_family: Vec<String>,

    /// Font size in pixels
    ///
    /// CSS: `font-size`
    /// Initial: 16px (medium)
    /// Note: Already resolved to px at computed value time
    pub font_size: f32,

    /// Font weight
    ///
    /// CSS: `font-weight`
    /// Initial: 400 (normal)
    /// Range: 100-900
    pub font_weight: u16,

    /// Font style
    ///
    /// CSS: `font-style`
    /// Initial: normal
    pub font_style: FontStyle,

    /// Line height
    ///
    /// CSS: `line-height`
    /// Initial: normal (1.2)
    /// Note: Can be length or number
    pub line_height: LineHeight,

    /// Text alignment
    ///
    /// CSS: `text-align`
    /// Initial: start
    pub text_align: TextAlign,

    // ===== FLEXBOX =====

    /// Flex direction
    ///
    /// CSS: `flex-direction`
    /// Initial: row
    pub flex_direction: FlexDirection,

    /// Flex wrap
    ///
    /// CSS: `flex-wrap`
    /// Initial: nowrap
    pub flex_wrap: FlexWrap,

    /// Justify content
    ///
    /// CSS: `justify-content`
    /// Initial: flex-start
    pub justify_content: JustifyContent,

    /// Align items
    ///
    /// CSS: `align-items`
    /// Initial: stretch
    pub align_items: AlignItems,

    /// Flex grow factor
    ///
    /// CSS: `flex-grow`
    /// Initial: 0
    pub flex_grow: f32,

    /// Flex shrink factor
    ///
    /// CSS: `flex-shrink`
    /// Initial: 1
    pub flex_shrink: f32,

    /// Flex basis
    ///
    /// CSS: `flex-basis`
    /// Initial: auto
    pub flex_basis: LengthOrAuto,
}

// Supporting types

/// Border colors for all four sides
///
/// Allows different colors per side
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct BorderColors {
    pub top: Color,
    pub right: Color,
    pub bottom: Color,
    pub left: Color,
}

impl BorderColors {
    /// Creates border colors with the same color on all sides
    pub const fn all(color: Color) -> Self {
        Self {
            top: color,
            right: color,
            bottom: color,
            left: color,
        }
    }
}

/// CSS position property values
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Position {
    Static,
    Relative,
    Absolute,
    Fixed,
    Sticky,
}

/// CSS visibility property values
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Visibility {
    Visible,
    Hidden,
    Collapse,
}

/// CSS font-style property values
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum FontStyle {
    Normal,
    Italic,
    Oblique,
}

/// CSS line-height property values
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum LineHeight {
    /// Normal line height (typically 1.2)
    Normal,
    /// Number (multiplier of font-size)
    Number(f32),
    /// Length in pixels
    Length(f32),
}

/// CSS text-align property values
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum TextAlign {
    Left,
    Right,
    Center,
    Justify,
    Start,
    End,
}

/// CSS flex-direction property values
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum FlexDirection {
    Row,
    RowReverse,
    Column,
    ColumnReverse,
}

/// CSS flex-wrap property values
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum FlexWrap {
    Nowrap,
    Wrap,
    WrapReverse,
}

/// CSS justify-content property values
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum JustifyContent {
    FlexStart,
    FlexEnd,
    Center,
    SpaceBetween,
    SpaceAround,
    SpaceEvenly,
}

/// CSS align-items property values
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum AlignItems {
    FlexStart,
    FlexEnd,
    Center,
    Baseline,
    Stretch,
}
```

### Step 3: Implement Default (Estimated: 1 hour)

**What to do:**
1. Implement Default trait with CSS initial values
2. Document each default

**Code:**

```rust
impl Default for ComputedStyle {
    /// Creates a ComputedStyle with CSS initial values
    ///
    /// This represents the default styling when no CSS is applied.
    /// Values match CSS specifications for initial values.
    fn default() -> Self {
        Self {
            // Box model defaults
            width: LengthOrAuto::Auto,
            height: LengthOrAuto::Auto,
            min_width: Length::px(0.0),
            max_width: Length::px(f32::INFINITY),
            min_height: Length::px(0.0),
            max_height: Length::px(f32::INFINITY),
            margin: EdgeOffsets::ZERO,
            padding: EdgeOffsets::ZERO,
            border_width: EdgeOffsets::all(3.0), // medium = 3px
            border_color: BorderColors::all(Color::BLACK),

            // Positioning defaults
            position: Position::Static,
            top: LengthOrAuto::Auto,
            right: LengthOrAuto::Auto,
            bottom: LengthOrAuto::Auto,
            left: LengthOrAuto::Auto,
            z_index: None,

            // Display defaults
            display: Display::Inline,
            visibility: Visibility::Visible,
            opacity: 1.0,

            // Color defaults
            color: Color::BLACK,
            background_color: Color::TRANSPARENT,

            // Text defaults
            font_family: vec!["serif".to_string()],
            font_size: 16.0, // medium = 16px
            font_weight: 400, // normal
            font_style: FontStyle::Normal,
            line_height: LineHeight::Normal,
            text_align: TextAlign::Start,

            // Flexbox defaults
            flex_direction: FlexDirection::Row,
            flex_wrap: FlexWrap::Nowrap,
            justify_content: JustifyContent::FlexStart,
            align_items: AlignItems::Stretch,
            flex_grow: 0.0,
            flex_shrink: 1.0,
            flex_basis: LengthOrAuto::Auto,
        }
    }
}
```

### Step 4: Add Helper Methods (Estimated: 2 hours)

**What to do:**
1. Add methods for common queries
2. Add methods for grouped access
3. Add convenience methods

**Code:**

```rust
impl ComputedStyle {
    // === Box Model Helpers ===

    /// Returns the total horizontal margin
    pub fn margin_horizontal(&self) -> f32 {
        self.margin.horizontal()
    }

    /// Returns the total vertical margin
    pub fn margin_vertical(&self) -> f32 {
        self.margin.vertical()
    }

    /// Returns the total horizontal padding
    pub fn padding_horizontal(&self) -> f32 {
        self.padding.horizontal()
    }

    /// Returns the total vertical padding
    pub fn padding_vertical(&self) -> f32 {
        self.padding.vertical()
    }

    /// Returns the total horizontal border width
    pub fn border_width_horizontal(&self) -> f32 {
        self.border_width.horizontal()
    }

    /// Returns the total vertical border width
    pub fn border_width_vertical(&self) -> f32 {
        self.border_width.vertical()
    }

    /// Returns the total horizontal spacing (margin + padding + border)
    ///
    /// Useful for computing content box from border box
    pub fn horizontal_spacing(&self) -> f32 {
        self.margin_horizontal() + self.padding_horizontal() + self.border_width_horizontal()
    }

    /// Returns the total vertical spacing
    pub fn vertical_spacing(&self) -> f32 {
        self.margin_vertical() + self.padding_vertical() + self.border_width_vertical()
    }

    // === Positioning Helpers ===

    /// Returns true if this element is positioned (not static)
    pub fn is_positioned(&self) -> bool {
        !matches!(self.position, Position::Static)
    }

    /// Returns true if this element is absolutely positioned
    pub fn is_absolutely_positioned(&self) -> bool {
        matches!(self.position, Position::Absolute | Position::Fixed)
    }

    /// Returns true if this element creates a stacking context
    ///
    /// Simplified check - real implementation has more conditions
    pub fn creates_stacking_context(&self) -> bool {
        self.is_positioned() && self.z_index.is_some() || self.opacity < 1.0
    }

    // === Display Helpers ===

    /// Returns true if display is none
    pub fn is_display_none(&self) -> bool {
        matches!(self.display, Display::None)
    }

    /// Returns true if element is visible
    pub fn is_visible(&self) -> bool {
        !self.is_display_none() && matches!(self.visibility, Visibility::Visible)
    }

    // === Text Helpers ===

    /// Returns true if font weight is bold (>= 700)
    pub fn is_bold(&self) -> bool {
        self.font_weight >= 700
    }

    /// Returns true if font style is italic
    pub fn is_italic(&self) -> bool {
        matches!(self.font_style, FontStyle::Italic)
    }

    /// Returns the computed line height in pixels
    ///
    /// Resolves number and normal to pixel values
    pub fn computed_line_height(&self) -> f32 {
        match self.line_height {
            LineHeight::Normal => self.font_size * 1.2,
            LineHeight::Number(n) => self.font_size * n,
            LineHeight::Length(px) => px,
        }
    }

    // === Flexbox Helpers ===

    /// Returns true if this is a flex container
    pub fn is_flex_container(&self) -> bool {
        matches!(self.display, Display::Flex | Display::InlineFlex)
    }

    /// Returns true if flex direction is horizontal
    pub fn is_flex_row(&self) -> bool {
        matches!(
            self.flex_direction,
            FlexDirection::Row | FlexDirection::RowReverse
        )
    }

    /// Returns true if flex direction is vertical
    pub fn is_flex_column(&self) -> bool {
        !self.is_flex_row()
    }
}
```

### Step 5: Add Builder Methods for Tests (Estimated: 1 hour)

**What to do:**
1. Add builder pattern methods
2. Make test construction easy

**Code:**

```rust
impl ComputedStyle {
    /// Creates a builder for constructing test styles
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::style::ComputedStyle;
    /// use fastrender::style::Display;
    ///
    /// let style = ComputedStyle::builder()
    ///     .display(Display::Block)
    ///     .font_size(20.0)
    ///     .build();
    ///
    /// assert_eq!(style.display, Display::Block);
    /// assert_eq!(style.font_size, 20.0);
    /// ```
    pub fn builder() -> ComputedStyleBuilder {
        ComputedStyleBuilder::new()
    }
}

/// Builder for ComputedStyle (useful for tests)
pub struct ComputedStyleBuilder {
    style: ComputedStyle,
}

impl ComputedStyleBuilder {
    pub fn new() -> Self {
        Self {
            style: ComputedStyle::default(),
        }
    }

    pub fn display(mut self, display: Display) -> Self {
        self.style.display = display;
        self
    }

    pub fn font_size(mut self, size: f32) -> Self {
        self.style.font_size = size;
        self
    }

    pub fn width(mut self, width: LengthOrAuto) -> Self {
        self.style.width = width;
        self
    }

    pub fn height(mut self, height: LengthOrAuto) -> Self {
        self.style.height = height;
        self
    }

    pub fn color(mut self, color: Color) -> Self {
        self.style.color = color;
        self
    }

    pub fn background_color(mut self, color: Color) -> Self {
        self.style.background_color = color;
        self
    }

    pub fn position(mut self, position: Position) -> Self {
        self.style.position = position;
        self
    }

    pub fn build(self) -> ComputedStyle {
        self.style
    }
}

impl Default for ComputedStyleBuilder {
    fn default() -> Self {
        Self::new()
    }
}
```

### Step 6: Write Tests (Estimated: 1 hour)

**Code:**

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_default_values() {
        let style = ComputedStyle::default();

        // Box model
        assert!(style.width.is_auto());
        assert!(style.height.is_auto());
        assert_eq!(style.margin, EdgeOffsets::ZERO);
        assert_eq!(style.padding, EdgeOffsets::ZERO);

        // Display
        assert_eq!(style.display, Display::Inline);
        assert_eq!(style.visibility, Visibility::Visible);
        assert_eq!(style.opacity, 1.0);

        // Text
        assert_eq!(style.font_size, 16.0);
        assert_eq!(style.font_weight, 400);
    }

    #[test]
    fn test_spacing_helpers() {
        let mut style = ComputedStyle::default();
        style.margin = EdgeOffsets::all(10.0);
        style.padding = EdgeOffsets::all(5.0);
        style.border_width = EdgeOffsets::all(2.0);

        assert_eq!(style.margin_horizontal(), 20.0);
        assert_eq!(style.padding_horizontal(), 10.0);
        assert_eq!(style.border_width_horizontal(), 4.0);
        assert_eq!(style.horizontal_spacing(), 34.0);
    }

    #[test]
    fn test_is_positioned() {
        let mut style = ComputedStyle::default();
        assert!(!style.is_positioned());

        style.position = Position::Relative;
        assert!(style.is_positioned());

        style.position = Position::Absolute;
        assert!(style.is_absolutely_positioned());
    }

    #[test]
    fn test_is_visible() {
        let mut style = ComputedStyle::default();
        assert!(style.is_visible());

        style.display = Display::None;
        assert!(!style.is_visible());

        style.display = Display::Block;
        style.visibility = Visibility::Hidden;
        assert!(!style.is_visible());
    }

    #[test]
    fn test_text_helpers() {
        let mut style = ComputedStyle::default();
        assert!(!style.is_bold());
        assert!(!style.is_italic());

        style.font_weight = 700;
        assert!(style.is_bold());

        style.font_style = FontStyle::Italic;
        assert!(style.is_italic());
    }

    #[test]
    fn test_computed_line_height() {
        let mut style = ComputedStyle::default();
        style.font_size = 20.0;

        // Normal
        style.line_height = LineHeight::Normal;
        assert_eq!(style.computed_line_height(), 24.0); // 20 * 1.2

        // Number
        style.line_height = LineHeight::Number(1.5);
        assert_eq!(style.computed_line_height(), 30.0); // 20 * 1.5

        // Length
        style.line_height = LineHeight::Length(25.0);
        assert_eq!(style.computed_line_height(), 25.0);
    }

    #[test]
    fn test_flex_helpers() {
        let mut style = ComputedStyle::default();
        assert!(!style.is_flex_container());

        style.display = Display::Flex;
        assert!(style.is_flex_container());

        assert!(style.is_flex_row());
        assert!(!style.is_flex_column());

        style.flex_direction = FlexDirection::Column;
        assert!(style.is_flex_column());
        assert!(!style.is_flex_row());
    }

    #[test]
    fn test_builder() {
        let style = ComputedStyle::builder()
            .display(Display::Block)
            .font_size(20.0)
            .color(Color::RED)
            .build();

        assert_eq!(style.display, Display::Block);
        assert_eq!(style.font_size, 20.0);
        assert_eq!(style.color, Color::RED);
    }

    #[test]
    fn test_creates_stacking_context() {
        let mut style = ComputedStyle::default();
        assert!(!style.creates_stacking_context());

        style.position = Position::Relative;
        style.z_index = Some(1);
        assert!(style.creates_stacking_context());

        style = ComputedStyle::default();
        style.opacity = 0.5;
        assert!(style.creates_stacking_context());
    }

    #[test]
    fn test_border_colors() {
        let colors = BorderColors::all(Color::RED);
        assert_eq!(colors.top, Color::RED);
        assert_eq!(colors.right, Color::RED);
        assert_eq!(colors.bottom, Color::RED);
        assert_eq!(colors.left, Color::RED);
    }
}
```

### Step 7: Documentation and Verification (Estimated: 30min)

**Commands:**

```bash
cargo test style::computed
cargo clippy -- -D warnings
cargo fmt
cargo doc --no-deps --open
```

## Testing Requirements

### Unit Tests

**Expected:** 15+ tests covering:
- Default values
- All helper methods
- Builder pattern
- Edge cases

## Output Artifacts

### Code Files

1. **`src/style/computed.rs`**
   - ComputedStyle struct (~50 properties)
   - Supporting enums and types
   - Helper methods
   - Builder pattern
   - Tests (~15 tests)
   - ~800-1000 lines total

### Notes File

Create: **`outputs/notes/W2.T05-notes.md`**

```markdown
# Task W2.T05 Output Notes

## Implementation Summary

Implemented ComputedStyle struct:
- **50+ CSS properties**: Organized into logical groups
- **Supporting types**: Position, Visibility, FontStyle, LineHeight, etc.
- **Helper methods**: 15+ methods for common queries
- **Builder pattern**: Easy test construction
- **Comprehensive tests**: 15+ tests covering all functionality

ComputedStyle is the central style representation.

## API Contracts

### Public Types

```rust
#[derive(Debug, Clone)]
pub struct ComputedStyle {
    // Box model (10 properties)
    pub width: LengthOrAuto,
    pub height: LengthOrAuto,
    pub margin: EdgeOffsets,
    pub padding: EdgeOffsets,
    pub border_width: EdgeOffsets,
    // ... 45+ more properties
}
```

### Key Methods

```rust
impl ComputedStyle {
    // Spacing
    pub fn horizontal_spacing(&self) -> f32;
    pub fn vertical_spacing(&self) -> f32;

    // Positioning
    pub fn is_positioned(&self) -> bool;
    pub fn is_absolutely_positioned(&self) -> bool;

    // Display
    pub fn is_visible(&self) -> bool;

    // Text
    pub fn is_bold(&self) -> bool;
    pub fn computed_line_height(&self) -> f32;

    // Flexbox
    pub fn is_flex_container(&self) -> bool;
}
```

## Decisions Made

### Decision 1: Single Large Struct

**Choice:** All properties in one struct
**Rationale:**
- Fast access (no indirection)
- Type-safe (no HashMap)
- Clear API
- Good cache locality
- Size acceptable (~200-400 bytes)

**Alternatives Considered:** HashMap, trait objects → rejected for performance

### Decision 2: Arc<ComputedStyle> Sharing

**Choice:** Wrap in Arc for sharing
**Rationale:**
- BoxNode and fragments share same style
- Immutable after creation
- Cheap to clone Arc
- Reduces memory usage

**Impact:** Clone = clone Arc pointer, not full struct

### Decision 3: Computed vs Used Values

**Choice:** Store computed values, not used
**Rationale:**
- Percentages kept (resolved during layout)
- Matches CSS spec stage
- Allows percentage resolution with different bases
- em/rem already resolved to px

**Example:** `width: 50%` stored as `Length::percent(50.0)`, not resolved

## Spec Interpretations

### Initial Values

**Spec says:** Each property has an initial value
**Interpretation:** Default::default() returns initial values
**Reasoning:** Matches CSS spec exactly
**Test coverage:** test_default_values checks all

## Discoveries & Gotchas

### Discovery 1: Struct Size Matters

**What:** ComputedStyle is ~200-400 bytes
**Why it matters:** Affects cache performance
**Recommendation:** Profile and consider splitting if too large
**Current:** Size is acceptable for Arc sharing

### Gotcha 1: Percentage Resolution

**Problem:** When to resolve percentages?
**Solution:** Keep in ComputedStyle, resolve during layout
**Warning:** Different properties use different percentage bases

### Gotcha 2: Line Height Normal

**Problem:** "normal" has no fixed value
**Solution:** Treat as 1.2 multiplier (common browser default)
**Warning:** Real value is font-dependent

## Performance Notes

### Performance Characteristics
- Struct access is O(1)
- Arc clone is cheap
- Default creation allocates vec for font_family
- Size: ~200-400 bytes

### Optimization Opportunities
- Consider bitflags for boolean-ish properties
- Could split into hot/cold sections
- Font family could use Arc<Vec<String>>

## Recommendations for Downstream Tasks

### For Task W2.T01 (BoxNode):
- Store as `Arc<ComputedStyle>`
- Clone Arc when creating fragments
- Access via `box.style.property_name`

### For Task W3.T04 (Block Layout):
- Use `width`, `height` for sizing
- Use `margin`, `padding`, `border_width` for box model
- Call `horizontal_spacing()` for quick totals
- Resolve percentages against containing block

### For Task W4.T12 (Inline Layout):
- Use `font_size`, `font_family` for text shaping
- Use `computed_line_height()` for line box height
- Use `text_align` for line justification

### For Task W5.T01 (Paint):
- Use `color` for text
- Use `background_color` for backgrounds
- Use `border_color` and `border_width` for borders
- Check `is_visible()` before painting

## Open Questions

### Question 1: Should we add more properties?

**Question:** 50 properties enough for v1?
**Context:** CSS has 300+ properties
**Suggested resolution:** Add as needed, but 50 is good start
**Priority:** Medium - can add incrementally

## Test Coverage

### What's Tested
- ✅ Default values
- ✅ All helper methods
- ✅ Builder pattern
- ✅ Edge cases

### Test Statistics
- Unit tests: 15 tests
- All tests pass: ✅

## Code Quality
- ✅ Clippy passes
- ✅ Rustfmt applied
- ✅ Full documentation
- ✅ All properties documented

## References Used
1. CSS Cascading and Inheritance Level 3
2. CSS Values and Units Module Level 3
3. W1.T03-T06 notes (value types)

---

**Task completed:** [DATE]
**Time taken:** 7 hours
**Tests passing:** 15/15
```

## Common Pitfalls to Avoid

### Pitfall 1: Resolving Too Early

**Wrong:** Storing used values instead of computed
**Right:** Keep percentages, resolve during layout

### Pitfall 2: Forgetting Arc

**Wrong:** Cloning ComputedStyle directly
**Right:** Always wrap in Arc, clone Arc

### Pitfall 3: Using Wrong Defaults

**Wrong:** Using 0 for everything
**Right:** Use CSS initial values from spec

## Verification Checklist

- [ ] All objectives met
- [ ] 50+ properties implemented
- [ ] Default with correct initial values
- [ ] Helper methods working
- [ ] Builder pattern implemented
- [ ] Tests pass: `cargo test style::computed`
- [ ] Clippy clean
- [ ] Documentation complete
- [ ] Notes file created

## Time Tracking

- **Planning:** 30min
- **Struct definition:** 2hrs
- **Default implementation:** 1hr
- **Helper methods:** 2hrs
- **Builder pattern:** 1hr
- **Testing:** 1hr
- **Documentation:** 30min
- **Total:** 6-8 hours

## Getting Help

If stuck:
1. **CSS specifications**: For initial values
2. **W1.T03-T06 notes**: For value types
3. **Browser DevTools**: Inspect computed styles
