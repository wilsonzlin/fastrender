---
task_id: "W2.T10"
title: "Implement LayoutEngine Orchestration Structure"
wave: 2
estimated_hours: 4-6
depends_on:
  - "W2.T07"
  - "W2.T09"
inputs:
  - "outputs/notes/W2.T07-notes.md"
  - "outputs/notes/W2.T09-notes.md"
  - "src/layout/formatting_context.rs"
  - "src/layout/contexts/factory.rs"
outputs:
  - "src/layout/engine.rs"
  - "outputs/notes/W2.T10-notes.md"
skills_required:
  - "Rust"
  - "Tree algorithms"
  - "Error handling"
  - "Caching strategies"
context_files:
  - "docs/plan/01-layout-engine.md"
  - "outputs/notes/W2.T07-notes.md"
  - "outputs/notes/W2.T09-notes.md"
verification:
  - "cargo test layout::engine"
  - "cargo clippy -- -D warnings"
---

# Implement LayoutEngine Orchestration Structure

## Context

The **LayoutEngine** is the conductor of the entire layout process. It's the single entry point that takes a BoxTree and produces a FragmentTree. Everything flows through the engine.

This is the **orchestration layer** that sits above formatting contexts and below the public API. It's responsible for:
- Managing the layout lifecycle
- Dispatching to appropriate formatting contexts
- Handling errors and edge cases
- Future: caching and incremental layout
- Future: parallel layout of independent subtrees

### Background

**What Does the LayoutEngine Do?**

The layout engine implements the high-level layout algorithm:

```
1. Start with BoxTree root
2. Determine root's formatting context type
3. Create appropriate FormattingContext via factory
4. Call FC's layout() method with constraints
5. FC recursively layouts children (steps 2-4 for each child)
6. Return complete FragmentTree
```

**Why Separate Engine from FormattingContexts?**

The engine and FCs have different responsibilities:

- **LayoutEngine** (this task):
  - High-level orchestration
  - FC creation and dispatch
  - Error handling and recovery
  - Caching (future)
  - Public API

- **FormattingContexts** (Wave 3):
  - Algorithm-specific layout logic
  - Box sizing and positioning
  - Child layout recursion
  - Margin collapsing, line breaking, etc.

This separation allows:
- FCs to focus purely on layout algorithms
- Engine to handle cross-cutting concerns
- Easy addition of new features (caching, parallelization)
- Clean testing boundaries

**Current Scope (Wave 2)**

In Wave 2, the engine works with stub FCs. It provides:
- Complete public API
- Error handling infrastructure
- Extensibility points for future features
- Comprehensive tests with stubs

Real layout will work when stub FCs are replaced in Wave 3.

### Why This Matters

The LayoutEngine is consumed by:
- **Public API**: Application code calls `engine.layout(box_tree)`
- **W3.T04**: BlockFormattingContext calls engine for child layout
- **W4.T12**: InlineFormattingContext calls engine for atomic inlines
- **Future**: Incremental layout, parallel layout, dev tools

Without the engine:
- No single entry point for layout
- Every FC must manage its own lifecycle
- Can't add cross-cutting features like caching
- Can't provide clean public API

The engine is the foundation of the layout system's architecture.

## Prerequisites

### Required Knowledge
- **Tree traversal**: Recursive tree algorithms
- **Error propagation**: Result types and error handling
- **Rust lifetimes**: Managing references in recursive code
- **Caching strategies**: LRU, invalidation (for future)

### Required Reading
1. **outputs/notes/W2.T07-notes.md**: FormattingContext trait API
2. **outputs/notes/W2.T09-notes.md**: FormattingContextFactory API
3. **CSS 2.1 Section 9**: Visual formatting model
4. **docs/plan/01-layout-engine.md**: Engine architecture

## Inputs

### From Dependencies

1. **W2.T07-notes.md** (FormattingContext trait)
   - Look for: layout() method signature
   - Look for: LayoutConstraints structure
   - Key insight: What FCs expect as input

2. **W2.T09-notes.md** (FormattingContextFactory)
   - Look for: create_for_box() method
   - Look for: Error handling for unsupported boxes
   - Key insight: How to create FCs dynamically

### Existing Code

Read:
- `src/layout/formatting_context.rs` - FormattingContext trait
- `src/layout/contexts/factory.rs` - FormattingContextFactory
- `src/tree/box_tree.rs` - BoxNode and BoxTree
- `src/tree/fragment.rs` - Fragment and FragmentTree

## Objectives

### Primary Goals

1. **Define LayoutEngine struct**: Main layout orchestrator
2. **Implement layout_tree()**: Layout entire tree from root
3. **Implement layout_subtree()**: Layout subtree with constraints
4. **Integrate with factory**: Create FCs dynamically
5. **Error handling**: Proper error propagation and reporting
6. **Extensibility points**: Prepare for caching, parallelization
7. **Comprehensive tests**: Test with stub FCs
8. **Documentation**: Explain lifecycle and usage

### Success Criteria

- [ ] LayoutEngine struct complete
- [ ] layout_tree() method works end-to-end
- [ ] layout_subtree() handles partial layout
- [ ] Integration with FormattingContextFactory
- [ ] Proper error handling throughout
- [ ] LayoutConfig for future extensibility
- [ ] Placeholder for cache (future optimization)
- [ ] 20+ comprehensive tests with stubs
- [ ] All tests pass
- [ ] Clippy clean
- [ ] Notes file comprehensive

## Implementation Guide

### Step 1: Create Engine Module (Estimated: 15min)

**Create `src/layout/engine.rs`:**

```rust
//! Layout engine - orchestrates the layout process
//!
//! The LayoutEngine is the main entry point for performing layout.
//! It takes a BoxTree and produces a FragmentTree.

use crate::tree::{BoxTree, BoxNode, Fragment};
use crate::layout::formatting_context::{FormattingContext, LayoutError};
use crate::layout::constraints::{LayoutConstraints, AvailableSpace};
use crate::layout::contexts::FormattingContextFactory;
use crate::geometry::Size;

/// Configuration for the layout engine
///
/// This struct contains settings that affect how layout is performed.
/// Future additions might include:
/// - Cache size limits
/// - Parallelization settings
/// - Debug/profiling flags
/// - Feature flags (e.g., enable experimental features)
#[derive(Debug, Clone)]
pub struct LayoutConfig {
    /// Initial containing block size
    ///
    /// This is typically the viewport size. It's used as the
    /// percentage base for the root element.
    pub initial_containing_block: Size,

    /// Whether to enable layout caching (future)
    ///
    /// When true, the engine will cache layout results for subtrees
    /// that haven't changed.
    pub enable_cache: bool,

    /// Whether to enable parallel layout (future)
    ///
    /// When true, independent subtrees may be laid out in parallel.
    pub enable_parallel: bool,
}

impl LayoutConfig {
    /// Creates a default configuration
    ///
    /// - Initial containing block: 800x600 (common default)
    /// - Cache: disabled (not implemented yet)
    /// - Parallel: disabled (not implemented yet)
    pub fn new(initial_containing_block: Size) -> Self {
        Self {
            initial_containing_block,
            enable_cache: false,
            enable_parallel: false,
        }
    }

    /// Creates a default configuration for a viewport size
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::layout::engine::LayoutConfig;
    /// use fastrender::geometry::Size;
    ///
    /// let config = LayoutConfig::for_viewport(Size::new(1920.0, 1080.0));
    /// assert_eq!(config.initial_containing_block.width, 1920.0);
    /// ```
    pub fn for_viewport(viewport_size: Size) -> Self {
        Self::new(viewport_size)
    }
}

impl Default for LayoutConfig {
    fn default() -> Self {
        Self::new(Size::new(800.0, 600.0))
    }
}
```

**Update `src/layout/mod.rs`:**
```rust
pub mod formatting_context;
pub mod constraints;
pub mod contexts;
pub mod engine;

pub use formatting_context::{FormattingContext, IntrinsicSizingMode, LayoutError};
pub use constraints::{LayoutConstraints, AvailableSpace};
pub use contexts::{FormattingContextType, FormattingContextFactory};
pub use engine::{LayoutEngine, LayoutConfig};
```

### Step 2: Implement LayoutEngine Struct (Estimated: 2 hours)

**Add to `src/layout/engine.rs`:**

```rust
/// The layout engine
///
/// Orchestrates the layout process, managing the transformation from
/// BoxTree to FragmentTree.
///
/// # Architecture
///
/// The layout engine:
/// 1. Takes a BoxTree as input
/// 2. Uses FormattingContextFactory to create appropriate FCs
/// 3. Calls FC layout() methods recursively
/// 4. Returns a FragmentTree as output
///
/// # Current Implementation
///
/// In Wave 2, the engine works with stub FC implementations. When real
/// FCs are implemented in Wave 3, the engine doesn't need to change.
///
/// # Future Features
///
/// - **Caching**: Cache layout results for unchanged subtrees
/// - **Incremental layout**: Re-layout only changed portions
/// - **Parallel layout**: Layout independent subtrees in parallel
/// - **Layout observers**: Callbacks for layout events
///
/// # Examples
///
/// ```
/// use std::sync::Arc;
/// use fastrender::layout::engine::{LayoutEngine, LayoutConfig};
/// use fastrender::tree::{BoxTree, BoxNode, FormattingContextType};
/// use fastrender::geometry::Size;
/// # use fastrender::tree::box_tree::ComputedStyle;
///
/// let config = LayoutConfig::for_viewport(Size::new(800.0, 600.0));
/// let engine = LayoutEngine::new(config);
///
/// let style = Arc::new(ComputedStyle::default());
/// let root = BoxNode::new_block(
///     style,
///     FormattingContextType::BlockFormatting,
///     vec![],
/// );
/// let box_tree = BoxTree::new(root);
///
/// let fragment_tree = engine.layout_tree(&box_tree).unwrap();
/// ```
pub struct LayoutEngine {
    /// Configuration
    config: LayoutConfig,

    /// FormattingContext factory
    factory: FormattingContextFactory,

    /// Layout cache (future)
    ///
    /// Maps box identity to cached fragments. Not implemented yet.
    /// Will be added when incremental layout is implemented.
    _cache: LayoutCache,
}

/// Placeholder for layout cache
///
/// Future implementation will cache layout results keyed by:
/// - Box identity (pointer or ID)
/// - Constraints used for layout
/// - Style snapshot (for invalidation)
#[derive(Debug)]
struct LayoutCache {
    // Future: HashMap<BoxId, CachedFragment>
    _placeholder: (),
}

impl LayoutCache {
    fn new() -> Self {
        Self {
            _placeholder: (),
        }
    }
}

impl LayoutEngine {
    /// Creates a new layout engine with the given configuration
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::layout::engine::{LayoutEngine, LayoutConfig};
    ///
    /// let config = LayoutConfig::default();
    /// let engine = LayoutEngine::new(config);
    /// ```
    pub fn new(config: LayoutConfig) -> Self {
        Self {
            config,
            factory: FormattingContextFactory::new(),
            _cache: LayoutCache::new(),
        }
    }

    /// Creates a layout engine with default configuration
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::layout::engine::LayoutEngine;
    ///
    /// let engine = LayoutEngine::with_defaults();
    /// ```
    pub fn with_defaults() -> Self {
        Self::new(LayoutConfig::default())
    }

    /// Lays out an entire box tree
    ///
    /// This is the main entry point for layout. It layouts the root box
    /// within the initial containing block and returns a complete fragment tree.
    ///
    /// # Arguments
    ///
    /// * `box_tree` - The box tree to layout
    ///
    /// # Returns
    ///
    /// A fragment tree with all boxes positioned, or an error if layout fails.
    ///
    /// # Errors
    ///
    /// Returns `LayoutError` if:
    /// - Root box doesn't establish a formatting context
    /// - Layout algorithm encounters an error (circular dependency, etc.)
    /// - Box type is not supported
    ///
    /// # Examples
    ///
    /// ```
    /// use std::sync::Arc;
    /// use fastrender::layout::engine::LayoutEngine;
    /// use fastrender::tree::{BoxTree, BoxNode, FormattingContextType};
    /// # use fastrender::tree::box_tree::ComputedStyle;
    ///
    /// let engine = LayoutEngine::with_defaults();
    /// let style = Arc::new(ComputedStyle::default());
    /// let root = BoxNode::new_block(
    ///     style,
    ///     FormattingContextType::BlockFormatting,
    ///     vec![],
    /// );
    /// let box_tree = BoxTree::new(root);
    ///
    /// let fragment_tree = engine.layout_tree(&box_tree).unwrap();
    /// ```
    pub fn layout_tree(&self, box_tree: &BoxTree) -> Result<Fragment, LayoutError> {
        // Create constraints for root (initial containing block)
        let constraints = LayoutConstraints {
            available_width: AvailableSpace::Definite(
                self.config.initial_containing_block.width
            ),
            available_height: AvailableSpace::Definite(
                self.config.initial_containing_block.height
            ),
            percentage_base_width: self.config.initial_containing_block.width,
            percentage_base_height: self.config.initial_containing_block.height,
        };

        // Layout root box
        self.layout_subtree(&box_tree.root, &constraints)
    }

    /// Lays out a subtree with given constraints
    ///
    /// This is used for:
    /// - Laying out the root (called by layout_tree)
    /// - Recursive child layout (called by FormattingContext implementations)
    /// - Re-laying out changed subtrees (incremental layout, future)
    ///
    /// # Arguments
    ///
    /// * `box_node` - The root of the subtree to layout
    /// * `constraints` - Available space and percentage bases
    ///
    /// # Returns
    ///
    /// A positioned fragment tree for the subtree
    ///
    /// # Errors
    ///
    /// Returns `LayoutError` if layout fails
    ///
    /// # Examples
    ///
    /// ```
    /// use std::sync::Arc;
    /// use fastrender::layout::engine::LayoutEngine;
    /// use fastrender::layout::constraints::LayoutConstraints;
    /// use fastrender::tree::{BoxNode, FormattingContextType};
    /// # use fastrender::tree::box_tree::ComputedStyle;
    ///
    /// let engine = LayoutEngine::with_defaults();
    /// let style = Arc::new(ComputedStyle::default());
    /// let box_node = BoxNode::new_block(
    ///     style,
    ///     FormattingContextType::BlockFormatting,
    ///     vec![],
    /// );
    ///
    /// let constraints = LayoutConstraints::with_definite_size(800.0, 600.0);
    /// let fragment = engine.layout_subtree(&box_node, &constraints).unwrap();
    /// ```
    pub fn layout_subtree(
        &self,
        box_node: &BoxNode,
        constraints: &LayoutConstraints,
    ) -> Result<Fragment, LayoutError> {
        // Future: Check cache first
        // if let Some(cached) = self.check_cache(box_node, constraints) {
        //     return Ok(cached);
        // }

        // Create appropriate formatting context
        let fc = self.factory.create_for_box(box_node)?;

        // Perform layout
        let fragment = fc.layout(box_node, constraints)?;

        // Future: Store in cache
        // self.store_in_cache(box_node, constraints, &fragment);

        Ok(fragment)
    }

    /// Computes intrinsic size for a box
    ///
    /// This is used when a parent needs to know a child's content-based size
    /// before performing layout (e.g., shrink-to-fit, auto sizing).
    ///
    /// # Arguments
    ///
    /// * `box_node` - The box to measure
    /// * `mode` - MinContent or MaxContent
    ///
    /// # Returns
    ///
    /// The intrinsic inline size (width for horizontal writing mode)
    ///
    /// # Errors
    ///
    /// Returns `LayoutError` if measurement fails
    ///
    /// # Examples
    ///
    /// ```
    /// use std::sync::Arc;
    /// use fastrender::layout::engine::LayoutEngine;
    /// use fastrender::layout::IntrinsicSizingMode;
    /// use fastrender::tree::{BoxNode, FormattingContextType};
    /// # use fastrender::tree::box_tree::ComputedStyle;
    ///
    /// let engine = LayoutEngine::with_defaults();
    /// let style = Arc::new(ComputedStyle::default());
    /// let box_node = BoxNode::new_block(
    ///     style,
    ///     FormattingContextType::BlockFormatting,
    ///     vec![],
    /// );
    ///
    /// let size = engine.compute_intrinsic_size(
    ///     &box_node,
    ///     IntrinsicSizingMode::MinContent,
    /// ).unwrap();
    /// ```
    pub fn compute_intrinsic_size(
        &self,
        box_node: &BoxNode,
        mode: crate::layout::formatting_context::IntrinsicSizingMode,
    ) -> Result<f32, LayoutError> {
        let fc = self.factory.create_for_box(box_node)?;
        fc.compute_intrinsic_inline_size(box_node, mode)
    }

    /// Returns a reference to the configuration
    pub fn config(&self) -> &LayoutConfig {
        &self.config
    }

    /// Returns statistics about the layout engine (future)
    ///
    /// When caching is implemented, this will return:
    /// - Cache hit rate
    /// - Number of cached fragments
    /// - Memory used by cache
    pub fn stats(&self) -> LayoutStats {
        LayoutStats {
            cache_hits: 0,
            cache_misses: 0,
            total_layouts: 0,
        }
    }
}

impl Default for LayoutEngine {
    fn default() -> Self {
        Self::with_defaults()
    }
}

/// Statistics about layout operations (future)
#[derive(Debug, Clone, Copy, Default)]
pub struct LayoutStats {
    /// Number of cache hits (future)
    pub cache_hits: usize,

    /// Number of cache misses (future)
    pub cache_misses: usize,

    /// Total number of layout operations performed
    pub total_layouts: usize,
}
```

### Step 3: Write Comprehensive Tests (Estimated: 1.5 hours)

**Add at bottom of file:**

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use crate::tree::{BoxNode, BoxTree, FormattingContextType};
    use crate::geometry::Size;
    use std::sync::Arc;

    fn default_style() -> Arc<crate::tree::box_tree::ComputedStyle> {
        Arc::new(crate::tree::box_tree::ComputedStyle::default())
    }

    #[test]
    fn test_layout_config_creation() {
        let config = LayoutConfig::new(Size::new(1024.0, 768.0));
        assert_eq!(config.initial_containing_block.width, 1024.0);
        assert_eq!(config.initial_containing_block.height, 768.0);
        assert!(!config.enable_cache);
        assert!(!config.enable_parallel);
    }

    #[test]
    fn test_layout_config_default() {
        let config = LayoutConfig::default();
        assert_eq!(config.initial_containing_block.width, 800.0);
        assert_eq!(config.initial_containing_block.height, 600.0);
    }

    #[test]
    fn test_layout_config_for_viewport() {
        let config = LayoutConfig::for_viewport(Size::new(1920.0, 1080.0));
        assert_eq!(config.initial_containing_block.width, 1920.0);
    }

    #[test]
    fn test_engine_creation() {
        let config = LayoutConfig::default();
        let engine = LayoutEngine::new(config);
        assert_eq!(engine.config().initial_containing_block.width, 800.0);
    }

    #[test]
    fn test_engine_with_defaults() {
        let engine = LayoutEngine::with_defaults();
        assert_eq!(engine.config().initial_containing_block.width, 800.0);
    }

    #[test]
    fn test_engine_default() {
        let engine = LayoutEngine::default();
        assert_eq!(engine.config().initial_containing_block.width, 800.0);
    }

    #[test]
    fn test_layout_single_block() {
        let engine = LayoutEngine::with_defaults();
        let root = BoxNode::new_block(
            default_style(),
            FormattingContextType::BlockFormatting,
            vec![],
        );
        let box_tree = BoxTree::new(root);

        let fragment = engine.layout_tree(&box_tree).unwrap();

        // Stub returns 800x600 (from config)
        assert_eq!(fragment.bounds().size().width, 800.0);
        assert_eq!(fragment.bounds().size().height, 600.0);
    }

    #[test]
    fn test_layout_block_with_children() {
        let engine = LayoutEngine::with_defaults();

        let child1 = BoxNode::new_block(
            default_style(),
            FormattingContextType::BlockFormatting,
            vec![],
        );
        let child2 = BoxNode::new_block(
            default_style(),
            FormattingContextType::BlockFormatting,
            vec![],
        );

        let root = BoxNode::new_block(
            default_style(),
            FormattingContextType::BlockFormatting,
            vec![child1, child2],
        );
        let box_tree = BoxTree::new(root);

        let fragment = engine.layout_tree(&box_tree).unwrap();
        assert!(fragment.bounds().size().width > 0.0);
    }

    #[test]
    fn test_layout_flex_container() {
        let engine = LayoutEngine::with_defaults();
        let root = BoxNode::new_block(
            default_style(),
            FormattingContextType::FlexFormatting,
            vec![],
        );
        let box_tree = BoxTree::new(root);

        let fragment = engine.layout_tree(&box_tree).unwrap();
        // Stub flex returns 800x600
        assert_eq!(fragment.bounds().size().width, 800.0);
    }

    #[test]
    fn test_layout_grid_container() {
        let engine = LayoutEngine::with_defaults();
        let root = BoxNode::new_block(
            default_style(),
            FormattingContextType::GridFormatting,
            vec![],
        );
        let box_tree = BoxTree::new(root);

        let fragment = engine.layout_tree(&box_tree).unwrap();
        assert_eq!(fragment.bounds().size().width, 800.0);
    }

    #[test]
    fn test_layout_table() {
        let engine = LayoutEngine::with_defaults();
        let root = BoxNode::new_block(
            default_style(),
            FormattingContextType::TableFormatting,
            vec![],
        );
        let box_tree = BoxTree::new(root);

        let fragment = engine.layout_tree(&box_tree).unwrap();
        assert_eq!(fragment.bounds().size().width, 800.0);
    }

    #[test]
    fn test_layout_inline_box_fails() {
        let engine = LayoutEngine::with_defaults();
        // Regular inline doesn't establish FC
        let root = BoxNode::new_inline(default_style(), vec![]);
        let box_tree = BoxTree::new(root);

        let result = engine.layout_tree(&box_tree);
        assert!(result.is_err());
    }

    #[test]
    fn test_layout_subtree() {
        let engine = LayoutEngine::with_defaults();
        let box_node = BoxNode::new_block(
            default_style(),
            FormattingContextType::BlockFormatting,
            vec![],
        );

        let constraints = LayoutConstraints::with_definite_size(400.0, 300.0);
        let fragment = engine.layout_subtree(&box_node, &constraints).unwrap();

        assert_eq!(fragment.bounds().size().width, 400.0);
        assert_eq!(fragment.bounds().size().height, 300.0);
    }

    #[test]
    fn test_layout_subtree_with_indefinite_size() {
        let engine = LayoutEngine::with_defaults();
        let box_node = BoxNode::new_block(
            default_style(),
            FormattingContextType::BlockFormatting,
            vec![],
        );

        let constraints = LayoutConstraints::new(
            AvailableSpace::MaxContent,
            AvailableSpace::MaxContent,
        );
        let fragment = engine.layout_subtree(&box_node, &constraints).unwrap();

        // Stub falls back to 100x50 for indefinite
        assert_eq!(fragment.bounds().size().width, 100.0);
    }

    #[test]
    fn test_compute_intrinsic_size_min_content() {
        let engine = LayoutEngine::with_defaults();
        let box_node = BoxNode::new_block(
            default_style(),
            FormattingContextType::BlockFormatting,
            vec![],
        );

        let size = engine.compute_intrinsic_size(
            &box_node,
            crate::layout::formatting_context::IntrinsicSizingMode::MinContent,
        ).unwrap();

        // Stub returns 100.0
        assert_eq!(size, 100.0);
    }

    #[test]
    fn test_compute_intrinsic_size_max_content() {
        let engine = LayoutEngine::with_defaults();
        let box_node = BoxNode::new_block(
            default_style(),
            FormattingContextType::BlockFormatting,
            vec![],
        );

        let size = engine.compute_intrinsic_size(
            &box_node,
            crate::layout::formatting_context::IntrinsicSizingMode::MaxContent,
        ).unwrap();

        assert_eq!(size, 100.0);
    }

    #[test]
    fn test_custom_viewport_size() {
        let config = LayoutConfig::for_viewport(Size::new(1920.0, 1080.0));
        let engine = LayoutEngine::new(config);

        let root = BoxNode::new_block(
            default_style(),
            FormattingContextType::BlockFormatting,
            vec![],
        );
        let box_tree = BoxTree::new(root);

        let fragment = engine.layout_tree(&box_tree).unwrap();
        // Stub uses constraints, which come from viewport
        assert_eq!(fragment.bounds().size().width, 1920.0);
        assert_eq!(fragment.bounds().size().height, 1080.0);
    }

    #[test]
    fn test_engine_stats() {
        let engine = LayoutEngine::with_defaults();
        let stats = engine.stats();

        // Currently all zeros (cache not implemented)
        assert_eq!(stats.cache_hits, 0);
        assert_eq!(stats.cache_misses, 0);
        assert_eq!(stats.total_layouts, 0);
    }

    #[test]
    fn test_multiple_layouts_independent() {
        let engine = LayoutEngine::with_defaults();

        // Layout two different trees
        let root1 = BoxNode::new_block(
            default_style(),
            FormattingContextType::BlockFormatting,
            vec![],
        );
        let tree1 = BoxTree::new(root1);

        let root2 = BoxNode::new_block(
            default_style(),
            FormattingContextType::FlexFormatting,
            vec![],
        );
        let tree2 = BoxTree::new(root2);

        let frag1 = engine.layout_tree(&tree1).unwrap();
        let frag2 = engine.layout_tree(&tree2).unwrap();

        // Both should succeed
        assert!(frag1.bounds().size().width > 0.0);
        assert!(frag2.bounds().size().width > 0.0);
    }

    #[test]
    fn test_nested_formatting_contexts() {
        let engine = LayoutEngine::with_defaults();

        // Create nested structure: Block → Flex → Block
        let inner_block = BoxNode::new_block(
            default_style(),
            FormattingContextType::BlockFormatting,
            vec![],
        );

        let flex_container = BoxNode::new_block(
            default_style(),
            FormattingContextType::FlexFormatting,
            vec![inner_block],
        );

        let root = BoxNode::new_block(
            default_style(),
            FormattingContextType::BlockFormatting,
            vec![flex_container],
        );

        let box_tree = BoxTree::new(root);
        let fragment = engine.layout_tree(&box_tree).unwrap();

        // Stub implementation should handle nesting
        assert!(fragment.bounds().size().width > 0.0);
    }

    #[test]
    fn test_engine_reuse() {
        let engine = LayoutEngine::with_defaults();

        // Reuse same engine for multiple layouts
        for _ in 0..10 {
            let root = BoxNode::new_block(
                default_style(),
                FormattingContextType::BlockFormatting,
                vec![],
            );
            let box_tree = BoxTree::new(root);
            let result = engine.layout_tree(&box_tree);
            assert!(result.is_ok());
        }
    }

    #[test]
    fn test_layout_with_text_box() {
        let engine = LayoutEngine::with_defaults();

        let text = BoxNode::new_text(default_style(), "Hello".to_string());

        // Text boxes can't be laid out directly (they're inline-level)
        // They must be inside a block container that establishes IFC
        let constraints = LayoutConstraints::with_definite_size(800.0, 600.0);
        let result = engine.layout_subtree(&text, &constraints);

        // Should fail - text boxes don't establish FC
        assert!(result.is_err());
    }
}
```

### Step 4: Documentation and Verification (Estimated: 30min)

Run verification:
```bash
cargo test layout::engine
cargo clippy -- -D warnings
cargo fmt
cargo doc --no-deps --open
```

## Testing Requirements

Run: `cargo test layout::engine`

Expected: 20+ tests passing covering:
- Config creation and defaults
- Engine creation
- Layout of single boxes (all FC types)
- Layout of trees with children
- Layout subtrees with custom constraints
- Intrinsic size computation
- Error handling for unsupported boxes
- Custom viewport sizes
- Multiple independent layouts
- Nested formatting contexts
- Engine reuse

## Output Artifacts

### Code Files

1. **`src/layout/engine.rs`** (~600-700 lines)
   - LayoutConfig struct
   - LayoutEngine struct
   - layout_tree() and layout_subtree() methods
   - LayoutStats (placeholder)
   - LayoutCache (placeholder)
   - Comprehensive tests

### Notes File

Create: **`outputs/notes/W2.T10-notes.md`**

**Key sections:**
- **API Contracts**: Engine methods and guarantees
- **Decision: Why separate tree/subtree methods**: Rationale
- **Decision: Config struct**: Extensibility for future features
- **Decision: Cache placeholder**: Why not implement now
- **Recommendations**: How to use in applications
- **Integration**: How FCs recursively call back to engine
- **Future**: Incremental layout, parallel layout, caching

## Common Pitfalls to Avoid

### Pitfall 1: Not Propagating Constraints Correctly

**Wrong:**
```rust
// Always using engine's initial containing block
fc.layout(box_node, &self.config.initial_containing_block)
```

**Right:**
```rust
// Using provided constraints (for recursive layout)
fc.layout(box_node, constraints)
```

### Pitfall 2: Caching Too Early

**Wrong:** Implementing complex caching in Wave 2
**Right:** Add placeholders, implement caching later when needed

### Pitfall 3: Tight Coupling to FC Implementations

**Wrong:** Engine knows about specific FC types
**Right:** Engine only knows about FormattingContext trait

## Verification Checklist

- [ ] LayoutEngine struct complete
- [ ] layout_tree() works end-to-end
- [ ] layout_subtree() handles constraints correctly
- [ ] Integration with factory works
- [ ] Error handling throughout
- [ ] LayoutConfig for extensibility
- [ ] Placeholders for future features
- [ ] 20+ tests all passing
- [ ] Clippy clean
- [ ] Documentation complete
- [ ] Notes file comprehensive

## Time Tracking

- **Module setup:** 15min
- **Config and structs:** 30min
- **Engine implementation:** 2hrs
- **Tests:** 1.5hrs
- **Documentation:** 30min
- **Total:** 4-6 hours

## Getting Help

- Review `outputs/notes/W2.T07-notes.md` for FormattingContext trait
- Check `outputs/notes/W2.T09-notes.md` for Factory usage
- See CSS 2.1 Section 9 for layout model
- Rust Book Chapter 13 for error handling patterns

Remember: The engine orchestrates, FCs implement. Keep them separate!
