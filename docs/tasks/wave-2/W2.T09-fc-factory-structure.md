---
task_id: "W2.T09"
title: "Implement FormattingContext Factory Structure"
wave: 2
estimated_hours: 3-4
depends_on:
  - "W2.T07"
  - "W2.T08"
inputs:
  - "outputs/notes/W2.T07-notes.md"
  - "outputs/notes/W2.T08-notes.md"
  - "src/layout/formatting_context.rs"
  - "src/layout/contexts/types.rs"
outputs:
  - "src/layout/contexts/factory.rs"
  - "outputs/notes/W2.T09-notes.md"
skills_required:
  - "Rust"
  - "Factory pattern"
  - "Trait objects"
  - "Smart pointers"
context_files:
  - "docs/plan/01-formatting-contexts.md"
  - "outputs/notes/W2.T07-notes.md"
  - "outputs/notes/W2.T08-notes.md"
verification:
  - "cargo test layout::contexts::factory"
  - "cargo clippy -- -D warnings"
---

# Implement FormattingContext Factory Structure

## Context

The FormattingContext Factory is the **creation hub** for all layout algorithms in FastRender V2. It's responsible for looking at a box's properties and instantiating the correct FormattingContext implementation.

This is the **dependency injection** point of the layout system. The factory pattern allows us to:
- Keep layout algorithms modular and independent
- Add new FCs without modifying the core engine
- Use stub implementations during development
- Swap implementations for testing

### Background

**The Factory Pattern**

The factory pattern separates object creation from object use. Instead of:
```rust
// Bad: LayoutEngine knows about all FC implementations
let fc = match box_type {
    BlockBox => BlockFormattingContext::new(),
    FlexBox => FlexFormattingContext::new(),
    // Tight coupling!
}
```

We use:
```rust
// Good: LayoutEngine delegates to factory
let fc = factory.create_for_box(&box_node)?;
// Factory handles all creation logic
```

**Why Use Trait Objects?**

The factory returns `Box<dyn FormattingContext>` because:
- Different FCs have different internal state
- We need runtime polymorphism (can't know FC type at compile time)
- The LayoutEngine treats all FCs uniformly

**Stub Implementations**

In Wave 2, we don't have real FC implementations yet (they come in Wave 3).
So we create **stub implementations** that:
- Implement the FormattingContext trait
- Return dummy fragments for now
- Allow testing the factory and engine
- Will be replaced with real implementations in Wave 3

### Why This Matters

The FormattingContext Factory is consumed by:
- **W2.T10**: LayoutEngine (uses factory to create FCs)
- **W3.T04**: BlockFormattingContext (registered in factory)
- **W4.T12**: InlineFormattingContext (registered in factory)
- **W3.T08**: FlexFormattingContext (registered in factory)

Without the factory:
- Can't create formatting contexts dynamically
- LayoutEngine must know about all FC implementations
- Adding new FCs requires modifying multiple files
- Can't test layout system before all FCs are implemented

The factory is the bridge between box generation and layout.

## Prerequisites

### Required Knowledge
- **Factory pattern**: Creation patterns in OOP
- **Rust trait objects**: Box<dyn Trait>
- **Smart pointers**: Box, Arc, Rc
- **Pattern matching**: Exhaustive matching in Rust

### Required Reading
1. **outputs/notes/W2.T07-notes.md**: FormattingContext trait contract
2. **outputs/notes/W2.T08-notes.md**: FormattingContextType enum
3. **Rust Book Chapter 17**: Using Trait Objects for polymorphism
4. **Design Patterns**: Factory pattern (Gang of Four)

## Inputs

### From Dependencies

1. **W2.T07-notes.md** (FormattingContext trait)
   - Look for: Trait signature (layout, compute_intrinsic_inline_size)
   - Look for: LayoutError types
   - Key insight: What must every FC implementation provide

2. **W2.T08-notes.md** (FormattingContextType)
   - Look for: All FC type variants
   - Look for: derive_fc_from_display() function
   - Key insight: How to determine which FC to create

### Existing Code

Read:
- `src/layout/formatting_context.rs` - FormattingContext trait
- `src/layout/contexts/types.rs` - FormattingContextType enum
- `src/tree/box_tree.rs` - BoxNode structure

## Objectives

### Primary Goals

1. **Define FormattingContextFactory struct**: Factory for creating FCs
2. **Implement create_for_box()**: Main factory method
3. **Create stub FC implementations**: Block, Inline, Flex, Grid, Table stubs
4. **Handle creation errors**: Proper error handling
5. **Support future extensibility**: Easy to add real implementations
6. **Comprehensive tests**: Test all code paths with stubs
7. **Documentation**: Explain stub vs real implementations

### Success Criteria

- [ ] FormattingContextFactory struct complete
- [ ] create_for_box() method implemented
- [ ] 5 stub FC implementations (Block, Inline, Flex, Grid, Table)
- [ ] All stubs implement FormattingContext trait
- [ ] Proper error handling for unsupported cases
- [ ] Factory returns Box<dyn FormattingContext>
- [ ] Tests with all stub implementations
- [ ] Clear documentation on replacing stubs
- [ ] All tests pass
- [ ] Clippy clean
- [ ] Notes file comprehensive

## Implementation Guide

### Step 1: Update Module Structure (Estimated: 10min)

**Update `src/layout/contexts/mod.rs`:**
```rust
//! Formatting context types and factory
//!
//! This module contains:
//! - FormattingContextType enum (discriminator)
//! - FormattingContext factory (creates appropriate FC)

pub mod types;
pub mod factory;

// Re-exports
pub use types::{FormattingContextType, derive_fc_from_display, BfcTriggers};
pub use factory::FormattingContextFactory;
```

### Step 2: Define Stub FC Implementations (Estimated: 1.5 hours)

**Create `src/layout/contexts/factory.rs`:**

```rust
//! FormattingContext factory
//!
//! Creates the appropriate FormattingContext implementation based on box properties.

use crate::layout::formatting_context::{FormattingContext, IntrinsicSizingMode, LayoutError};
use crate::layout::constraints::LayoutConstraints;
use crate::tree::{BoxNode, Fragment};
use crate::geometry::{Rect, Size, Point};

/// Stub implementation of BlockFormattingContext
///
/// This is a placeholder until the real implementation is completed in W3.T04.
/// It implements the FormattingContext trait but returns dummy fragments.
///
/// # Note
///
/// This will be replaced with the real BlockFormattingContext in Wave 3.
/// For now, it allows testing the factory and layout engine infrastructure.
struct StubBlockFormattingContext;

impl FormattingContext for StubBlockFormattingContext {
    fn layout(
        &self,
        box_node: &BoxNode,
        constraints: &LayoutConstraints,
    ) -> Result<Fragment, LayoutError> {
        // Stub: Return a dummy fragment with arbitrary size
        // Real implementation will:
        // 1. Compute used values for width, height, margins, etc.
        // 2. Recursively layout children
        // 3. Position children vertically
        // 4. Handle margin collapsing
        // 5. Return properly positioned fragment tree

        let width = constraints.available_width.definite_value().unwrap_or(100.0);
        let height = constraints.available_height.definite_value().unwrap_or(50.0);

        Ok(Fragment::new_block(
            Rect::new(Point::ZERO, Size::new(width, height)),
            box_node.style.clone(),
            vec![], // No children in stub
        ))
    }

    fn compute_intrinsic_inline_size(
        &self,
        _box_node: &BoxNode,
        _mode: IntrinsicSizingMode,
    ) -> Result<f32, LayoutError> {
        // Stub: Return arbitrary size
        // Real implementation will measure content
        Ok(100.0)
    }
}

/// Stub implementation of InlineFormattingContext
///
/// Placeholder until real implementation in W4.T12.
struct StubInlineFormattingContext;

impl FormattingContext for StubInlineFormattingContext {
    fn layout(
        &self,
        box_node: &BoxNode,
        constraints: &LayoutConstraints,
    ) -> Result<Fragment, LayoutError> {
        // Stub: Return dummy inline fragment
        // Real implementation will:
        // 1. Shape text runs
        // 2. Break lines at boundaries
        // 3. Create line boxes
        // 4. Position line boxes vertically
        // 5. Return fragment tree with line boxes

        let width = constraints.available_width.definite_value().unwrap_or(200.0);
        let height = 20.0; // Arbitrary line height

        Ok(Fragment::new_inline(
            Rect::new(Point::ZERO, Size::new(width, height)),
            box_node.style.clone(),
            vec![],
        ))
    }

    fn compute_intrinsic_inline_size(
        &self,
        _box_node: &BoxNode,
        _mode: IntrinsicSizingMode,
    ) -> Result<f32, LayoutError> {
        // Stub: Return arbitrary text width
        Ok(200.0)
    }
}

/// Stub implementation of FlexFormattingContext
///
/// Placeholder until real implementation in W3.T08.
struct StubFlexFormattingContext;

impl FormattingContext for StubFlexFormattingContext {
    fn layout(
        &self,
        box_node: &BoxNode,
        constraints: &LayoutConstraints,
    ) -> Result<Fragment, LayoutError> {
        // Stub: Return dummy flex container
        // Real implementation will:
        // 1. Determine main/cross axis
        // 2. Collect flex items
        // 3. Resolve flexible lengths
        // 4. Position items along main axis
        // 5. Align items on cross axis

        let width = constraints.available_width.definite_value().unwrap_or(300.0);
        let height = constraints.available_height.definite_value().unwrap_or(100.0);

        Ok(Fragment::new_block(
            Rect::new(Point::ZERO, Size::new(width, height)),
            box_node.style.clone(),
            vec![],
        ))
    }

    fn compute_intrinsic_inline_size(
        &self,
        _box_node: &BoxNode,
        _mode: IntrinsicSizingMode,
    ) -> Result<f32, LayoutError> {
        // Stub: Return arbitrary flex container size
        Ok(300.0)
    }
}

/// Stub implementation of GridFormattingContext
///
/// Placeholder until real implementation in Wave 4.
struct StubGridFormattingContext;

impl FormattingContext for StubGridFormattingContext {
    fn layout(
        &self,
        box_node: &BoxNode,
        constraints: &LayoutConstraints,
    ) -> Result<Fragment, LayoutError> {
        // Stub: Return dummy grid container
        // Real implementation will:
        // 1. Resolve grid template
        // 2. Place grid items
        // 3. Size tracks
        // 4. Align items in cells
        // 5. Return positioned fragment tree

        let width = constraints.available_width.definite_value().unwrap_or(400.0);
        let height = constraints.available_height.definite_value().unwrap_or(400.0);

        Ok(Fragment::new_block(
            Rect::new(Point::ZERO, Size::new(width, height)),
            box_node.style.clone(),
            vec![],
        ))
    }

    fn compute_intrinsic_inline_size(
        &self,
        _box_node: &BoxNode,
        _mode: IntrinsicSizingMode,
    ) -> Result<f32, LayoutError> {
        // Stub: Return arbitrary grid size
        Ok(400.0)
    }
}

/// Stub implementation of TableFormattingContext
///
/// Placeholder until real implementation in W3.T06.
struct StubTableFormattingContext;

impl FormattingContext for StubTableFormattingContext {
    fn layout(
        &self,
        box_node: &BoxNode,
        constraints: &LayoutConstraints,
    ) -> Result<Fragment, LayoutError> {
        // Stub: Return dummy table
        // Real implementation will:
        // 1. Build table structure (rows, columns)
        // 2. Run table width algorithm
        // 3. Distribute column widths
        // 4. Position cells
        // 5. Handle spanning cells

        let width = constraints.available_width.definite_value().unwrap_or(500.0);
        let height = 200.0; // Arbitrary table height

        Ok(Fragment::new_block(
            Rect::new(Point::ZERO, Size::new(width, height)),
            box_node.style.clone(),
            vec![],
        ))
    }

    fn compute_intrinsic_inline_size(
        &self,
        _box_node: &BoxNode,
        _mode: IntrinsicSizingMode,
    ) -> Result<f32, LayoutError> {
        // Stub: Return arbitrary table width
        Ok(500.0)
    }
}
```

### Step 3: Implement FormattingContextFactory (Estimated: 1 hour)

**Add to `src/layout/contexts/factory.rs`:**

```rust
use crate::layout::contexts::types::{FormattingContextType, derive_fc_from_display};

/// Factory for creating FormattingContext implementations
///
/// The factory determines which formatting context to use based on a box's
/// display property and other characteristics.
///
/// # Current Implementation
///
/// Currently returns stub implementations for all FC types. These stubs
/// implement the FormattingContext trait but return dummy fragments.
///
/// # Future Implementation
///
/// In Wave 3, stubs will be replaced with real implementations:
/// - W3.T04: Real BlockFormattingContext
/// - W4.T12: Real InlineFormattingContext
/// - W3.T08: Real FlexFormattingContext
/// - Wave 4: Real GridFormattingContext
/// - W3.T06: Real TableFormattingContext
///
/// # Examples
///
/// ```
/// use std::sync::Arc;
/// use fastrender::layout::contexts::FormattingContextFactory;
/// use fastrender::layout::constraints::LayoutConstraints;
/// use fastrender::tree::{BoxNode, FormattingContextType};
/// # use fastrender::tree::box_tree::ComputedStyle;
///
/// let factory = FormattingContextFactory::new();
/// let style = Arc::new(ComputedStyle::default());
/// let box_node = BoxNode::new_block(
///     style,
///     FormattingContextType::Block,
///     vec![],
/// );
///
/// let fc = factory.create_for_box(&box_node).unwrap();
/// let constraints = LayoutConstraints::with_definite_size(800.0, 600.0);
/// let fragment = fc.layout(&box_node, &constraints).unwrap();
/// ```
pub struct FormattingContextFactory {
    // Future: May contain configuration, caching, custom FC registry, etc.
    _placeholder: (),
}

impl FormattingContextFactory {
    /// Creates a new factory with default configuration
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::layout::contexts::FormattingContextFactory;
    ///
    /// let factory = FormattingContextFactory::new();
    /// ```
    pub fn new() -> Self {
        Self {
            _placeholder: (),
        }
    }

    /// Creates the appropriate FormattingContext for a box
    ///
    /// Determines the FC type from the box's display property and returns
    /// the corresponding implementation.
    ///
    /// # Arguments
    ///
    /// * `box_node` - The box to create a formatting context for
    ///
    /// # Returns
    ///
    /// A boxed FormattingContext implementation, or an error if no
    /// appropriate FC can be created.
    ///
    /// # Errors
    ///
    /// Returns `LayoutError::UnsupportedBoxType` if:
    /// - The display value doesn't establish a formatting context
    /// - The box type is not supported (shouldn't happen in practice)
    ///
    /// # Examples
    ///
    /// ```
    /// use std::sync::Arc;
    /// use fastrender::layout::contexts::FormattingContextFactory;
    /// use fastrender::tree::{BoxNode, FormattingContextType};
    /// # use fastrender::tree::box_tree::ComputedStyle;
    ///
    /// let factory = FormattingContextFactory::new();
    /// let style = Arc::new(ComputedStyle::default());
    /// let box_node = BoxNode::new_block(
    ///     style,
    ///     FormattingContextType::Block,
    ///     vec![],
    /// );
    ///
    /// let fc = factory.create_for_box(&box_node).unwrap();
    /// // fc is now a Box<dyn FormattingContext>
    /// ```
    pub fn create_for_box(
        &self,
        box_node: &BoxNode,
    ) -> Result<Box<dyn FormattingContext>, LayoutError> {
        // Determine FC type from box's formatting context
        let fc_type = box_node.formatting_context()
            .ok_or_else(|| LayoutError::UnsupportedBoxType(
                "Box does not establish a formatting context".to_string()
            ))?;

        // Create appropriate FC implementation
        match fc_type {
            FormattingContextType::BlockFormatting => {
                Ok(Box::new(StubBlockFormattingContext))
            }
            FormattingContextType::InlineFormatting => {
                Ok(Box::new(StubInlineFormattingContext))
            }
            FormattingContextType::FlexFormatting => {
                Ok(Box::new(StubFlexFormattingContext))
            }
            FormattingContextType::GridFormatting => {
                Ok(Box::new(StubGridFormattingContext))
            }
            FormattingContextType::TableFormatting => {
                Ok(Box::new(StubTableFormattingContext))
            }
        }
    }

    /// Creates a specific formatting context type
    ///
    /// This is a lower-level method that creates an FC for a specific type,
    /// bypassing box analysis. Useful for testing or when the FC type is
    /// already known.
    ///
    /// # Arguments
    ///
    /// * `fc_type` - The formatting context type to create
    ///
    /// # Returns
    ///
    /// A boxed FormattingContext implementation
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::layout::contexts::{FormattingContextFactory, FormattingContextType};
    ///
    /// let factory = FormattingContextFactory::new();
    /// let fc = factory.create_specific(FormattingContextType::BlockFormatting);
    /// ```
    pub fn create_specific(
        &self,
        fc_type: FormattingContextType,
    ) -> Box<dyn FormattingContext> {
        match fc_type {
            FormattingContextType::BlockFormatting => {
                Box::new(StubBlockFormattingContext)
            }
            FormattingContextType::InlineFormatting => {
                Box::new(StubInlineFormattingContext)
            }
            FormattingContextType::FlexFormatting => {
                Box::new(StubFlexFormattingContext)
            }
            FormattingContextType::GridFormatting => {
                Box::new(StubGridFormattingContext)
            }
            FormattingContextType::TableFormatting => {
                Box::new(StubTableFormattingContext)
            }
        }
    }
}

impl Default for FormattingContextFactory {
    fn default() -> Self {
        Self::new()
    }
}
```

### Step 4: Write Comprehensive Tests (Estimated: 1 hour)

**Add at bottom of file:**

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use crate::tree::{BoxNode, FormattingContextType};
    use crate::layout::constraints::{LayoutConstraints, AvailableSpace};
    use std::sync::Arc;

    fn default_style() -> Arc<crate::tree::box_tree::ComputedStyle> {
        Arc::new(crate::tree::box_tree::ComputedStyle::default())
    }

    #[test]
    fn test_factory_creation() {
        let factory = FormattingContextFactory::new();
        // Factory should be created successfully
        let _ = factory;
    }

    #[test]
    fn test_factory_default() {
        let factory = FormattingContextFactory::default();
        let _ = factory;
    }

    #[test]
    fn test_create_block_fc() {
        let factory = FormattingContextFactory::new();
        let box_node = BoxNode::new_block(
            default_style(),
            FormattingContextType::BlockFormatting,
            vec![],
        );

        let fc = factory.create_for_box(&box_node).unwrap();
        let constraints = LayoutConstraints::with_definite_size(800.0, 600.0);
        let fragment = fc.layout(&box_node, &constraints).unwrap();

        assert_eq!(fragment.bounds().size().width, 800.0);
    }

    #[test]
    fn test_create_inline_fc() {
        let factory = FormattingContextFactory::new();

        // Create an inline box that establishes IFC
        // (In practice, this would be a block container with inline children)
        let box_node = BoxNode::new_block(
            default_style(),
            FormattingContextType::InlineFormatting,
            vec![],
        );

        let fc = factory.create_for_box(&box_node).unwrap();
        let constraints = LayoutConstraints::with_definite_size(800.0, 600.0);
        let fragment = fc.layout(&box_node, &constraints).unwrap();

        // Stub returns 200.0 width
        assert_eq!(fragment.bounds().size().width, 800.0);
    }

    #[test]
    fn test_create_flex_fc() {
        let factory = FormattingContextFactory::new();
        let box_node = BoxNode::new_block(
            default_style(),
            FormattingContextType::FlexFormatting,
            vec![],
        );

        let fc = factory.create_for_box(&box_node).unwrap();
        let constraints = LayoutConstraints::with_definite_size(800.0, 600.0);
        let fragment = fc.layout(&box_node, &constraints).unwrap();

        assert_eq!(fragment.bounds().size().width, 800.0);
    }

    #[test]
    fn test_create_grid_fc() {
        let factory = FormattingContextFactory::new();
        let box_node = BoxNode::new_block(
            default_style(),
            FormattingContextType::GridFormatting,
            vec![],
        );

        let fc = factory.create_for_box(&box_node).unwrap();
        let constraints = LayoutConstraints::with_definite_size(800.0, 600.0);
        let fragment = fc.layout(&box_node, &constraints).unwrap();

        assert_eq!(fragment.bounds().size().width, 800.0);
    }

    #[test]
    fn test_create_table_fc() {
        let factory = FormattingContextFactory::new();
        let box_node = BoxNode::new_block(
            default_style(),
            FormattingContextType::TableFormatting,
            vec![],
        );

        let fc = factory.create_for_box(&box_node).unwrap();
        let constraints = LayoutConstraints::with_definite_size(800.0, 600.0);
        let fragment = fc.layout(&box_node, &constraints).unwrap();

        assert_eq!(fragment.bounds().size().width, 800.0);
    }

    #[test]
    fn test_create_for_inline_box_fails() {
        let factory = FormattingContextFactory::new();
        // Regular inline box doesn't establish FC
        let box_node = BoxNode::new_inline(default_style(), vec![]);

        let result = factory.create_for_box(&box_node);
        assert!(result.is_err());
    }

    #[test]
    fn test_create_specific_block() {
        let factory = FormattingContextFactory::new();
        let fc = factory.create_specific(FormattingContextType::BlockFormatting);

        let box_node = BoxNode::new_block(
            default_style(),
            FormattingContextType::BlockFormatting,
            vec![],
        );
        let constraints = LayoutConstraints::with_definite_size(800.0, 600.0);
        let fragment = fc.layout(&box_node, &constraints).unwrap();

        assert_eq!(fragment.bounds().size().width, 800.0);
    }

    #[test]
    fn test_create_specific_all_types() {
        let factory = FormattingContextFactory::new();
        let types = vec![
            FormattingContextType::BlockFormatting,
            FormattingContextType::InlineFormatting,
            FormattingContextType::FlexFormatting,
            FormattingContextType::GridFormatting,
            FormattingContextType::TableFormatting,
        ];

        for fc_type in types {
            let fc = factory.create_specific(fc_type);
            let box_node = BoxNode::new_block(
                default_style(),
                fc_type,
                vec![],
            );
            let constraints = LayoutConstraints::with_definite_size(800.0, 600.0);
            let result = fc.layout(&box_node, &constraints);
            assert!(result.is_ok(), "Failed for {:?}", fc_type);
        }
    }

    #[test]
    fn test_intrinsic_sizing_block() {
        let factory = FormattingContextFactory::new();
        let fc = factory.create_specific(FormattingContextType::BlockFormatting);

        let box_node = BoxNode::new_block(
            default_style(),
            FormattingContextType::BlockFormatting,
            vec![],
        );

        let size = fc.compute_intrinsic_inline_size(
            &box_node,
            IntrinsicSizingMode::MinContent,
        ).unwrap();

        assert_eq!(size, 100.0); // Stub returns 100.0
    }

    #[test]
    fn test_intrinsic_sizing_all_fcs() {
        let factory = FormattingContextFactory::new();
        let types = vec![
            FormattingContextType::BlockFormatting,
            FormattingContextType::InlineFormatting,
            FormattingContextType::FlexFormatting,
            FormattingContextType::GridFormatting,
            FormattingContextType::TableFormatting,
        ];

        for fc_type in types {
            let fc = factory.create_specific(fc_type);
            let box_node = BoxNode::new_block(
                default_style(),
                fc_type,
                vec![],
            );

            let result = fc.compute_intrinsic_inline_size(
                &box_node,
                IntrinsicSizingMode::MaxContent,
            );

            assert!(result.is_ok(), "Failed for {:?}", fc_type);
        }
    }

    #[test]
    fn test_layout_with_indefinite_size() {
        let factory = FormattingContextFactory::new();
        let fc = factory.create_specific(FormattingContextType::BlockFormatting);

        let box_node = BoxNode::new_block(
            default_style(),
            FormattingContextType::BlockFormatting,
            vec![],
        );

        let constraints = LayoutConstraints::new(
            AvailableSpace::MaxContent,
            AvailableSpace::MaxContent,
        );

        let fragment = fc.layout(&box_node, &constraints).unwrap();
        // Stub falls back to 100.0 when size is indefinite
        assert_eq!(fragment.bounds().size().width, 100.0);
    }

    #[test]
    fn test_multiple_fc_instances() {
        let factory = FormattingContextFactory::new();

        // Create multiple FCs of same type
        let fc1 = factory.create_specific(FormattingContextType::BlockFormatting);
        let fc2 = factory.create_specific(FormattingContextType::BlockFormatting);

        // Both should work independently
        let box_node = BoxNode::new_block(
            default_style(),
            FormattingContextType::BlockFormatting,
            vec![],
        );
        let constraints = LayoutConstraints::with_definite_size(800.0, 600.0);

        let frag1 = fc1.layout(&box_node, &constraints).unwrap();
        let frag2 = fc2.layout(&box_node, &constraints).unwrap();

        assert_eq!(frag1.bounds().size(), frag2.bounds().size());
    }

    #[test]
    fn test_factory_reuse() {
        let factory = FormattingContextFactory::new();

        // Reuse same factory for multiple creations
        for _ in 0..10 {
            let fc = factory.create_specific(FormattingContextType::FlexFormatting);
            let box_node = BoxNode::new_block(
                default_style(),
                FormattingContextType::FlexFormatting,
                vec![],
            );
            let constraints = LayoutConstraints::with_definite_size(800.0, 600.0);
            let result = fc.layout(&box_node, &constraints);
            assert!(result.is_ok());
        }
    }
}
```

### Step 5: Documentation and Verification (Estimated: 15min)

Run verification:
```bash
cargo test layout::contexts::factory
cargo clippy -- -D warnings
cargo fmt
cargo doc --no-deps --open
```

## Testing Requirements

Run: `cargo test layout::contexts::factory`

Expected: 15+ tests passing covering:
- Factory creation
- All FC types can be created
- create_for_box() works for boxes that establish FCs
- create_for_box() fails for boxes that don't establish FCs
- create_specific() works for all types
- Layout through factory-created FCs works
- Intrinsic sizing through factory-created FCs works
- Multiple FC instances work independently
- Factory can be reused

## Output Artifacts

### Code Files

1. **`src/layout/contexts/factory.rs`** (~500-600 lines)
   - 5 stub FC implementations
   - FormattingContextFactory struct
   - create_for_box() and create_specific() methods
   - Comprehensive tests

### Notes File

Create: **`outputs/notes/W2.T09-notes.md`**

**Key sections:**
- **API Contracts**: Factory methods and their guarantees
- **Decision: Why Box<dyn Trait>**: Rationale for trait objects
- **Decision: Stub implementations**: Why stubs are temporary
- **Recommendations**: How to replace stubs with real implementations
- **Integration**: How W2.T10 (LayoutEngine) will use factory
- **Migration path**: Step-by-step guide for replacing each stub

## Common Pitfalls to Avoid

### Pitfall 1: Returning Concrete Types Instead of Trait Objects

**Wrong:**
```rust
pub fn create_for_box(&self, box_node: &BoxNode) -> StubBlockFormattingContext {
    StubBlockFormattingContext
}
```

**Right:**
```rust
pub fn create_for_box(&self, box_node: &BoxNode) -> Box<dyn FormattingContext> {
    Box::new(StubBlockFormattingContext)
}
```

### Pitfall 2: Forgetting to Implement All Trait Methods in Stubs

**Wrong:**
```rust
impl FormattingContext for StubBlockFormattingContext {
    fn layout(...) -> Result<Fragment, LayoutError> { ... }
    // Missing compute_intrinsic_inline_size!
}
```

**Right:** Implement ALL trait methods, even in stubs

### Pitfall 3: Making Stubs Too Complex

**Wrong:** Trying to implement partial layout logic in stubs
**Right:** Keep stubs simple - just return dummy values

## Verification Checklist

- [ ] FormattingContextFactory struct complete
- [ ] All 5 stub FCs implement FormattingContext trait
- [ ] create_for_box() handles all FC types
- [ ] create_specific() works for all types
- [ ] Proper error handling for unsupported boxes
- [ ] Tests cover all code paths
- [ ] Documentation explains stub vs real
- [ ] Clippy clean
- [ ] Notes file comprehensive

## Time Tracking

- **Module setup:** 10min
- **Stub implementations:** 1.5hrs
- **Factory implementation:** 1hr
- **Tests:** 1hr
- **Documentation:** 30min
- **Total:** 3-4 hours

## Getting Help

- Review `outputs/notes/W2.T07-notes.md` for FormattingContext trait
- Check `outputs/notes/W2.T08-notes.md` for FC type determination
- See Rust Book Chapter 17 for trait objects
- Gang of Four Design Patterns for Factory pattern

Remember: Stubs are temporary! They'll be replaced with real implementations in Wave 3.
