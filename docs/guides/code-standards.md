# Code Standards & Conventions

**Purpose:** Define coding standards for consistent, high-quality code
**Audience:** AI agents and human developers
**Rule:** All code MUST follow these standards

## Philosophy

Our coding philosophy is based on these principles:

1. **Simplicity over cleverness** - Code should be obvious, not clever
2. **Clarity over brevity** - Readable > short
3. **Explicitness over implicitness** - No magic, no surprises
4. **Testability first** - If it's hard to test, it's wrong
5. **Fail fast** - Errors should be visible immediately

## Rust Conventions

### Naming

**Follow Rust naming conventions exactly:**

```rust
// Module names: snake_case
mod box_tree;
mod formatting_context;

// Type names: PascalCase
struct BoxNode { }
enum DisplayType { }
trait FormattingContext { }

// Function names: snake_case
fn compute_layout() { }
fn is_block_level() -> bool { }

// Constant names: SCREAMING_SNAKE_CASE
const DEFAULT_FONT_SIZE: f32 = 16.0;
const MAX_RECURSION_DEPTH: usize = 1000;

// Variable names: snake_case
let fragment_tree = ...;
let available_width = ...;
```

**Naming Guidelines:**

- Use descriptive names, avoid abbreviations
  - ✅ `available_width`
  - ❌ `avail_w`

- Boolean functions start with `is_`, `has_`, `can_`, `should_`
  - ✅ `is_block_level()`, `has_children()`, `can_collapse()`
  - ❌ `block_level()`, `children()`, `collapse()`

- Conversion functions use `to_`, `from_`, `into_`
  - ✅ `to_pixels()`, `from_em()`, `into_fragment()`
  - ❌ `pixels()`, `em()`, `fragment()`

- Avoid generic names
  - ❌ `data`, `info`, `temp`, `value`, `thing`
  - ✅ Specific domain names

### Type Definitions

**Struct Organization:**

```rust
/// A CSS box in the box tree
///
/// Represents a box as defined in the CSS Display Module Level 3.
/// Boxes are generated from styled DOM nodes and consumed by layout
/// algorithms to produce fragments.
///
/// # Examples
///
/// ```
/// use fastrender::tree::box_tree::*;
/// use std::sync::Arc;
///
/// let style = Arc::new(ComputedStyle::default());
/// let box_node = BoxNode::new_block(
///     style,
///     FormattingContextType::Block,
///     vec![],
/// );
/// ```
#[derive(Debug, Clone)]
pub struct BoxNode {
    /// Computed style for this box
    ///
    /// Shared with the corresponding fragment to avoid duplication.
    pub style: Arc<ComputedStyle>,

    /// Type of box (block, inline, text, etc.)
    pub box_type: BoxType,

    /// Child boxes
    pub children: Vec<BoxNode>,

    /// Optional debug information
    pub debug_info: Option<DebugInfo>,
}
```

**Key points:**
- Doc comment on struct explaining what it is
- Doc comment on each field explaining what it contains
- Example if it's a public API
- Derive common traits: `Debug`, `Clone` (when appropriate)

**Enum Organization:**

```rust
/// Types of CSS boxes
#[derive(Debug, Clone)]
pub enum BoxType {
    /// Block-level box (div, p, h1, etc.)
    Block(BlockBox),

    /// Inline-level box (span, a, em, etc.)
    Inline(InlineBox),

    /// Text box containing actual text content
    Text(TextBox),

    /// Replaced element (img, video, canvas, etc.)
    Replaced(ReplacedBox),

    /// Anonymous box generated by layout algorithm
    Anonymous(AnonymousBox),
}
```

**Key points:**
- Doc comment on enum
- Doc comment on each variant
- Use tuple variants or struct variants, not raw values

### Function Signatures

**Public Functions:**

```rust
/// Compute the layout of a box within given constraints
///
/// This function implements the block formatting context layout algorithm
/// as specified in CSS 2.1 Section 9.4.1.
///
/// # Arguments
///
/// * `box_node` - The box to layout
/// * `constraints` - Available space and containing block size
///
/// # Returns
///
/// A fragment tree representing the laid-out box and its children
///
/// # Errors
///
/// Returns `LayoutError` if:
/// - Box has circular references (exceeds max recursion depth)
/// - Constraints are invalid (negative sizes)
///
/// # Examples
///
/// ```
/// use fastrender::layout::block::*;
///
/// let mut layout = BlockLayout::new();
/// let constraints = Constraints::definite(800.0, 600.0);
/// let fragment = layout.layout(&box_node, constraints)?;
/// ```
pub fn layout(
    &mut self,
    box_node: &BoxNode,
    constraints: Constraints,
) -> Result<Fragment, LayoutError> {
    // Implementation
}
```

**Private Functions:**

```rust
/// Helper function to compute margin collapsing
///
/// Implements the margin collapsing algorithm from CSS 2.1 Section 8.3.1.
fn compute_collapsed_margin(
    margin1: f32,
    margin2: f32,
) -> f32 {
    // Spec: Take the maximum of positive margins, minimum of negative
    if margin1 >= 0.0 && margin2 >= 0.0 {
        margin1.max(margin2)
    } else if margin1 < 0.0 && margin2 < 0.0 {
        margin1.min(margin2)
    } else {
        margin1 + margin2
    }
}
```

**Key points:**
- All public functions have doc comments
- Private functions have brief comments
- Document parameters, returns, errors, examples
- Reference spec sections when implementing algorithms

### Error Handling

**Always use Result for fallible operations:**

```rust
// ✅ Good - explicit error handling
pub fn parse_color(s: &str) -> Result<Color, ParseError> {
    if s.starts_with('#') {
        parse_hex_color(s)
    } else {
        parse_named_color(s)
    }
}

// ❌ Bad - panics on invalid input
pub fn parse_color(s: &str) -> Color {
    if s.starts_with('#') {
        parse_hex_color(s).unwrap()
    } else {
        panic!("Invalid color: {}", s);
    }
}
```

**Use ? operator for error propagation:**

```rust
// ✅ Good
pub fn render(html: &str) -> Result<Pixmap> {
    let dom = parse_html(html)?;
    let box_tree = build_box_tree(&dom)?;
    let fragments = layout(&box_tree)?;
    let pixmap = rasterize(&fragments)?;
    Ok(pixmap)
}

// ❌ Bad - hiding errors
pub fn render(html: &str) -> Pixmap {
    let dom = parse_html(html).expect("Parse failed");
    let box_tree = build_box_tree(&dom).expect("Box tree failed");
    let fragments = layout(&box_tree).expect("Layout failed");
    rasterize(&fragments).expect("Raster failed")
}
```

**Never use unwrap/expect in library code:**

```rust
// ❌ Never in production code
let value = option.unwrap();
let result = fallible_op().expect("This should never fail");

// ✅ Use pattern matching
let value = match option {
    Some(v) => v,
    None => return Err(Error::MissingValue),
};

// ✅ Or use ? with Option
let value = option.ok_or(Error::MissingValue)?;
```

**Exception:** Test code can use unwrap

```rust
#[test]
fn test_something() {
    let result = compute().unwrap(); // OK in tests
    assert_eq!(result, expected);
}
```

### Comments

**When to comment:**

```rust
// ✅ Good - explains WHY, not WHAT
// CSS spec requires we use the larger of the two margins (margin collapsing)
let margin = margin1.max(margin2);

// ❌ Bad - explains WHAT (obvious from code)
// Set margin to the maximum of margin1 and margin2
let margin = margin1.max(margin2);

// ✅ Good - explains non-obvious algorithm
// Line breaking algorithm from UAX #14
// We use greedy breaking: fit as much as possible on each line
let break_point = find_break_opportunity(text, width);

// ✅ Good - explains spec reference
// CSS Tables Module Level 3, Section 7.2
// "The automatic table layout algorithm distributes width proportionally
// between min-content and max-content widths"
let width = distribute_width(&min_widths, &max_widths, available);

// ✅ Good - explains workaround
// HACK: rustybuzz doesn't support color emoji, so we skip them
// TODO: Add proper emoji support via harfbuzz
if !is_color_emoji(glyph) {
    render_glyph(glyph);
}
```

**Comment tags:**

- `TODO:` - Feature not yet implemented
- `FIXME:` - Bug that needs fixing
- `HACK:` - Temporary workaround (should be rare!)
- `NOTE:` - Important information
- `SAFETY:` - Explains why unsafe code is safe

### Code Organization

**Module structure:**

```rust
// src/layout/block.rs

//! Block Formatting Context
//!
//! Implements the block layout algorithm as specified in CSS 2.1 Section 9.4.1.
//!
//! # Algorithm Overview
//!
//! 1. Compute width of block (§10.3.3)
//! 2. Layout children vertically
//! 3. Compute height (§10.6.3)
//! 4. Apply margin collapsing (§8.3.1)

// Imports - organized groups
use crate::geom::{Rect, Size};
use crate::tree::box_tree::{BoxNode, BoxType};
use crate::tree::fragment::Fragment;
use crate::layout::formatting_context::{FormattingContext, Constraints};
use std::sync::Arc;

// Constants
const MAX_BLOCK_NESTING: usize = 1000;

// Main struct
pub struct BlockLayout {
    // fields
}

// Public impl
impl BlockLayout {
    pub fn new() -> Self { }
    // other public methods
}

// Trait implementations
impl FormattingContext for BlockLayout {
    fn layout(&mut self, box_node: &BoxNode, constraints: Constraints) -> Fragment {
        // implementation
    }
}

// Private functions
fn helper_function() { }

// Tests
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_something() { }
}
```

**File size limits:**
- Keep files under 1000 lines
- If larger, split into submodules
- Example: `src/layout/table/mod.rs`, `src/layout/table/width.rs`, etc.

### Testing

**Test organization:**

```rust
#[cfg(test)]
mod tests {
    use super::*;

    // Group related tests
    mod width_calculation {
        use super::*;

        #[test]
        fn auto_width_fills_containing_block() {
            // Arrange
            let style = Arc::new(ComputedStyle {
                width: None, // auto
                ..Default::default()
            });
            let box_node = BoxNode::new_block(style, FC::Block, vec![]);
            let mut layout = BlockLayout::new();
            let constraints = Constraints::definite(800.0, 600.0);

            // Act
            let fragment = layout.layout(&box_node, constraints).unwrap();

            // Assert
            assert_eq!(fragment.size().width, 800.0);
        }

        #[test]
        fn specified_width_is_respected() {
            // Arrange
            let style = Arc::new(ComputedStyle {
                width: Some(Length::px(400.0)),
                ..Default::default()
            });
            let box_node = BoxNode::new_block(style, FC::Block, vec![]);
            let mut layout = BlockLayout::new();
            let constraints = Constraints::definite(800.0, 600.0);

            // Act
            let fragment = layout.layout(&box_node, constraints).unwrap();

            // Assert
            assert_eq!(fragment.size().width, 400.0);
        }
    }

    mod height_calculation {
        use super::*;

        #[test]
        fn auto_height_fits_content() {
            // Test implementation
        }
    }
}
```

**Test naming:**
- Use descriptive names: `test_auto_width_fills_containing_block`
- Not: `test1`, `test_width`, `width_test`

**Test structure:**
- Arrange: Set up test data
- Act: Execute function being tested
- Assert: Verify results

**Use helper functions:**

```rust
#[cfg(test)]
mod tests {
    use super::*;

    // Helper to create test box
    fn create_block_box(width: Option<f32>, height: Option<f32>) -> BoxNode {
        let style = Arc::new(ComputedStyle {
            width: width.map(Length::px),
            height: height.map(Length::px),
            ..Default::default()
        });
        BoxNode::new_block(style, FormattingContextType::Block, vec![])
    }

    #[test]
    fn test_with_helper() {
        let box_node = create_block_box(Some(400.0), Some(300.0));
        // ... test code
    }
}
```

## Architecture Patterns

### Separation of Concerns

**Each module has ONE responsibility:**

```rust
// ✅ Good - clear separation
mod css {
    // ONLY parsing CSS
}
mod style {
    // ONLY computing styles
}
mod layout {
    // ONLY layout algorithms
}
mod paint {
    // ONLY rasterization
}

// ❌ Bad - mixed concerns
mod rendering {
    // Parsing, styling, layout, paint all mixed
}
```

### Immutability

**Prefer immutable data:**

```rust
// ✅ Good - immutable
#[derive(Debug, Clone)]
pub struct BoxNode {
    pub style: Arc<ComputedStyle>,
    pub children: Vec<BoxNode>,
}

// Box tree is never modified after construction

// ❌ Bad - mutable
pub struct BoxNode {
    pub style: Arc<ComputedStyle>,
    pub children: RefCell<Vec<BoxNode>>,
}
```

**Use builder pattern for configuration:**

```rust
// ✅ Good
let renderer = Renderer::builder()
    .viewport_size(1024, 768)
    .background_color(Color::WHITE)
    .build();

// ❌ Bad - mutable configuration
let mut renderer = Renderer::new();
renderer.set_viewport_size(1024, 768);
renderer.set_background_color(Color::WHITE);
```

### Resource Management

**Use Arc for shared ownership:**

```rust
// ✅ Good - ComputedStyle is shared
pub struct BoxNode {
    pub style: Arc<ComputedStyle>,
}

pub struct Fragment {
    pub style: Arc<ComputedStyle>, // Same Arc as BoxNode
}

// ❌ Bad - duplicates data
pub struct BoxNode {
    pub style: ComputedStyle,
}

pub struct Fragment {
    pub style: ComputedStyle, // Clone of BoxNode's style
}
```

**Use caching for expensive operations:**

```rust
// ✅ Good
pub struct FontCache {
    cache: HashMap<FontKey, Arc<Font>>,
}

impl FontCache {
    pub fn get_font(&mut self, key: &FontKey) -> Arc<Font> {
        self.cache.entry(key.clone())
            .or_insert_with(|| Arc::new(load_font(key)))
            .clone()
    }
}

// ❌ Bad - loads font every time
pub fn get_font(key: &FontKey) -> Font {
    load_font(key)
}
```

## Performance Guidelines

### Avoid Premature Optimization

**Write simple code first, optimize if needed:**

```rust
// ✅ Good - simple, clear
fn find_box_by_id(&self, id: &str) -> Option<&BoxNode> {
    if self.id() == Some(id) {
        return Some(self);
    }

    for child in &self.children {
        if let Some(found) = child.find_box_by_id(id) {
            return Some(found);
        }
    }

    None
}

// ❌ Bad - premature optimization
fn find_box_by_id(&self, id: &str) -> Option<&BoxNode> {
    // Cache hit?
    if let Some(cached) = GLOBAL_ID_CACHE.get(id) {
        return Some(cached);
    }

    // Complex bitmap-based search...
}
```

### Measure Before Optimizing

**Use benchmarks to guide optimization:**

```rust
// Don't optimize without data
// Run: cargo bench
// Identify hot spots
// Optimize only hot spots
// Measure again to verify improvement
```

### Common Patterns

**Avoid allocation in hot paths:**

```rust
// ✅ Good - reuse buffer
pub struct LineBreaker {
    buffer: String,
}

impl LineBreaker {
    pub fn break_line(&mut self, text: &str) -> Vec<Line> {
        self.buffer.clear();
        // Use self.buffer instead of allocating new String
    }
}

// ❌ Bad - allocates every call
pub fn break_line(text: &str) -> Vec<Line> {
    let mut buffer = String::new(); // New allocation
    // ...
}
```

**Use iterators instead of collecting:**

```rust
// ✅ Good - lazy, no allocation
let total: f32 = fragments
    .iter()
    .map(|f| f.width())
    .sum();

// ❌ Bad - creates intermediate vector
let total: f32 = fragments
    .iter()
    .map(|f| f.width())
    .collect::<Vec<_>>()
    .iter()
    .sum();
```

## Forbidden Patterns

### Never Do These Things

**1. Magic numbers**

```rust
// ❌ Bad
let width = available * 0.73; // What is 0.73?

// ✅ Good
const MAIN_CONTENT_WIDTH_RATIO: f32 = 0.73;
// Main content typically spans 73% of viewport width
let width = available * MAIN_CONTENT_WIDTH_RATIO;
```

**2. Element-specific code in layout/paint**

```rust
// ❌ FORBIDDEN - element-specific logic
if node.has_class("votearrow") {
    width = 10.0;
}

// ✅ Good - generic, CSS-driven
let width = compute_width(&node.style, constraints);
```

**3. Silent failures**

```rust
// ❌ Bad - error disappears
match parse_css(css) {
    Ok(stylesheet) => stylesheet,
    Err(_) => StyleSheet::default(), // Error is lost!
}

// ✅ Good - propagate error
let stylesheet = parse_css(css)?;

// ✅ Also good - log and return default
let stylesheet = parse_css(css).unwrap_or_else(|e| {
    eprintln!("Warning: CSS parse error: {}", e);
    StyleSheet::default()
});
```

**4. println/eprintln in library code**

```rust
// ❌ Bad - libraries shouldn't own stdout/stderr
println!("Debug: width = {}", width);

// ✅ Good - use logging crate (if needed)
log::debug!("width = {}", width);

// ✅ Best - no logging in library, let user decide
// (Keep code silent by default)
```

**5. Global mutable state**

```rust
// ❌ FORBIDDEN
static mut GLOBAL_CACHE: Option<HashMap<K, V>> = None;

// ✅ Good - pass state explicitly
pub struct Engine {
    cache: HashMap<K, V>,
}
```

## Documentation Standards

### Module-level Documentation

Every module starts with:

```rust
//! Short description (one sentence)
//!
//! Longer description explaining what this module does,
//! why it exists, and how it fits into the larger system.
//!
//! # Architecture
//!
//! Explain the key types and how they relate.
//!
//! # Examples
//!
//! ```
//! // Show how to use the module
//! ```
//!
//! # References
//!
//! - CSS Specification Section X.Y.Z
//! - Related modules: foo, bar
```

### Type Documentation

```rust
/// Short description (one sentence)
///
/// Longer description with details.
///
/// # Layout Algorithm
///
/// Explain the algorithm this type implements.
///
/// # Examples
///
/// ```
/// use fastrender::layout::BlockLayout;
///
/// let layout = BlockLayout::new();
/// ```
///
/// # Specification
///
/// CSS 2.1 Section 9.4.1: Block Formatting Contexts
pub struct BlockLayout {
    // ...
}
```

### Function Documentation

Every public function:

```rust
/// Short description (one sentence)
///
/// Longer description.
///
/// # Arguments
///
/// * `foo` - Description
/// * `bar` - Description
///
/// # Returns
///
/// Description of return value
///
/// # Errors
///
/// This function returns an error if:
/// - Condition 1
/// - Condition 2
///
/// # Examples
///
/// ```
/// let result = function(arg1, arg2)?;
/// ```
///
/// # Panics
///
/// This function panics if... (avoid panics!)
pub fn function(foo: Foo, bar: Bar) -> Result<Baz> {
    // ...
}
```

## Git Commit Messages

**Format:**

```
Short summary (50 chars or less)

More detailed explanation if needed. Wrap at 72 characters.
Explain WHAT changed and WHY, not HOW (code shows how).

Reference: CSS Spec Section 9.4.1

Fixes: #123
```

**Examples:**

```
✅ Good:
Implement block layout algorithm

Implements CSS 2.1 Section 9.4.1 block formatting context.
Boxes are stacked vertically with margin collapsing.

Reference: CSS 2.1 Section 9.4.1

❌ Bad:
Fixed stuff
updated code
WIP
```

## Code Review Checklist

Before committing code, verify:

- [ ] No `unwrap()` or `panic!()` in production code
- [ ] No element-specific logic (class checks, etc.)
- [ ] All public items have documentation
- [ ] Tests exist and pass
- [ ] No compiler warnings
- [ ] `cargo clippy` passes
- [ ] `cargo fmt` has been run
- [ ] Follows naming conventions
- [ ] Error handling is correct (use Result)
- [ ] Comments explain WHY, not WHAT
- [ ] No magic numbers (use constants)
- [ ] Performance is reasonable (if hot path)

## Tools

**Required:**

```bash
# Format code
cargo fmt

# Check for common mistakes
cargo clippy -- -D warnings

# Run tests
cargo test

# Check documentation
cargo doc --no-deps --open

# Coverage
cargo tarpaulin
```

**Recommended:**

```bash
# Static analysis
cargo audit

# Dependency tree
cargo tree

# Bloat analysis
cargo bloat
```

## Summary

The most important rules:

1. **Simple > Clever**
2. **No hacks, ever**
3. **Test everything**
4. **Document why, not what**
5. **Errors are values (Result)**
6. **Immutable by default**
7. **One responsibility per module**
8. **Follow the spec, not intuition**

When in doubt: Read the spec, look at browser code, write a test.
