# W4.T03: Text Shaper Component - Implementation Notes

## Task Summary

Implemented a comprehensive text shaping component using rustybuzz (pure Rust HarfBuzz port) for OpenType text shaping. The shaper converts Unicode text into positioned glyphs, handling:

- Complex scripts (Arabic, Hebrew, Devanagari)
- Ligatures (fi, ff, fl combinations)
- Kerning adjustments
- Combining marks/diacritics
- RTL and vertical text directions

## Implementation Details

### Core Types

| Type | Purpose |
|------|---------|
| `TextShaper` | Main shaping interface, stateless and thread-safe |
| `TextDirection` | Text direction (Ltr, Rtl, Ttb, Btt) - distinct from bidi::Direction |
| `Script` | Unicode script (Latin, Arabic, Hebrew, etc.) |
| `GlyphPosition` | Individual glyph with ID, advance, and offsets |
| `GlyphCluster` | Character-to-glyph mapping for hit testing |
| `ShapedGlyphs` | Complete result with glyphs, clusters, and metrics |

### API Design

```rust
// Simple shaping with explicit parameters
let shaped = shaper.shape_text(
    "Hello",
    &font,
    16.0,
    Script::Latin,
    TextDirection::Ltr,
)?;

// Auto-detect script and direction
let shaped = shaper.shape_text_auto("مرحبا", &font, 16.0)?;

// Quick width measurement
let width = shaper.measure_width("Hello", &font, 16.0)?;
```

### Script Detection

The `Script` enum supports 16 scripts with automatic detection:

- Latin, Greek, Cyrillic (European)
- Arabic, Hebrew (RTL scripts)
- Devanagari, Bengali, Tamil, Thai (Indic)
- Han, Hiragana, Katakana, Hangul (CJK)
- Common, Inherited, Unknown (Unicode special)

Script detection uses Unicode code point ranges for efficiency.

### Cluster Tracking

Clusters map characters to glyphs for:
- **Hit testing**: Find character at x position
- **Cursor positioning**: Get x position for character offset
- **Selection**: Determine selection boundaries

```rust
// Get position for cursor at text offset
let x = shaped.x_position_for_text_offset(5);

// Find character for click position
let offset = shaped.text_offset_for_x_position(50.0);
```

### Integration with rustybuzz

Uses ISO 15924 tags for script identification:

```rust
pub fn iso15924_tag(self) -> [u8; 4] {
    match self {
        Script::Latin => *b"Latn",
        Script::Arabic => *b"Arab",
        Script::Hebrew => *b"Hebr",
        // ...
    }
}
```

## Files Created/Modified

### Created
- `src/text/shaper.rs` - Main shaper implementation (~900 lines)
- `tests/test_shaper.rs` - Comprehensive test suite (66 tests)

### Modified
- `src/text/mod.rs` - Added shaper module export and re-exports

## Test Coverage

**66 tests** covering:

| Category | Tests |
|----------|-------|
| Direction | 4 tests (horizontal/vertical/RTL detection) |
| Script detection | 16 tests (Latin, Arabic, Hebrew, CJK, etc.) |
| GlyphPosition | 3 tests (creation, metrics) |
| GlyphCluster | 4 tests (containment, creation) |
| ShapedGlyphs | 2 tests (empty, cluster lookup) |
| Latin shaping | 7 tests (simple, empty, spaces, accents, scaling) |
| Ligatures | 3 tests (fi, ff, fl) |
| Kerning | 2 tests (AV, To pairs) |
| RTL/Arabic | 4 tests (Arabic, Hebrew, direction) |
| Complex scripts | 2 tests (Devanagari, Cyrillic) |
| Auto-detection | 3 tests (auto Latin, Arabic, simple) |
| Combining marks | 2 tests (acute, precomposed vs combining) |
| Cluster tracking | 3 tests (simple, advances sum) |
| Hit testing | 2 tests (x position, text offset) |
| Width measurement | 3 tests (basic, empty, consistency) |
| Edge cases | 4 tests (emoji, mixed scripts, newlines, tabs) |

## Design Decisions

### 1. Stateless TextShaper

Made `TextShaper` a zero-sized stateless type for simplicity and thread safety. Each `shape_text` call is independent - no state to manage.

### 2. Script as separate from Direction

While rustybuzz can auto-detect these, explicit control allows:
- Overriding for mixed-script text
- Faster shaping when script is known
- Better bidirectional text handling

### 3. Cluster-based hit testing

Clusters provide the right abstraction for text interaction:
- Ligatures (fi) are a single cluster
- Combining characters (e + combining acute) form a cluster
- Selection/cursor stays at cluster boundaries

### 4. ISO 15924 tag conversion

Used ISO 15924 four-character tags for rustybuzz compatibility:
- Standard way to identify scripts
- Works with rustybuzz's `Script::from_iso15924_tag()`
- Easy to extend for new scripts

## Dependencies

| Crate | Usage |
|-------|-------|
| `rustybuzz` 0.20 | Core text shaping |
| `ttf-parser` (via rustybuzz) | Font face parsing, Tag creation |

## Future Enhancements (W4.T04+)

1. **OpenType Features**: Add support for enabling/disabling features (liga, kern, smcp)
2. **Vertical Text**: Full vertical text layout support
3. **Language Tags**: BCP 47 language tag support for locale-specific shaping
4. **Feature API**: User-controllable OpenType feature selection

```rust
// Future API example
let features = vec![
    Feature::new("liga", true),   // Enable ligatures
    Feature::new("smcp", true),   // Small caps
];
let shaped = shaper.shape_with_features(text, &font, 16.0, &features)?;
```

## Verification

```bash
cargo build                    # OK - Builds successfully
cargo test text::shaper        # OK - 24 unit tests pass
cargo test --test test_shaper  # OK - 66 integration tests pass
cargo clippy -- -D warnings    # OK - No warnings in shaper code
```

## Usage Example

```rust
use fastrender::text::{TextShaper, Direction, Script, FontContext};

fn shape_and_render() {
    let ctx = FontContext::new();
    let shaper = TextShaper::new();

    if let Some(font) = ctx.get_sans_serif() {
        // Shape Latin text
        let shaped = shaper
            .shape_text("Hello, World!", &font, 24.0, Script::Latin, Direction::LeftToRight)
            .expect("Shaping should succeed");

        // Use for rendering
        let mut x = 0.0;
        for glyph in &shaped.glyphs {
            let glyph_x = x + glyph.offset_x;
            let glyph_y = glyph.offset_y;
            // render_glyph(glyph.glyph_id, glyph_x, glyph_y);
            x += glyph.advance;
        }

        // Hit testing
        let click_x = 50.0;
        let char_index = shaped.text_offset_for_x_position(click_x);
        println!("Clicked on character {}", char_index);
    }
}
```

## References

- [OpenType Specification](https://learn.microsoft.com/en-us/typography/opentype/spec/)
- [UAX #24: Unicode Script Property](https://www.unicode.org/reports/tr24/)
- [ISO 15924: Script Codes](https://unicode.org/iso15924/)
- [CSS Text Module Level 3](https://www.w3.org/TR/css-text-3/)
- [rustybuzz documentation](https://docs.rs/rustybuzz/)
