# Task W1.T03 Output Notes

## Implementation Summary

Implemented three core CSS value types:
- **LengthUnit**: Enum of all CSS length unit types (px, em, %, etc.)
- **Length**: Value + unit pair with resolution methods
- **LengthOrAuto**: Discriminated union for properties that accept `auto`

These types bridge CSS syntax and layout algorithms, handling unit conversions and context-dependent resolution.

I also consolidated the style types in `src/style/mod.rs` to provide a cleaner structure and ensure compatibility with existing code, while introducing the new `Length` types.

## API Contracts

### Public Types

```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum LengthUnit {
    Px, Pt, Pc, In, Cm, Mm,      // Absolute
    Em, Rem, Ex, Ch,              // Font-relative
    Vw, Vh, Vmin, Vmax,           // Viewport-relative
    Percent,                      // Percentage
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Length {
    pub value: f32,
    pub unit: LengthUnit,
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum LengthOrAuto {
    Length(Length),
    Auto,
}
```

### Key Methods

```rust
impl LengthUnit {
    pub fn is_absolute(self) -> bool;
    pub fn is_font_relative(self) -> bool;
    pub fn is_viewport_relative(self) -> bool;
}

impl Length {
    // Constructors
    pub const fn px(value: f32) -> Self;
    pub const fn em(value: f32) -> Self;
    pub const fn percent(value: f32) -> Self;
    // ... constructors for all units

    // Conversion/resolution
    pub fn to_px(self) -> f32;  // Absolute units only
    pub fn resolve_against(self, percentage_base: f32) -> f32;
    pub fn resolve_with_font_size(self, font_size_px: f32) -> f32;
    pub fn resolve_with_viewport(self, vw: f32, vh: f32) -> f32;
}

impl LengthOrAuto {
    pub fn is_auto(self) -> bool;
    pub fn length(self) -> Option<Length>;
    pub fn to_px(self) -> Option<f32>;
    pub fn resolve_against(self, percentage_base: f32) -> Option<f32>;
    pub fn resolve_or(self, default: f32, percentage_base: f32) -> f32;
}
```

## Decisions Made

### Decision 1: Use f32 for Values

**Choice:** All length values are f32, not f64
**Rationale:**
- Consistent with geometry types (W1.T01)
- Sufficient precision for CSS layout
- Better performance and memory usage
**Impact:** All downstream code should use f32

### Decision 2: Separate resolve_* Methods

**Choice:** Different methods for different resolution contexts
**Rationale:**
- Type safety: Can't accidentally resolve em units against percentage base
- Clear intent: Method name indicates what context is needed
- Compile-time errors: Catches mistakes early

**Alternatives Considered:**
- Single resolve() method taking all context → rejected as error-prone
- Runtime context enum → rejected as less type-safe

### Decision 3: Panic on Invalid Conversions

**Choice:** Methods like `to_px()` panic on relative units
**Rationale:**
- Programming error to call without context
- Should be caught in development, not production
- Clearer than returning Result for obvious misuse

**Impact:** Callers must check unit type or use appropriate resolve method

### Decision 4: Make LengthOrAuto an Enum, Not Option

**Choice:** Explicit enum, not `Option<Length>`
**Rationale:**
- More semantically clear
- Auto is not "absence of length", it's a distinct value
- Better pattern matching ergonomics
- Follows CSS semantics

## Spec Interpretations

### CSS Pixel Definition

**Spec says** (CSS Values Level 3): "The reference pixel is the visual angle of one pixel on a device with a pixel density of 96dpi"

**Interpretation**: 1px = 1/96 inch, 1in = 96px exactly

**Implementation**: Used exact conversion factors from spec

### Unit Conversions

All conversions use CSS 2.1 defined ratios:
- 1in = 2.54cm
- 1in = 96px
- 1in = 72pt
- 1pc = 12pt

## Discoveries & Gotchas

### Discovery 1: Viewport Units Need Context

**What:** vmin/vmax depend on viewport dimensions
**Why it matters:** Cannot be resolved without viewport size
**Recommendation:** Layout algorithms must pass viewport size through constraints

### Gotcha 1: Percentage Heights Are Contextual

**Problem:** Percentage could be relative to containing block height OR font size (for line-height)
**Solution:** Context must specify what percentage is relative to
**Warning:** W2.T05 (ComputedStyle) must document which properties use which base

### Gotcha 2: Zero Lengths Have Units

**Problem:** CSS `0` has no unit, but we need to store one
**Solution:** Use `Length::px(0.0)` as canonical zero
**Impact:** All zero lengths convert to px(0) during parsing

## Performance Notes

### Performance Characteristics
- All types are Copy (8-12 bytes each)
- Resolution methods are inline-friendly
- No allocations

### Optimization Opportunities
- **Caching**: Resolved values could be cached in ComputedStyle
- **SIMD**: Batch resolution of many lengths could use SIMD

## Recommendations for Downstream Tasks

### For Task W2.T05 (ComputedStyle):

- Use `LengthOrAuto` for width, height, margins
- Use `Length` for padding, border-width (never auto)
- Document percentage bases for each property
- Consider caching resolved values if profiles show benefit

### For Task W3.T04 (Block Layout):

- Use `resolve_against()` for width/height percentages
- Use `resolve_or()` with 0.0 for auto margins in BFC
- Remember: auto width has special algorithm, don't just use default

### For Task W3.T16 (Font Metrics):

- Use `resolve_with_font_size()` for em/rem/ex/ch units
- Font size cascade must happen before layout

### For Task W4.T12 (Inline Layout):

- Line-height percentages are relative to font size, not containing block!
- Use `resolve_with_font_size()` not `resolve_against()`

## Open Questions

### Question 1: Subpixel Rendering

**Question:** Should we round resolved values to integer pixels?
**Context:** Browsers use subpixel layout (fractional pixels)
**Suggested resolution:** Keep fractional values, let rasterizer handle rounding
**Assigned to:** W5.T07 (rasterization) should document approach

### Question 2: Negative Lengths

**Question:** Should we allow negative lengths?
**Context:** Most properties don't allow negative, but some (margins) do
**Suggested resolution:** Allow at type level, validate in ComputedStyle
**Assigned to:** W2.T05 should document which properties allow negative

## Test Coverage

### What's Tested
- ✅ All unit type classifications
- ✅ All convenience constructors
- ✅ Absolute unit conversions
- ✅ Percentage resolution
- ✅ Font-relative resolution
- ✅ Viewport-relative resolution
- ✅ Auto handling in all scenarios
- ✅ Display formatting

### What's Not Tested
- ❌ ex/ch unit resolution (needs actual font metrics - W3.T16)
- ❌ Integration with ComputedStyle (W2.T05)
- ❌ Performance of batch resolution (not needed until profiling)

### Test Statistics
- Unit tests: 18 tests passing
- Coverage: All public methods tested
