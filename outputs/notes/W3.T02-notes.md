# Task W3.T02 Output Notes - Anonymous Box Creation

## Implementation Summary

This task implements CSS anonymous box generation rules per CSS 2.1 Sections 9.2.1.1 and 9.2.2.1. The `AnonymousBoxCreator` provides a post-processing fixup pass that transforms a box tree to satisfy CSS structural constraints.

The implementation handles two primary cases:
1. **Anonymous Block Boxes**: When a block container has mixed block-level and inline-level children, consecutive inline-level children are wrapped in anonymous block boxes. This ensures block containers have either all block-level or all inline-level children.
2. **Anonymous Inline Boxes**: When text nodes appear directly in block containers without an explicit inline wrapper, they are wrapped in anonymous inline boxes.

The fixup operates as a recursive bottom-up traversal, first processing children then fixing up the current node. This ensures nested structures are correctly handled at all levels.

## API Contracts

### Primary API

```rust
/// Main entry point for anonymous box fixup
pub struct AnonymousBoxCreator;

impl AnonymousBoxCreator {
    /// Fixes up a box tree by inserting anonymous boxes where required by CSS rules
    /// This is a post-processing step after initial box generation.
    pub fn fixup_tree(mut box_node: BoxNode) -> BoxNode;

    /// Creates an anonymous block box
    pub fn create_anonymous_block(style: Arc<ComputedStyles>, children: Vec<BoxNode>) -> BoxNode;

    /// Creates an anonymous inline box
    pub fn create_anonymous_inline(style: Arc<ComputedStyles>, children: Vec<BoxNode>) -> BoxNode;

    /// Creates an anonymous table row box (for W3.T03)
    pub fn create_anonymous_table_row(style: Arc<ComputedStyles>, children: Vec<BoxNode>) -> BoxNode;

    /// Creates an anonymous table cell box (for W3.T03)
    pub fn create_anonymous_table_cell(style: Arc<ComputedStyles>, children: Vec<BoxNode>) -> BoxNode;

    /// Utility: Checks if children contain mixed block/inline content
    pub fn has_mixed_content(children: &[BoxNode]) -> bool;

    /// Utility: Checks if all children are block-level
    pub fn all_block_level(children: &[BoxNode]) -> bool;

    /// Utility: Checks if all children are inline-level
    pub fn all_inline_level(children: &[BoxNode]) -> bool;

    /// Utility: Counts anonymous boxes in tree (for debugging)
    pub fn count_anonymous_boxes(node: &BoxNode) -> usize;
}
```

### BoxGenerator Integration

```rust
impl BoxGenerator {
    /// Generate with automatic anonymous box fixup (when config.insert_anonymous_boxes = true)
    pub fn generate(&self, dom_root: &DOMNode) -> Result<BoxTree, BoxGenerationError>;

    /// Convenience method that always applies anonymous box fixup
    pub fn generate_with_anonymous_fixup(&self, dom_root: &DOMNode) -> Result<BoxTree, BoxGenerationError>;
}

impl BoxGenerationConfig {
    /// Set to true to enable automatic anonymous box insertion
    pub insert_anonymous_boxes: bool;
}
```

## Decisions Made

### 1. Post-Processing vs Inline Generation

**Decision**: Anonymous box creation is done as a separate post-processing pass rather than during initial box generation.

**Rationale**:
- Cleaner separation of concerns - box generation focuses on DOM-to-box mapping
- Easier to reason about and test in isolation
- Post-processing can see the complete child list before deciding on fixup
- Matches how Servo and other engines handle this

**Impact**: Call `AnonymousBoxCreator::fixup_tree()` after `BoxGenerator::generate_box()` completes, or use `generate_with_anonymous_fixup()` convenience method.

### 2. Bottom-Up Traversal

**Decision**: Process children recursively before fixing up the current node.

**Rationale**:
- Ensures nested mixed content is properly handled at all levels
- Children may need their own anonymous boxes before we can determine parent's fixup needs
- CSS spec describes fixup as applied at each level independently

### 3. Consecutive Inline Grouping

**Decision**: Group consecutive inline-level boxes into a single anonymous block, not one block per inline.

**Rationale**:
- CSS 2.1 Section 9.2.1.1 specifies wrapping "runs" of inline content
- Preserves proper inline formatting context within each anonymous block
- More efficient (fewer boxes created)

**Example**:
```
Input:  [Text, Inline, Block, Text]
Output: [AnonymousBlock[Text, Inline], Block, AnonymousBlock[Text]]
```

### 4. Text in All-Inline Context

**Decision**: When a block container has only inline-level children (no block mixing), text nodes are wrapped in anonymous inline boxes rather than anonymous blocks.

**Rationale**:
- CSS 2.1 Section 9.2.2.1 specifies anonymous inline boxes for bare text
- Preserves inline formatting context for the container
- Anonymous blocks are only needed when there's mixed block/inline content

### 5. Style Inheritance

**Decision**: Anonymous boxes use the style of the first child in the run (or default style if no children).

**Rationale**:
- CSS spec says anonymous boxes inherit from their containing block
- We don't have access to parent style in the static method context
- Using first child's style is a reasonable approximation
- Proper inheritance should be handled during style computation phase

**Impact**: For downstream tasks, be aware that anonymous box styles may need adjustment during layout.

## Spec Interpretations

### CSS 2.1 Section 9.2.1.1 - Anonymous Block Boxes

The spec states: "If a block container box has a block-level box inside it, then we force it to have only block-level boxes inside it."

**Interpretation**:
- "Has a block-level box inside" means at least one direct child is block-level
- "Force" means wrap inline-level children in anonymous block boxes
- Applies recursively at each level of the tree
- Text nodes are considered inline-level for this purpose

### CSS 2.1 Section 9.2.2.1 - Anonymous Inline Boxes

The spec states: "Any text that is directly contained inside a block container element (not inside an inline element) must be treated as an anonymous inline element."

**Interpretation**:
- Text directly in a block container (with no block children) gets anonymous inline wrapper
- Text directly in an inline container also gets anonymous inline wrapper
- This ensures all text has a containing inline box for line breaking

### Edge Cases

1. **Empty containers**: No fixup needed, return empty children list
2. **Single inline child**: No block mixing, so no anonymous block needed
3. **Whitespace-only text**: Still wrapped (whitespace handling is a later phase)
4. **Nested anonymous blocks**: Prevented by bottom-up traversal

## Discoveries & Gotchas

### Gotcha 1: Text is Inline-Level

Text boxes (`BoxType::Text`) are inline-level, so they trigger anonymous block creation when mixed with block boxes. Always use `is_inline_level()` which returns true for both `Inline` and `Text` box types.

### Gotcha 2: Anonymous Blocks Contain the Original Children

When wrapping inline runs in anonymous blocks, the original inline/text boxes become children of the anonymous block. Don't flatten the structure.

```rust
// WRONG: Flattening
children = vec![anon_block]; // Lost the inline children!

// RIGHT: Preserving structure
anon_block.children = inline_run; // Inline children inside anonymous block
result.push(anon_block);
```

### Gotcha 3: Bottom-Up Ordering Matters

Must process children before processing parent, otherwise nested mixed content won't be detected correctly after child fixup changes structure.

### Gotcha 4: Config Flag Default

`BoxGenerationConfig::insert_anonymous_boxes` defaults to `false` for backwards compatibility. Use `generate_with_anonymous_fixup()` or set the flag explicitly to enable fixup.

## Performance Notes

### Complexity

- Time: O(n) where n is total boxes in tree - single recursive traversal
- Space: O(d) stack space where d is tree depth, plus O(n) for child vectors

### Optimization Opportunities

1. **Early exit**: Check for mixed content before processing children could skip unnecessary work
2. **In-place mutation**: Current implementation creates new vectors; could use in-place mutation
3. **Parallel processing**: Independent subtrees could be processed in parallel

### Benchmarks

Not yet benchmarked. For large documents (1000+ boxes), consider profiling the fixup pass.

## Recommendations for Downstream Tasks

### For W3.T03 (Table Structure Fixup)

**Use provided table anonymous box helpers:**
```rust
AnonymousBoxCreator::create_anonymous_table_row(style, children)
AnonymousBoxCreator::create_anonymous_table_cell(style, children)
```

**Pattern for table fixup:**
1. Call `AnonymousBoxCreator::fixup_tree()` first for block/inline fixup
2. Then apply table-specific fixup in a second pass
3. Table anonymous boxes use different `AnonymousType` variants

### For W3.T04 (Block Layout)

**Anonymous blocks behave like regular blocks:**
- They establish block formatting context
- Use `is_block_container()` which returns true for anonymous blocks
- Check `is_anonymous()` only when you need to skip DOM-related operations

**Style access:**
- Anonymous boxes have a style, but it may be approximate
- Don't rely on CSS properties that might differ from actual inheritance

### For W4.T12 (Inline Layout)

**Anonymous inlines behave like regular inlines:**
- They participate in inline formatting context
- Text is wrapped in anonymous inline, so always access text via `box.children[0].text()`
- Don't assume text is direct child of block container

**Detection:**
```rust
if box.is_anonymous() && box.is_inline_level() {
    // Anonymous inline wrapping text
    if let Some(text) = box.children.first().and_then(|c| c.text()) {
        // Process text
    }
}
```

### For Layout in General

**Use utility methods:**
```rust
// Check if fixup would create anonymous boxes
if AnonymousBoxCreator::has_mixed_content(&children) {
    // Will need fixup
}

// Debug: count anonymous boxes
let count = AnonymousBoxCreator::count_anonymous_boxes(&root);
```

**Enable fixup:**
```rust
// Option 1: Via config
let mut config = BoxGenerationConfig::new();
config.insert_anonymous_boxes = true;
let generator = BoxGenerator::with_config(config);
let tree = generator.generate(&dom)?;

// Option 2: Via convenience method
let generator = BoxGenerator::new();
let tree = generator.generate_with_anonymous_fixup(&dom)?;
```

## Open Questions

### 1. Style Inheritance Accuracy

Currently anonymous boxes get an approximate style (from first child or default). Should we:
- Pass parent style into the fixup function?
- Add a separate style inheritance pass?
- Leave for style computation phase to handle?

**Suggested resolution**: Leave for style computation phase - anonymous boxes should inherit from containing block at that time.

### 2. Table Fixup Ordering

Should table fixup happen:
- As part of this fixup pass?
- As a separate pass after this one?
- Integrated into table layout?

**Suggested resolution**: Separate pass in W3.T03, called after this fixup.

### 3. Performance for Large Documents

For documents with thousands of boxes, should we:
- Add caching?
- Use parallel processing?
- Add early exit optimizations?

**Suggested resolution**: Profile first, optimize if needed. Current O(n) complexity should be acceptable.

## Test Coverage

### Unit Tests (12 tests in `src/tree/anonymous.rs`)

- `test_empty_container_no_crash` - Empty containers
- `test_all_block_children_no_change` - All block children
- `test_single_text_wrapped` - Text wrapping
- `test_mixed_content_wraps_inline_runs` - Mixed content
- `test_consecutive_inlines_grouped` - Inline grouping
- `test_nested_fixup` - Nested structures
- `test_all_inline_content_wraps_text` - All inline with text
- `test_inline_container_wraps_text` - Inline containers
- `test_has_mixed_content` - Utility method
- `test_count_anonymous_boxes` - Counting utility
- `test_text_at_start_and_end` - Text positioning
- `test_deeply_nested_structure` - Deep nesting

### Integration Tests (30+ tests in `tests/tree/test_anonymous_boxes.rs`)

Comprehensive coverage including:
- Basic fixup scenarios
- Text wrapping in various contexts
- Mixed content patterns
- Consecutive inline grouping
- Nested structures (2-level, deep)
- All-inline content handling
- Helper function tests
- BoxGenerator integration tests
- Edge cases (empty text, whitespace, anonymous types)

### Test Gaps

- Performance tests for large trees not yet added
- Table anonymous box scenarios not tested (deferred to W3.T03)
- Complex real-world DOM structures not covered

## Files Created/Modified

### Created

1. **`src/tree/anonymous.rs`** (~400 lines)
   - `AnonymousBoxCreator` implementation
   - Block/inline fixup methods
   - Anonymous box creation helpers
   - Utility methods
   - Unit tests

2. **`tests/tree/test_anonymous_boxes.rs`** (~500 lines)
   - 30+ comprehensive tests
   - All anonymous box scenarios
   - BoxGenerator integration tests

3. **`tests/tree/mod.rs`**
   - Module declaration for test file

4. **`outputs/notes/W3.T02-notes.md`** (this file)

### Modified

1. **`src/tree/mod.rs`**
   - Added `pub mod anonymous;`
   - Added `pub use anonymous::AnonymousBoxCreator;`

2. **`src/tree/box_generation.rs`**
   - Imported `AnonymousBoxCreator`
   - Updated `generate()` to use fixup when `insert_anonymous_boxes` is true
   - Added `generate_with_anonymous_fixup()` convenience method

---

**Last Updated:** 2025-11-22
**Task Status:** Complete
**Verification:** All tests passing, clippy clean, formatted
