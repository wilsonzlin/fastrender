# W5.T06: Canvas Wrapper Component - Implementation Notes

## Overview

Implemented a comprehensive Canvas wrapper for tiny-skia that provides a high-level 2D graphics API for painting display items. The Canvas abstracts over tiny-skia's low-level API and provides state management for transforms, clips, and opacity.

## Files Created

### `src/paint/canvas.rs`
Main canvas module providing:
- `Canvas` struct wrapping tiny-skia `Pixmap`
- `BorderRadii` for rounded rectangle corners
- `BlendMode` enum mapping CSS blend modes to tiny-skia
- State management (save/restore pattern)
- Drawing primitives (rect, rounded rect, circle, line, text)

### `tests/test_canvas.rs`
Comprehensive integration tests covering:
- Canvas creation and initialization
- All drawing primitives
- State management (save/restore)
- Transform operations
- Opacity handling
- Clipping
- Blend modes
- Edge cases

### `src/paint/mod.rs` (Updated)
Added exports for the canvas module:
- `Canvas`
- `BorderRadii`
- `BlendMode`

## Key Implementation Details

### State Management
The Canvas maintains a stack of graphics states, each containing:
- Transform matrix
- Opacity value (0.0-1.0)
- Clip rectangle (optional)
- Blend mode

States are pushed/popped via `save()` and `restore()` methods, enabling CSS-like layered rendering.

### Color Handling
Uses `crate::css::Color` which provides RGBA values as u8 components. The canvas converts these to tiny-skia colors with proper alpha blending based on current state opacity.

### Drawing Primitives

1. **Rectangle (`draw_rect`, `stroke_rect`)**
   - Simple filled or stroked rectangles
   - Clip-aware rendering

2. **Rounded Rectangle (`draw_rounded_rect`, `stroke_rounded_rect`)**
   - Per-corner radii via `BorderRadii`
   - Radius clamping to prevent invalid geometry
   - Uses quadratic bezier curves for corners

3. **Circle (`draw_circle`, `stroke_circle`)**
   - Cubic bezier approximation (4 curves)
   - Uses KAPPA constant (~0.5523) for circle approximation

4. **Line (`draw_line`)**
   - Simple path-based line drawing

5. **Text (`draw_text`)**
   - Renders glyphs from `GlyphPosition` array
   - Uses font outlines via `ttf_parser`
   - Proper baseline positioning
   - Coordinate system flip (font Y-up to screen Y-down)

### Glyph Rendering
Text rendering uses a custom `GlyphPathBuilder` that implements `ttf_parser::OutlineBuilder`:
- Transforms glyph coordinates from font units to pixels
- Flips Y axis for screen coordinates
- Handles move_to, line_to, quad_to, and curve_to operations

### Transform Support
- `translate(dx, dy)` - Translation
- `scale(sx, sy)` - Uniform or non-uniform scaling
- `set_transform(transform)` - Direct transform setting

### Blend Modes
Maps CSS `mix-blend-mode` values to tiny-skia:
- Normal, Multiply, Screen, Overlay
- Darken, Lighten, ColorDodge, ColorBurn
- HardLight, SoftLight, Difference, Exclusion

## Design Decisions

1. **State Stack Pattern**: Chose save/restore pattern (like HTML Canvas API) over explicit state objects for familiarity and CSS compatibility.

2. **Clip Handling**: Implemented simple rectangle intersection for clips rather than complex path clipping, sufficient for CSS box model.

3. **Anti-aliasing**: Enabled by default for smoother edges on all drawing operations.

4. **Error Handling**: Canvas creation can fail (returns `Result`), but drawing operations are infallible (skip invalid operations silently).

5. **Coordinate System**: Uses standard screen coordinates (origin top-left, Y increasing downward).

## Integration Points

### With Display List (future W5.T07)
The Canvas is designed to be used by a display list renderer:
```rust
for item in display_list.items() {
    match item {
        DisplayItem::Rect { rect, color } => canvas.draw_rect(rect, color),
        DisplayItem::Text { position, glyphs, font, size, color } => {
            canvas.draw_text(position, glyphs, font, size, color);
        }
        // etc.
    }
}
```

### With Painter
The existing Painter module can be refactored to use Canvas for drawing:
```rust
let mut canvas = Canvas::new(width, height, background)?;
// Walk fragment tree and draw using canvas
canvas.into_pixmap()
```

## Test Coverage

36 integration tests covering:
- Canvas creation (various sizes, colors, transparent)
- Rectangle drawing (basic, at origin, multiple, stroked)
- Rounded rectangles (uniform, per-corner, large radius clamping)
- Circles and lines
- State save/restore for opacity and transforms
- Nested transforms
- Clipping
- Blend modes
- Text rendering with shaped glyphs
- Edge cases (transparent, zero size, outside bounds, negative radius)
- Complex multi-layer scenes

## Performance Considerations

1. **Early Bail-out**: Skips drawing transparent colors and zero-opacity operations
2. **Clip Intersection**: Pre-computes clip intersection before creating paths
3. **Path Reuse**: Rounded rect paths are built once per draw
4. **No Allocations in Hot Path**: State stack uses Vec with reasonable capacity

## CSS Compatibility

The Canvas supports CSS rendering requirements:
- Box backgrounds and borders (via `draw_rect`, `draw_rounded_rect`)
- Text rendering with proper glyph positioning
- Opacity via state management
- CSS blend modes
- Transform operations for positioned elements

## Dependencies

- `tiny-skia` - Core 2D graphics (Pixmap, PathBuilder, Paint)
- `ttf-parser` - Font outline extraction for glyph rendering
- `crate::css::Color` - CSS color type
- `crate::geometry` - Point, Rect, Size types
- `crate::text::shaper::GlyphPosition` - Shaped glyph data
- `crate::text::font_db::LoadedFont` - Font data

## Future Enhancements

1. **Gradient Support**: Add linear/radial gradient fills
2. **Image Drawing**: Support for image/texture rendering
3. **Shadow Effects**: Box shadows and text shadows
4. **Path API**: General path drawing for complex shapes
5. **Mask Support**: Alpha masks for complex clipping
6. **Layer Compositing**: Offscreen render targets for effects
