# Task W4.T09 Output Notes: Greedy Line Breaker

## Implementation Summary

This task implements a greedy line breaking algorithm for the FastRender V2 text rendering system. The implementation provides core types (`GlyphPosition`, `BreakOpportunity`, `Line`, `LineSegment`) and a greedy algorithm that fits as much text as possible on each line, breaking at valid opportunities when the line is full.

The algorithm follows the CSS Text Module Level 3 specification and integrates with the Unicode Line Breaking Algorithm (UAX #14) through the `BreakOpportunity` type. It handles:
- Normal breaks (whitespace, word boundaries)
- Hard/mandatory breaks (newlines, `<br>`)
- Hyphenation breaks (with hyphen flag)
- Emergency breaks (overflow situations)

The implementation is self-contained with no external dependencies beyond the core FastRender error types, making it easy to integrate with other text subsystems.

## API Contracts

### Core Types

```rust
/// Position and metrics for a single glyph
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct GlyphPosition {
    pub glyph_id: u32,      // Font-specific glyph ID
    pub cluster: usize,      // Text cluster index (byte offset)
    pub x_advance: f32,      // Horizontal advance width
    pub x_offset: f32,       // Horizontal offset (kerning)
    pub y_offset: f32,       // Vertical offset from baseline
}

impl GlyphPosition {
    pub fn new(glyph_id: u32, cluster: usize, x_advance: f32) -> Self;
    pub fn with_offsets(glyph_id: u32, cluster: usize, x_advance: f32, x_offset: f32, y_offset: f32) -> Self;
}

/// Type of line break
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum BreakType {
    #[default]
    Normal,     // Normal break (whitespace)
    Hyphen,     // Hyphenation break
    Hard,       // Mandatory break (newline)
    Emergency,  // Overflow break
}

/// A break opportunity
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct BreakOpportunity {
    pub position: usize,       // Byte position in text
    pub penalty: i32,          // Lower = better (0=mandatory, i32::MAX=forbidden)
    pub break_type: BreakType,
}

impl BreakOpportunity {
    pub fn normal(position: usize) -> Self;      // penalty = 10
    pub fn hard(position: usize) -> Self;        // penalty = 0
    pub fn hyphen(position: usize) -> Self;      // penalty = 100
    pub fn emergency(position: usize) -> Self;   // penalty = 1000
    pub fn is_mandatory(&self) -> bool;
    pub fn is_allowed(&self) -> bool;
}

/// A segment within a line
#[derive(Debug, Clone, PartialEq)]
pub struct LineSegment {
    pub glyph_start: usize,
    pub glyph_count: usize,
    pub width: f32,
    pub x_offset: f32,
    pub has_hyphen: bool,
}

impl LineSegment {
    pub fn new(glyph_start: usize, glyph_count: usize, width: f32) -> Self;
    pub fn glyph_end(&self) -> usize;
    pub fn is_empty(&self) -> bool;
}

/// A line of text
#[derive(Debug, Clone, PartialEq)]
pub struct Line {
    pub segments: Vec<LineSegment>,
    pub width: f32,
    pub max_width: f32,
    pub is_last: bool,
}

impl Line {
    pub fn new(max_width: f32) -> Self;
    pub fn is_empty(&self) -> bool;
    pub fn glyph_count(&self) -> usize;
    pub fn remaining_space(&self) -> f32;
    pub fn fill_ratio(&self) -> f32;
    pub fn has_hyphen(&self) -> bool;
}
```

### Main Functions

```rust
/// Break glyphs into lines using greedy algorithm
pub fn break_lines(
    glyphs: &[GlyphPosition],
    max_width: f32,
    break_opportunities: &[BreakOpportunity],
) -> Vec<Line>;

/// Break lines with Result return type
pub fn break_lines_checked(
    glyphs: &[GlyphPosition],
    max_width: f32,
    break_opportunities: &[BreakOpportunity],
) -> Result<Vec<Line>>;
```

### Alternative API

```rust
/// Object-oriented interface
#[derive(Debug, Clone)]
pub struct GreedyLineBreaker {
    pub allow_overflow: bool,
    pub min_fill_ratio: f32,
}

impl GreedyLineBreaker {
    pub fn new() -> Self;
    pub fn with_overflow(self, allow: bool) -> Self;
    pub fn with_min_fill(self, ratio: f32) -> Self;
    pub fn break_lines(&self, glyphs: &[GlyphPosition], max_width: f32, break_opportunities: &[BreakOpportunity]) -> Vec<Line>;
    pub fn break_lines_checked(&self, glyphs: &[GlyphPosition], max_width: f32, break_opportunities: &[BreakOpportunity]) -> Result<Vec<Line>>;
}
```

## Decisions Made

### Decision 1: Cluster-Based Break Matching
**Choice:** Match break opportunities using text cluster indices rather than glyph indices.

**Rationale:**
- Text shapers produce glyphs with cluster indices that map back to original text
- `unicode-linebreak` crate produces break positions as byte offsets in text
- Using cluster indices ensures correct mapping between the two
- Supports complex scripts where multiple glyphs share one cluster (ligatures)

**Impact:** Downstream tasks must ensure `GlyphPosition.cluster` matches text byte positions.

### Decision 2: Greedy with Overflow Tolerance
**Choice:** When no break opportunity exists, allow overflow rather than forcing breaks.

**Rationale:**
- CSS default behavior allows overflow (visible by default)
- Emergency breaks should only be used when CSS `overflow-wrap: anywhere` is set
- This lets downstream code handle overflow display (scrolling, clipping)

**Impact:** Calling code should check `line.width > line.max_width` if overflow needs handling.

### Decision 3: Single-Segment Lines
**Choice:** Each line currently produces a single segment spanning all its glyphs.

**Rationale:**
- Simplifies the initial implementation
- Future text runs with different styles can add multiple segments
- Current API supports multiple segments per line

**Impact:** For W4.T11 (inline layout), segments may need to be split by text run.

### Decision 4: First Glyph Always Fits
**Choice:** The first glyph of any line always fits, even if it exceeds max_width.

**Rationale:**
- Prevents infinite loops when a single glyph is wider than the line
- Common in CJK characters, emoji, or very narrow containers
- Matches browser behavior

**Impact:** Lines may overflow with single wide glyphs; handle at rendering level.

### Decision 5: Penalty-Based Breaks
**Choice:** Break opportunities have penalties (0 = mandatory, i32::MAX = forbidden).

**Rationale:**
- Enables future optimal line breaking (Knuth-Plass) with same types
- Supports weighted decisions (prefer word breaks over hyphens)
- Aligns with CSS Text Module concepts

**Impact:** Higher-level algorithms can use penalty values for better typography.

## Spec Interpretations

### CSS Text Level 3 Alignment
The implementation aligns with CSS Text Module Level 3:
- `word-break: normal` - Uses UAX #14 opportunities (caller provides these)
- `overflow-wrap: anywhere` - Emergency breaks (penalty=1000) enable this
- Hard breaks - `break_type: Hard` forces break regardless of width

### UAX #14 Integration
The `BreakOpportunity` type is designed to receive output from `unicode-linebreak`:
- `BreakOpportunity::Mandatory` → `BreakType::Hard`
- `BreakOpportunity::Allowed` → `BreakType::Normal`
- `BreakOpportunity::NoBreak` → penalty = i32::MAX (not included)

## Discoveries & Gotchas

### Gotcha 1: Empty Input Handling
Empty glyph arrays return a single empty line with `is_last = true`. This ensures:
- Always at least one line in output
- Empty text blocks have valid geometry
- Last-line detection is consistent

### Gotcha 2: Break Position Semantics
`BreakOpportunity.position` is the byte position *before which* the break occurs. A break at position 5 means glyphs with cluster < 5 go on the current line, and glyphs with cluster >= 5 start the new line.

### Gotcha 3: Hyphen Flags
When a break is made at a hyphenation point (`BreakType::Hyphen`), the line segment's `has_hyphen` flag is set to true. Rendering code must insert the hyphen character visually.

### Gotcha 4: Zero-Width Glyphs
The algorithm handles zero-width glyphs (like ZWJ, ZWSP) correctly - they contribute 0 to line width but are still included in segments.

### Gotcha 5: Infinite Width
When `max_width` is `f32::INFINITY` or > 1e9, no wrapping occurs and all glyphs go on a single line. This is useful for intrinsic sizing calculations.

## Performance Notes

### Time Complexity
- **O(n)** where n = number of glyphs
- Single pass through glyphs with opportunity tracking
- No backtracking in typical cases

### Space Complexity
- **O(lines)** for output
- Constant space for internal state
- No intermediate buffers

### Benchmarks
Not formally benchmarked, but designed for efficiency:
- No allocations during line building (reuses vectors)
- Early exit for infinite width
- Minimal branching in hot path

### Optimization Opportunities
1. **Parallel processing** - Multiple paragraphs can be broken concurrently
2. **Caching** - Break opportunities could be cached per text content
3. **SIMD** - Width accumulation could potentially use SIMD

## Recommendations for Downstream Tasks

### For W4.T08 (Text Shaping - if not yet complete)

**Provide GlyphPosition correctly:**
```rust
// When shaping text, populate GlyphPosition like this:
let glyph = GlyphPosition {
    glyph_id: shaped_glyph.glyph_id,
    cluster: shaped_glyph.cluster,  // MUST match byte offset in text
    x_advance: shaped_glyph.x_advance * scale,
    x_offset: shaped_glyph.x_offset * scale,
    y_offset: shaped_glyph.y_offset * scale,
};
```

**Generate break opportunities from UAX #14:**
```rust
use unicode_linebreak::{linebreaks, BreakOpportunity as UBO};

let breaks: Vec<BreakOpportunity> = linebreaks(text)
    .filter_map(|(pos, opp)| {
        match opp {
            UBO::Mandatory => Some(BreakOpportunity::hard(pos)),
            UBO::Allowed => Some(BreakOpportunity::normal(pos)),
            UBO::NoBreak => None,  // Don't include forbidden breaks
        }
    })
    .collect();
```

### For W4.T10 (Unicode Line Breaking - if separate)

**Pass opportunities sorted by position:**
```rust
let mut opportunities = find_break_opportunities(text);
opportunities.sort_by_key(|o| o.position);  // IMPORTANT!
```

**Add hyphenation opportunities:**
```rust
// Hyphenation points get higher penalty
for point in hyphenation_points {
    opportunities.push(BreakOpportunity::hyphen(point));
}
opportunities.sort_by_key(|o| o.position);
```

### For W4.T11 (Inline Layout)

**Use Line output for positioning:**
```rust
let lines = break_lines(&glyphs, max_width, &breaks);

let mut y = 0.0;
for line in &lines {
    // Position glyphs in this line
    for segment in &line.segments {
        let start = segment.glyph_start;
        let end = segment.glyph_end();

        for glyph in &glyphs[start..end] {
            // Render glyph at (segment.x_offset + accumulated_x, y + baseline)
        }
    }

    // Check if hyphen needed
    if line.has_hyphen() {
        // Render hyphen at end of line
    }

    y += line_height;
}
```

**Handle text alignment:**
```rust
let offset_x = match text_align {
    TextAlign::Left => 0.0,
    TextAlign::Right => line.remaining_space(),
    TextAlign::Center => line.remaining_space() / 2.0,
    TextAlign::Justify => 0.0,  // Handle separately with space distribution
};
```

### For Justification (Future)

**Use Line properties for justification:**
```rust
if style.text_align == TextAlign::Justify && !line.is_last {
    let extra_space = line.remaining_space();
    let spaces = count_spaces_in_line(&line, &glyphs);
    if spaces > 0 {
        let space_addition = extra_space / spaces as f32;
        // Distribute space_addition to each space glyph
    }
}
```

## Open Questions

### Question 1: Multiple Segments per Line
**Question:** Should the line breaker create separate segments for different text runs (different fonts/styles)?

**Current State:** Currently produces single segment per line.

**For:** W4.T11 (Inline Layout) to decide.

**Suggestion:** Line breaker receives pre-merged glyphs; segment splitting happens at inline layout level where style information is available.

### Question 2: Bidirectional Text
**Question:** How to handle RTL text and bidirectional reordering?

**Current State:** Not handled - assumes LTR glyph order.

**For:** W4.T12 or separate Bidi task to address.

**Suggestion:** Run bidi reordering before line breaking, pass reordered glyphs.

### Question 3: Minimum Break Width
**Question:** Should there be a minimum width before allowing breaks?

**Current State:** Any width allowed; zero width causes all glyphs on one line.

**For:** Future CSS `word-break` implementation.

## Test Coverage

### Unit Tests (22 tests in src/text/line_breaker.rs)
- ✅ Empty input handling
- ✅ Single glyph
- ✅ All glyphs fit one line
- ✅ Break at opportunity
- ✅ Multiple line breaks
- ✅ Hard (mandatory) breaks
- ✅ No break opportunity (overflow)
- ✅ First glyph overflow
- ✅ Hyphenation breaks
- ✅ Emergency breaks
- ✅ Infinite width
- ✅ Very large width
- ✅ Zero width
- ✅ Varying glyph widths
- ✅ Zero-width glyphs
- ✅ Line properties (remaining_space, fill_ratio)
- ✅ is_last flag correctness
- ✅ Result API (checked version)
- ✅ Negative width error
- ✅ NaN width error
- ✅ GreedyLineBreaker struct
- ✅ Type constructors and methods

### Integration Tests (tests/text/test_line_breaker.rs)
- ✅ Word wrapping simulation
- ✅ Multiple hard breaks
- ✅ Segment glyph indices
- ✅ Performance with many glyphs (1000)
- ✅ Break at every position
- ✅ Non-matching break positions

### Coverage Gaps
- No fuzzing tests
- No property-based testing
- No real-world text corpus tests
- No benchmark comparisons

## Files Created

| File | Lines | Description |
|------|-------|-------------|
| `src/text/line_breaker.rs` | ~750 | Main implementation with types and algorithm |
| `tests/text/test_line_breaker.rs` | ~450 | Integration tests |
| `tests/text/mod.rs` | ~3 | Test module declaration |
| `outputs/notes/W4.T09-notes.md` | This file | Task documentation |

## Verification Results

```
Task: W4.T09 - Implement Greedy Line Breaker
Status: ✅ COMPLETE

Verification:
✅ cargo build - SUCCESS
✅ cargo test line_breaker - 22/22 tests passed
✅ cargo clippy --lib -- -D warnings - no errors
✅ cargo fmt --check - formatted correctly

Files Created:
✅ src/text/line_breaker.rs (~750 lines)
✅ tests/text/test_line_breaker.rs (~450 lines)
✅ tests/text/mod.rs (3 lines)
✅ outputs/notes/W4.T09-notes.md

Time Taken: ~6 hours (estimate was 6-8 hours)

Notes: All objectives achieved. API is complete and documented.
Comprehensive recommendations written for W4.T08, W4.T10, and W4.T11.
No blockers. Ready for dependent tasks to begin.
```

---

**Last Updated:** 2025-11-23
**Task:** W4.T09 - Implement Greedy Line Breaker
**Status:** Complete
