# Task W2.T02 Output Notes - Implement BoxType Enum

**Task ID:** W2.T02
**Title:** Implement BoxType Enum
**Completed:** 2025-11-21
**Time Taken:** ~3 hours (within estimated 3-4 hours)

## Implementation Summary

Successfully implemented the BoxType enum for categorizing CSS boxes by their layout behavior. The implementation provides a clean abstraction between the CSS Display property (external API) and the internal layout algorithm dispatch system.

The BoxType enum simplifies the Display enum by focusing on layout algorithm needs rather than CSS syntax. This allows layout code to pattern match on a smaller set of meaningful categories without worrying about the distinctions between related display values like `flex` and `inline-flex`.

### Key Achievements

1. **BoxType enum** with 12 variants covering all CSS box types
2. **FormattingContextType enum** for identifying which formatting context a box establishes
3. **Conversion from Display** via `From<Display>` trait implementation
4. **Helper methods** for querying box properties (container types, FC generation, type checks)
5. **Comprehensive test coverage** with 22 passing tests
6. **Full documentation** with rustdoc examples for all public APIs

## API Contracts

### BoxType Enum

```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum BoxType {
    Block,
    Inline,
    Text,
    Replaced,
    InlineBlock,
    Flex,
    Grid,
    Table,
    TableRow,
    TableCell,
    TableOther,
    Anonymous,
}
```

### FormattingContextType Enum

```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum FormattingContextType {
    Block,
    Inline,
    Flex,
    Grid,
    Table,
}
```

### Key Methods

```rust
impl BoxType {
    // Container queries
    pub fn is_block_container(self) -> bool;
    pub fn is_inline_container(self) -> bool;

    // Formatting context queries
    pub fn generates_formatting_context(self) -> bool;
    pub fn formatting_context_type(self) -> Option<FormattingContextType>;

    // Type checks
    pub fn is_table_internal(self) -> bool;
    pub fn is_replaced(self) -> bool;
    pub fn is_text(self) -> bool;
    pub fn is_anonymous(self) -> bool;

    // Utility
    pub fn name(self) -> &'static str;
}

impl From<Display> for BoxType;
impl fmt::Display for BoxType;
```

## Decisions Made

### Decision 1: Simplify Display to BoxType

**Choice:** BoxType has 12 variants, fewer than Display's 22 variants

**Rationale:**
- Display represents CSS syntax (many values for web compatibility)
- BoxType represents layout algorithm categories (fewer, more meaningful groups)
- Multiple Display values map to same BoxType when they use the same layout algorithm
- Example: `flex` and `inline-flex` both → BoxType::Flex (outer display handled separately)
- This reduces complexity in layout code and makes pattern matching cleaner

**Impact:**
- Layout algorithms pattern match on BoxType, not Display
- Outer display (block vs inline participation) must be checked via Display separately
- BoxType is the primary dispatch mechanism for layout algorithm selection

### Decision 2: Separate Table Variants

**Choice:** TableRow, TableCell, TableOther as distinct variants (not unified as Table)

**Rationale:**
- Each table-internal type needs different layout algorithm
- TableRow contains cells and handles row sizing
- TableCell contains block content and handles cell sizing
- TableOther includes column groups, captions, etc. with unique behaviors
- Pattern matching is more ergonomic with explicit variants

**Alternatives Considered:**
- Single `Table` variant with sub-type field → Rejected: Less type-safe, worse ergonomics
- Enum within enum → Rejected: Unnecessary complexity

### Decision 3: Anonymous as First-Class Variant

**Choice:** Anonymous is a BoxType variant, not a special case

**Rationale:**
- Anonymous boxes are common and fundamental to CSS layout
- Generated during box generation for spec compliance
- Need to be handled by all layout algorithms
- Not exceptional cases that warrant special handling
- Examples: anonymous block boxes wrapping inline content, anonymous inline boxes

### Decision 4: FormattingContextType Separation

**Choice:** Separate enum for FormattingContextType instead of returning BoxType

**Rationale:**
- FormattingContextType is conceptually distinct from BoxType
- Multiple BoxTypes can establish the same FC type (Block, InlineBlock, TableCell all → Block FC)
- Allows future expansion if new FC types added without changing BoxType
- More semantic: "what FC does it establish" vs "what kind of box is it"

## Spec Interpretations

### Display to BoxType Mapping

**Spec Reference:** CSS Display Module Level 3, CSS 2.1 Chapter 9

**Interpretation:** BoxType represents the inner display type (layout algorithm) while outer display (participation mode) is handled separately by checking the original Display value.

**Reasoning:**
- The CSS spec separates outer and inner display semantics
- BoxType focuses on "what layout algorithm" (inner display)
- Code must check Display separately for "how it participates in parent" (outer display)

**Example:**
```rust
// Both map to BoxType::Flex, but differ in outer participation
Display::Flex → BoxType::Flex (block-level participation)
Display::InlineFlex → BoxType::Flex (inline-level participation)

// Must check Display for outer semantics:
if display.is_block_level() { /* participates as block */ }
else if display.is_inline_level() { /* participates as inline */ }
```

### Contents and None Handling

**Spec Ambiguity:** What BoxType for `display: contents` and `display: none`?

**Interpretation:** Map both to BoxType::Anonymous

**Reasoning:**
- `display: none` should never generate boxes, so box generation should filter it
- `display: contents` generates no box for the element itself (children promoted)
- If these values reach BoxType conversion, it's likely an error or edge case
- Anonymous is the safest fallback that won't crash layout algorithms

**Warning:** If BoxType::Anonymous appears from Contents/None, investigate box generation bug

## Discoveries & Gotchas

### Discovery 1: Outer Display Handled Separately

**What:** BoxType doesn't encode outer display (block vs inline participation)

**Why it matters:** The same BoxType (e.g., Flex) can participate as block-level or inline-level depending on the original Display value

**Recommendation:** Always check the original Display value for outer display semantics

**Example:**
```rust
let box_type = BoxType::from(display);
// box_type alone doesn't tell you if it's block-level or inline-level!

// Must check Display separately:
let is_block_level = display.is_block_level();
let is_inline_level = display.is_inline_level();
```

### Gotcha 1: Contents and None Edge Cases

**Problem:** `display: contents` and `display: none` map to BoxType::Anonymous

**Solution:** Box generation must filter these before creating BoxNode instances

**Warning:** If you see BoxType::Anonymous from a conversion of Contents/None, it indicates a bug in box generation logic

**Correct approach:**
```rust
// In box generation (W3.T01):
if display.is_none() {
    return None; // Don't generate box at all
}

if display == Display::Contents {
    // Special handling: promote children
    return generate_contents_boxes(element);
}

// Only then convert to BoxType
let box_type = BoxType::from(display);
```

### Discovery 2: Block vs Flow-Root Distinction

**What:** Both `display: block` and `display: flow-root` map to BoxType::Block

**Why it matters:** Only flow-root establishes a new BFC; regular block doesn't

**Solution:** Layout code must check Display.establishes_formatting_context() separately

**Example:**
```rust
// Both are BoxType::Block
assert_eq!(BoxType::from(Display::Block), BoxType::Block);
assert_eq!(BoxType::from(Display::FlowRoot), BoxType::Block);

// But only flow-root establishes new BFC
assert!(!Display::Block.establishes_formatting_context());
assert!(Display::FlowRoot.establishes_formatting_context());
```

### Discovery 3: Table Formatting Context Complexity

**What:** Table, TableRow, and TableOther all return FormattingContextType::Table

**Why it matters:** Not all return values mean "establishes" an FC

**Clarification:**
- `BoxType::Table.formatting_context_type()` → Some(Table) - YES, establishes
- `BoxType::TableRow.formatting_context_type()` → Some(Table) - NO, participates in parent's
- Use `generates_formatting_context()` to check if it actually establishes one

## Performance Notes

### Memory Characteristics

- `BoxType`: 1 byte (12 variants fit in u8)
- `FormattingContextType`: 1 byte (5 variants)
- Both derive `Copy` - no heap allocations
- Hash derive enables efficient HashMap/HashSet usage

### Method Performance

- All helper methods are simple matches - O(1) constant time
- No allocations in any method
- Suitable for inlining (compiler decides)
- Safe to call in hot layout loops

### Pattern Matching

- Rust compiles matches on BoxType to jump tables
- Very efficient dispatch for layout algorithm selection
- Much faster than string comparison or dynamic dispatch

## Recommendations for Downstream Tasks

### For W2.T03 (FragmentNode Type):

**Store BoxType in fragments:**
```rust
pub struct FragmentNode {
    pub box_type: BoxType,  // Store for debugging and paint
    // ...
}
```

**Rationale:** Fragments need to know their source box type for painting decisions

### For W2.T07 (FormattingContext Trait):

**Use formatting_context_type() for dispatch:**
```rust
fn layout(&self, box_node: &BoxNode) -> FragmentNode {
    match box_node.box_type.formatting_context_type() {
        Some(FormattingContextType::Block) => self.layout_block(box_node),
        Some(FormattingContextType::Flex) => self.layout_flex(box_node),
        Some(FormattingContextType::Grid) => self.layout_grid(box_node),
        Some(FormattingContextType::Table) => self.layout_table(box_node),
        Some(FormattingContextType::Inline) => self.layout_inline(box_node),
        None => {
            // Text, Replaced, or participates in parent FC
            self.layout_inline_level(box_node)
        }
    }
}
```

**Check generates_formatting_context():**
```rust
if box_node.box_type.generates_formatting_context() {
    // Create new FC - margins don't collapse, contains floats
} else {
    // Participates in parent FC - margins can collapse
}
```

### For W3.T01 (Box Generation):

**Convert Display → BoxType during generation:**
```rust
fn generate_box(element: &Element, styles: &ComputedStyle) -> Option<BoxNode> {
    // Filter special cases BEFORE conversion
    if styles.display.is_none() {
        return None;
    }

    if styles.display == Display::Contents {
        return generate_contents_boxes(element, styles);
    }

    // Now safe to convert
    let box_type = BoxType::from(styles.display);

    Some(BoxNode {
        box_type,
        // ...
    })
}
```

**Create text boxes:**
```rust
fn generate_text_box(text: &str) -> BoxNode {
    BoxNode {
        box_type: BoxType::Text,  // Not from Display
        // ...
    }
}
```

**Create anonymous boxes:**
```rust
fn create_anonymous_block() -> BoxNode {
    BoxNode {
        box_type: BoxType::Anonymous,
        // ...
    }
}
```

### For W3.T04 (Block Layout):

**Only handle block containers:**
```rust
fn can_layout(&self, box_type: BoxType) -> bool {
    box_type.is_block_container()
}
```

**Check FC establishment:**
```rust
fn layout_block(&self, box_node: &BoxNode) -> FragmentNode {
    if box_node.styles.display.establishes_formatting_context() {
        // New BFC - margins don't collapse, floats contained
        self.layout_with_new_bfc(box_node)
    } else {
        // Participates in parent BFC - margins collapse
        self.layout_in_parent_bfc(box_node)
    }
}
```

### For W4.T12 (Inline Layout):

**Handle inline-level boxes:**
```rust
fn can_layout(&self, box_type: BoxType) -> bool {
    matches!(box_type,
        BoxType::Inline | BoxType::Text | BoxType::InlineBlock | BoxType::Replaced
    )
}
```

**Text-specific handling:**
```rust
if box_node.box_type.is_text() {
    // Shape text, create glyphs
    self.shape_text(box_node)
} else if box_node.box_type == BoxType::InlineBlock {
    // Run block layout, treat result as atomic inline
    self.layout_atomic_inline(box_node)
}
```

### For All Layout Tasks:

**Always handle Anonymous:**
```rust
match box_type {
    BoxType::Block => { /* ... */ },
    BoxType::Inline => { /* ... */ },
    // ... other cases ...
    BoxType::Anonymous => {
        // Anonymous boxes inherit layout mode from context
        // Don't panic or unwrap!
    }
}
```

## Open Questions

### Question 1: Inline Formatting Context Type

**Question:** Should BoxType::Inline return FormattingContextType::Inline from formatting_context_type()?

**Current Status:** Returns None

**Reasoning:** Inline boxes don't establish IFCs, they participate in parent's IFC

**Resolution:** Keep as None. Only containers that establish IFCs should return Some(Inline)

### Question 2: Ruby Display Support

**Question:** Do we need BoxType variants for ruby layout?

**Current Status:** Not implemented

**Assigned to:** Future wave if ruby layout is prioritized (rare in western content)

## Test Coverage

### Test Statistics

- **Total tests:** 22
- **Passing:** 22 (100%)
- **Coverage areas:**
  - Display → BoxType conversions (all 22 Display variants)
  - Helper methods (is_block_container, is_inline_container, etc.)
  - Formatting context queries
  - Type checks (is_text, is_replaced, is_anonymous)
  - Edge cases (Contents, None mapping to Anonymous)
  - Equality and copy semantics

### Test Examples

```rust
#[test]
fn test_display_to_boxtype_flex() {
    // Both flex and inline-flex map to Flex
    assert_eq!(BoxType::from(Display::Flex), BoxType::Flex);
    assert_eq!(BoxType::from(Display::InlineFlex), BoxType::Flex);
}

#[test]
fn test_generates_formatting_context() {
    assert!(BoxType::Block.generates_formatting_context());
    assert!(BoxType::Flex.generates_formatting_context());
    assert!(!BoxType::Inline.generates_formatting_context());
}

#[test]
fn test_formatting_context_type() {
    assert_eq!(
        BoxType::Flex.formatting_context_type(),
        Some(FormattingContextType::Flex)
    );
    assert_eq!(BoxType::Inline.formatting_context_type(), None);
}
```

### Coverage Gaps

- **Integration tests:** No tests with actual box generation pipeline
- **Property-based tests:** Could add quickcheck/proptest for invariants
- **Performance tests:** No benchmarks (but all methods are trivial)

**Recommendation:** Add integration tests in W3.T01 (Box Generation) that test Display → BoxType → Layout pipeline

## Code Quality

- ✅ All tests pass (22/22)
- ✅ Clippy clean (no warnings)
- ✅ Rustfmt applied
- ✅ Full rustdoc documentation with examples
- ✅ All examples compile and run
- ✅ Display trait implemented for debugging
- ✅ All expected derives (Debug, Clone, Copy, PartialEq, Eq, Hash)

## File Structure

### Created Files

1. **src/tree/box_type.rs** (690 lines)
   - BoxType enum with full documentation
   - FormattingContextType enum
   - From<Display> implementation
   - All helper methods
   - Comprehensive test suite

2. **outputs/notes/W2.T02-notes.md** (this file)
   - Complete implementation notes
   - Recommendations for downstream tasks

### Modified Files

1. **src/tree/mod.rs**
   - Added `pub mod box_type;`
   - Added re-export `pub use box_type::BoxType;`

## Verification Results

```bash
# Tests
$ cargo test tree::box_type
running 22 tests
test tree::box_type::tests::test_all_display_variants_convert ... ok
test tree::box_type::tests::test_boxtype_copy ... ok
test tree::box_type::tests::test_boxtype_equality ... ok
test tree::box_type::tests::test_display_formatting ... ok
test tree::box_type::tests::test_display_to_boxtype_block ... ok
test tree::box_type::tests::test_display_to_boxtype_flex ... ok
test tree::box_type::tests::test_display_to_boxtype_grid ... ok
test tree::box_type::tests::test_display_to_boxtype_inline ... ok
test tree::box_type::tests::test_display_to_boxtype_inline_block ... ok
test tree::box_type::tests::test_display_to_boxtype_special_cases ... ok
test tree::box_type::tests::test_display_to_boxtype_table ... ok
test tree::box_type::tests::test_display_to_boxtype_table_internals ... ok
test tree::box_type::tests::test_formatting_context_type ... ok
test tree::box_type::tests::test_formatting_context_type_equality ... ok
test tree::box_type::tests::test_generates_formatting_context ... ok
test tree::box_type::tests::test_is_anonymous ... ok
test tree::box_type::tests::test_is_block_container ... ok
test tree::box_type::tests::test_is_inline_container ... ok
test tree::box_type::tests::test_is_replaced ... ok
test tree::box_type::tests::test_is_table_internal ... ok
test tree::box_type::tests::test_is_text ... ok
test tree::box_type::tests::test_name ... ok

test result: ok. 22 passed; 0 failed; 0 ignored

# Clippy
$ cargo clippy -- -D warnings
Finished `dev` profile [unoptimized + debuginfo] target(s)
(no warnings)

# Format
$ cargo fmt --check
(all files formatted correctly)
```

## References Used

1. **CSS Display Module Level 3:** https://www.w3.org/TR/css-display-3/
   - Section 2: Box Layout Modes
   - Section 3: Display Property
2. **CSS 2.1 Section 9:** Visual Formatting Model
   - 9.2: Controlling box generation
   - 9.4: Normal flow
3. **W1.T05-notes.md:** Display enum implementation and recommendations
4. **docs/plan/01-type-system.md:** Architecture guidance for type system
5. **docs/plan/01-box-generation.md:** Box generation algorithm

## Conclusion

Task W2.T02 completed successfully within estimated time. The BoxType enum provides a clean, efficient abstraction for layout algorithm dispatch while maintaining clear separation from CSS syntax concerns.

**Key accomplishments:**
- ✅ Simple, focused API (12 variants vs Display's 22)
- ✅ Type-safe formatting context queries
- ✅ Comprehensive documentation and tests
- ✅ Ready for layout algorithm implementation in Wave 3

**Ready for downstream tasks:**
- W2.T03 (FragmentNode) can use BoxType for fragment categorization
- W2.T07 (FormattingContext) can dispatch based on FormattingContextType
- W3.T01 (Box Generation) can convert Display → BoxType
- W3.T04+ (Layout algorithms) can pattern match on BoxType

**No blockers.** All downstream tasks have clear guidance in the recommendations section above.

---

**Task completed:** 2025-11-21
**Time taken:** ~3 hours
**Tests passing:** 22/22
**Quality checks:** All passed (tests, clippy, fmt)
