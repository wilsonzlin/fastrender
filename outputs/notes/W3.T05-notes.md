# Task W3.T05 Output Notes: Margin Collapsing Algorithm

**Task ID:** W3.T05
**Status:** Complete
**Implementation Date:** 2025-11-22
**Wave:** 3

---

## Implementation Summary

This task implements the CSS 2.1 Section 8.3.1 margin collapsing algorithm, one of the most complex and subtle aspects of CSS block layout. The implementation provides the core data structures and algorithms needed for vertical margin collapse in block formatting contexts.

The implementation consists of three main components:

1. **CollapsibleMargin** - A type that tracks positive and negative margin components separately, enabling correct handling of all CSS margin collapse rules including mixed positive/negative margins.

2. **MarginCollapseContext** - A state tracker used during block layout to accumulate and resolve margins between siblings, through empty blocks, and with clearance.

3. **ParentChildCollapseRules** - A set of static methods that determine when parent-child margin collapse is permitted, based on border, padding, height, and BFC boundaries.

Additionally, helper functions for BFC boundary detection are provided to determine when margins should not collapse across formatting context boundaries.

---

## API Contracts

### CollapsibleMargin

```rust
/// A collapsible margin that tracks positive and negative components
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct CollapsibleMargin {
    pub positive: f32,  // Largest positive margin
    pub negative: f32,  // Most negative margin (stored as absolute value)
}

impl CollapsibleMargin {
    /// Zero margin constant
    pub const ZERO: Self;

    /// Create from raw positive/negative components
    pub fn new(positive: f32, negative: f32) -> Self;

    /// Create from a single margin value
    pub fn from_margin(value: f32) -> Self;

    /// Collapse two margins together
    pub fn collapse_with(self, other: Self) -> Self;

    /// Resolve to final pixel value
    pub fn resolve(self) -> f32;

    /// Check if margin is zero
    pub fn is_zero(self) -> bool;

    /// Add a margin value (convenience method)
    pub fn add_margin(self, value: f32) -> Self;
}
```

### MarginCollapseContext

```rust
/// State tracker for margin collapsing during block layout
#[derive(Debug, Clone)]
pub struct MarginCollapseContext {
    pending_margin: CollapsibleMargin,
    at_start: bool,
    has_clearance: bool,
}

impl MarginCollapseContext {
    /// Create new context (at start of block)
    pub fn new() -> Self;

    /// Create with initial pending margin (for parent-child collapse)
    pub fn with_initial_margin(initial_margin: f32) -> Self;

    /// Process a child's margins, returns (offset, pending)
    pub fn process_child_margins(
        &mut self,
        margin_top: f32,
        margin_bottom: f32,
        is_empty: bool,
    ) -> (f32, CollapsibleMargin);

    /// Process child with clearance (breaks collapse chain)
    pub fn process_child_with_clearance(
        &mut self,
        clearance: f32,
        margin_top: f32,
        margin_bottom: f32,
        is_empty: bool,
    ) -> (f32, CollapsibleMargin);

    /// Get current pending margin
    pub fn pending_margin(&self) -> CollapsibleMargin;

    /// Check if at start of block
    pub fn is_at_start(&self) -> bool;

    /// Add margin to pending
    pub fn add_margin(&mut self, margin: f32);

    /// Consume pending margin, reset to zero
    pub fn consume_pending(&mut self) -> f32;
}
```

### ParentChildCollapseRules

```rust
/// Rules for parent-child margin collapse
pub struct ParentChildCollapseRules;

impl ParentChildCollapseRules {
    /// Check if parent's top can collapse with first child's top
    pub fn can_collapse_top_margins(
        parent_border_top: f32,
        parent_padding_top: f32,
        child_has_clearance: bool,
    ) -> bool;

    /// Check if parent's bottom can collapse with last child's bottom
    pub fn can_collapse_bottom_margins(
        parent_border_bottom: f32,
        parent_padding_bottom: f32,
        parent_has_auto_height: bool,
    ) -> bool;

    /// Check if element's own margins can collapse through
    pub fn can_collapse_through(
        height: Option<f32>,
        min_height: f32,
        padding_top: f32,
        padding_bottom: f32,
        border_top: f32,
        border_bottom: f32,
        has_in_flow_children: bool,
        establishes_bfc: bool,
    ) -> bool;
}
```

### BFC Detection

```rust
/// Check if box establishes BFC from box type
pub fn establishes_bfc(box_node: &BoxNode) -> bool;

/// Check if style properties establish BFC
pub fn style_establishes_bfc(
    overflow_x: Overflow,
    overflow_y: Overflow,
    float: Float,
    position: Position,
) -> bool;

/// Overflow values
pub enum Overflow { Visible, Hidden, Scroll, Auto }

/// Float values
pub enum Float { None, Left, Right }
```

---

## Decisions Made

### Decision 1: Separate Positive/Negative Tracking

**What:** Store positive and negative margin components separately in CollapsibleMargin.

**Rationale:** CSS 2.1 Section 8.3.1 specifies different collapse rules for:
- All positive: take max
- All negative: take min (most negative)
- Mixed: max(positive) + min(negative)

By tracking components separately, we can correctly implement all three cases with a single `collapse_with` operation that just takes max of each component.

**Impact:** Simplifies the collapse algorithm to two max() operations plus a subtraction.

### Decision 2: Context-Based State Tracking

**What:** Use MarginCollapseContext to track state during layout iteration.

**Rationale:** Margin collapse is stateful - the pending margin from one child affects the next. Rather than passing margins around explicitly, encapsulating state in a context object:
- Makes the layout loop cleaner
- Handles edge cases (empty blocks, clearance) internally
- Allows future extension without changing caller code

**Impact:** Block layout code just calls `process_child_margins()` for each child.

### Decision 3: Empty Blocks Return Zero Offset

**What:** When processing an empty block, return 0.0 as the offset.

**Rationale:** Empty blocks don't occupy vertical space - their entire contribution is through margin collapse with adjacent elements. The pending margin accumulates but no vertical advancement occurs.

**Impact:** Caller must not add child height for empty blocks (which is 0 anyway).

### Decision 4: Clearance Consumes Pending Margin

**What:** When an element has clearance, the pending margin is resolved immediately, then clearance is added, then the element's top margin.

**Rationale:** CSS 2.1 Section 9.5.2 specifies that clearance is inserted ABOVE the margin-top. This breaks the collapse chain with previous margins.

**Impact:** The formula becomes: offset = pending.resolve() + clearance + margin_top

### Decision 5: BFC Detection Split Between Box Type and Style

**What:** Provide two functions for BFC detection - one from box type, one from computed style.

**Rationale:** Some BFC triggers are inherent in the box type (inline-block, flex container), while others depend on computed style values (overflow, float, position). During layout, different contexts have access to different information.

**Impact:** Callers should use both checks when determining if margins collapse.

---

## Spec Interpretations

### Interpretation 1: "Most Negative" Means Largest Absolute Value

**Spec:** "the maximum of the collapsing margins' widths" and "If there are no positive margins, the maximum of the absolute values of the negative margins"

**Interpretation:** When collapsing negative margins, we take the one with the largest absolute value (most negative). -30px "wins" over -20px.

**Implementation:** Store negative as absolute value, use max() to find largest.

### Interpretation 2: Empty Block Definition

**Spec:** "margins are adjoining if... the element has zero computed 'min-height', zero or 'auto' computed 'height', and no in-flow children"

**Interpretation:** An element is "empty" for collapse purposes if:
- height is auto or 0
- min-height is 0
- No in-flow children (floats and abspos don't count)
- No border or padding (which would separate margins)

**Implementation:** Caller determines emptiness; we just handle it via `is_empty` parameter.

### Interpretation 3: Clearance Value is Additional

**Spec:** "Clearance is introduced as spacing above the margin-top"

**Interpretation:** Clearance is ADDED to the margin, not replacing it. So for an element with clearance=50px and margin-top=20px, the total space above is 50+20=70px.

**Implementation:** Add clearance and margin_top separately in the offset calculation.

---

## Discoveries & Gotchas

### Gotcha 1: Margins Collapse Through Empty Blocks

Empty blocks don't "block" margin collapse - they let margins pass through. Multiple adjacent empty blocks with margins all collapse together into one margin.

```rust
// Three empty blocks with margins 10, 20, 30
// Result: one 30px margin gap, not three gaps
```

### Gotcha 2: Parent-Child Collapse "Escapes" Parent

When parent's margin collapses with first child's margin, the resulting margin appears OUTSIDE the parent, not inside. This is a common source of CSS bugs.

```css
.parent { margin-top: 10px; }
.child { margin-top: 20px; }
/* Result: 20px above parent, 0px inside parent above child */
```

### Gotcha 3: Negative Margins Can Cause Overlap

When a negative margin is larger (in absolute value) than the positive margin it collapses with, the result is negative, causing visual overlap. This is spec-compliant behavior.

### Gotcha 4: Context Must Track at_start

We need to know if we're at the start of the block to correctly handle first-child margin collapse with parent. After any non-empty child, `at_start` becomes false.

### Gotcha 5: Empty Blocks Preserve at_start

Empty blocks don't count as "content" for at_start purposes. After processing only empty blocks, we're still "at start" for parent-child collapse purposes.

---

## Performance Notes

### Memory

- CollapsibleMargin: 8 bytes (two f32s)
- MarginCollapseContext: 16 bytes (CollapsibleMargin + 2 bools + padding)

Both are Copy types with no heap allocation.

### Time

- `collapse_with`: 2 comparisons (max operations), O(1)
- `resolve`: 1 subtraction, O(1)
- `process_child_margins`: ~10 operations, O(1)

Margin collapse processing is negligible compared to actual layout operations.

### Optimization Opportunities

1. **Short-circuit zero**: Could skip collapse operations when one margin is zero, but the current max-based approach is already fast.

2. **SIMD potential**: CollapsibleMargin operations could potentially be vectorized, but the benefit is minimal given how few operations are involved.

---

## Recommendations for Downstream Tasks

### For W3.T04 (Block Layout)

**Integration Pattern:**

```rust
pub fn layout_children(
    &self,
    parent: &BoxNode,
    constraints: &LayoutConstraints,
) -> Result<Vec<FragmentNode>> {
    let mut fragments = Vec::new();
    let mut current_y = 0.0;
    let mut collapse_ctx = MarginCollapseContext::new();

    // Handle parent-child top margin collapse
    if ParentChildCollapseRules::can_collapse_top_margins(
        parent.style.border_width.top,
        parent.style.padding.top,
        false, // first child clearance checked below
    ) {
        collapse_ctx = MarginCollapseContext::with_initial_margin(
            resolve_margin(&parent.style.margin.top, constraints.available_width)
        );
    }

    for child in &parent.children {
        let child_fragment = self.layout_child(child, constraints)?;

        let margin_top = resolve_margin(&child.style.margin.top, ...);
        let margin_bottom = resolve_margin(&child.style.margin.bottom, ...);
        let is_empty = child_fragment.bounds.height() == 0.0;

        let (offset, _) = collapse_ctx.process_child_margins(
            margin_top,
            margin_bottom,
            is_empty,
        );

        current_y += offset;
        // Position child at current_y
        current_y += child_fragment.bounds.height();

        fragments.push(child_fragment);
    }

    Ok(fragments)
}
```

**Key Points:**
- Create context at start of layout
- Check parent-child collapse conditions before processing children
- Call `process_child_margins()` for each child
- Use returned offset for positioning
- Don't manually add margins - context handles it

### For W3.T10 (Float Layout)

**Clearance Interaction:**

When an element has `clear: left/right/both`, use `process_child_with_clearance()`:

```rust
if child_has_clearance {
    let clearance = compute_clearance(child, float_state);
    let (offset, _) = collapse_ctx.process_child_with_clearance(
        clearance,
        margin_top,
        margin_bottom,
        is_empty,
    );
}
```

Clearance breaks the collapse chain - the element's top margin doesn't collapse with previous margins.

### For W3.T12 (Positioned Layout)

**Absolute Positioning Considerations:**

- Absolutely positioned elements don't participate in margin collapse
- They don't affect the margin collapse state of siblings
- Skip them when iterating through children for collapse purposes

```rust
for child in &parent.children {
    if is_absolutely_positioned(child) {
        // Handle separately, don't touch collapse_ctx
        continue;
    }
    // Normal collapse processing
}
```

---

## Open Questions

### Question 1: Percentage Margin Resolution

**Issue:** Percentage margins are resolved against containing block WIDTH, even for vertical margins. When should this resolution happen?

**Current Assumption:** Caller resolves percentage margins before passing to collapse functions.

**Assigned To:** W3.T04 to handle margin resolution.

### Question 2: Writing Mode Support

**Issue:** In vertical writing modes, "vertical" margins become horizontal and shouldn't collapse.

**Current Status:** Not addressed. Implementation assumes horizontal writing mode.

**Assigned To:** Future writing mode task (W5+).

### Question 3: Flex/Grid Item Margins

**Issue:** Flex and grid items don't collapse margins with siblings.

**Current Status:** The `establishes_bfc` check handles flex/grid containers, but the layout code must also skip collapse for their children.

**Assigned To:** W3.T08 (Flex) and Grid task.

---

## Test Coverage

### Unit Tests (46 tests in src/layout/contexts/block/margin_collapse.rs)

- **CollapsibleMargin creation**: 6 tests
- **Positive margin collapse**: 5 tests
- **Negative margin collapse**: 4 tests
- **Mixed margin collapse**: 6 tests
- **MarginCollapseContext**: 12 tests
- **ParentChildCollapseRules**: 12 tests
- **BFC detection**: 5 tests
- **Edge cases**: 6 tests

### Integration Tests (tests/layout/test_margin_collapse.rs)

Comprehensive test suite covering:
- Basic collapse scenarios
- Sibling collapse
- Empty block collapse
- Parent-child collapse rules
- BFC boundaries
- Clearance interaction
- Edge cases (extreme values, many margins)
- Real-world scenarios (nested divs)

### Test Gaps

1. **No visual tests**: No rendering tests to compare output against browser
2. **No WPT integration**: Not yet integrated with Web Platform Tests
3. **No float interaction tests**: Clearance tests are unit-level only

---

## Files Created

1. **src/layout/contexts/block/margin_collapse.rs** (~1100 lines)
   - CollapsibleMargin type
   - MarginCollapseContext state tracker
   - ParentChildCollapseRules methods
   - BFC detection functions
   - Overflow and Float enums
   - Comprehensive unit tests

2. **src/layout/contexts/block/mod.rs** (~40 lines)
   - Module declaration
   - Re-exports

3. **tests/layout/test_margin_collapse.rs** (~700 lines)
   - Integration tests organized by category
   - Edge case coverage

4. **tests/layout/mod.rs** (~3 lines)
   - Test module declaration

5. **Updated: src/layout/contexts/mod.rs**
   - Added block module

---

## Verification Results

```
Task: W3.T05 - Implement Margin Collapsing Algorithm
Status: COMPLETE

Verification:
 cargo build - SUCCESS
 cargo test margin_collapse - 46/46 tests passed
 cargo clippy - no warnings (in our code)
 cargo fmt --check - formatted correctly

Files Created:
 src/layout/contexts/block/margin_collapse.rs (~1100 lines)
 src/layout/contexts/block/mod.rs (~40 lines)
 tests/layout/test_margin_collapse.rs (~700 lines)
 tests/layout/mod.rs (~3 lines)
 outputs/notes/W3.T05-notes.md (this file)

Notes: All objectives achieved. API is complete and documented.
Comprehensive recommendations written for W3.T04, W3.T10, and W3.T12.
No blockers. Ready for dependent tasks to begin.
```

---

## CSS Specification References

- **CSS 2.1 Section 8.3.1**: Collapsing margins
  https://www.w3.org/TR/CSS21/box.html#collapsing-margins

- **CSS 2.1 Section 9.4.1**: Block formatting contexts
  https://www.w3.org/TR/CSS21/visuren.html#block-formatting

- **CSS 2.1 Section 9.5.2**: Controlling flow next to floats (clearance)
  https://www.w3.org/TR/CSS21/visuren.html#flow-control

---

**Last Updated:** 2025-11-22
**Author:** Claude (AI Agent)
**Task System:** FastRender V2 Parallel Rebuild
