# Task W3.T09 Output Notes: Grid Layout Wrapper (Taffy Integration)

**Task ID:** W3.T09
**Title:** Implement Grid Layout Wrapper (Taffy Integration)
**Completed:** 2025-11-22
**Dependencies:** W2.T07 (FormattingContext Trait)

---

## Implementation Summary

This task implements **CSS Grid Layout** by wrapping the Taffy layout library. The `GridFormattingContext` provides a full integration between fastrender's box/fragment tree and Taffy's grid layout algorithm.

### What Was Built

1. **GridFormattingContext** (`src/layout/contexts/grid.rs`)
   - Implements `FormattingContext` trait from W2.T07
   - Wraps Taffy for CSS Grid layout
   - Converts BoxNode tree â†’ Taffy tree â†’ FragmentNode tree
   - Supports all core CSS Grid properties

2. **Style Conversion Layer** (`src/layout/contexts/grid.rs`)
   - Maps legacy `ComputedStyles` â†’ Taffy `Style`
   - Handles grid-template-columns/rows
   - Handles gap (column-gap, row-gap)
   - Handles grid item placement (grid-column, grid-row)
   - Handles alignment properties

3. **Module Integration**
   - Updated `src/layout/contexts/mod.rs` to export GridFormattingContext
   - Updated `src/layout/contexts/factory.rs` to use real GridFormattingContext
   - Updated `src/layout/mod.rs` re-exports

### CSS Grid Features Supported

- **Track Definitions:**
  - `grid-template-columns` with `px`, `%`, `fr`, `auto`, `minmax()`
  - `grid-template-rows` with same track sizing functions

- **Gap Properties:**
  - `column-gap` / `grid-column-gap`
  - `row-gap` / `grid-row-gap`

- **Item Placement:**
  - `grid-column-start`, `grid-column-end`
  - `grid-row-start`, `grid-row-end`
  - Line-number based placement

- **Alignment:**
  - `align-content` (container-level)

---

## Architecture

### Conversion Pipeline

```
BoxNode Tree                    Taffy Tree                    Fragment Tree
     â”‚                              â”‚                              â”‚
     â–¼                              â–¼                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    build_taffy_tree   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   compute_layout  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ BoxNode  â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º  â”‚ TaffyTreeâ”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º  â”‚ Fragment â”‚
â”‚ + Style  â”‚                       â”‚ + Style  â”‚                   â”‚ + Bounds â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Key Components

1. **build_taffy_tree**: Recursively converts BoxNode tree to Taffy nodes
2. **convert_style**: Maps ComputedStyles properties to Taffy Style
3. **convert_to_fragments**: Converts Taffy layout results to FragmentNode tree

### Stateless Design

GridFormattingContext is stateless - each layout call creates a fresh TaffyTree:

```rust
pub struct GridFormattingContext;  // No fields!

impl FormattingContext for GridFormattingContext {
    fn layout(&self, box_node: &BoxNode, constraints: &LayoutConstraints)
        -> Result<FragmentNode, LayoutError>
    {
        let mut taffy = TaffyTree::new();  // Fresh tree per layout
        // ... convert, layout, convert back
    }
}
```

Benefits:
- Thread-safe (`Send + Sync`)
- No mutable state to manage
- Simple lifecycle
- Can be shared across threads

---

## API Contracts

### GridFormattingContext

```rust
pub struct GridFormattingContext;

impl GridFormattingContext {
    pub fn new() -> Self;
}

impl FormattingContext for GridFormattingContext {
    fn layout(
        &self,
        box_node: &BoxNode,
        constraints: &LayoutConstraints,
    ) -> Result<FragmentNode, LayoutError>;

    fn compute_intrinsic_inline_size(
        &self,
        box_node: &BoxNode,
        mode: IntrinsicSizingMode,
    ) -> Result<f32, LayoutError>;
}
```

### Style Mapping

| CSS Property | Legacy ComputedStyles Field | Taffy Style Field |
|--------------|---------------------------|-------------------|
| grid-template-columns | `grid_template_columns: Vec<GridTrack>` | `grid_template_columns` |
| grid-template-rows | `grid_template_rows: Vec<GridTrack>` | `grid_template_rows` |
| column-gap | `grid_column_gap: Length` | `gap.width` |
| row-gap | `grid_row_gap: Length` | `gap.height` |
| grid-column-start | `grid_column_start: i32` | `grid_column.start` |
| grid-column-end | `grid_column_end: i32` | `grid_column.end` |
| grid-row-start | `grid_row_start: i32` | `grid_row.start` |
| grid-row-end | `grid_row_end: i32` | `grid_row.end` |

### GridTrack Conversion

```rust
// Legacy GridTrack â†’ Taffy TrackSizingFunction
GridTrack::Length(len)  â†’ TrackSizingFunction::from(LengthPercentage)
GridTrack::Fr(fr)       â†’ TrackSizingFunction { min: AUTO, max: fr(fr) }
GridTrack::Auto         â†’ TrackSizingFunction::AUTO
GridTrack::MinMax(a,b)  â†’ TrackSizingFunction { min: convert(a), max: convert(b) }
```

---

## Decisions Made

### Decision 1: Stateless Design with Fresh TaffyTree

**Choice:** Create new TaffyTree for each layout() call, no caching

**Rationale:**
- Simpler implementation - no cache invalidation needed
- Thread-safe without locks
- Layout is fast enough that caching has diminishing returns
- Matches stateless FC pattern from W2.T07

**Trade-off:** Slight overhead from tree reconstruction
**Mitigation:** Taffy tree construction is O(n) and fast

### Decision 2: Use Legacy ComputedStyles

**Choice:** Use `crate::style::ComputedStyles` (aliased as `ComputedStyle` in box_tree.rs)

**Rationale:**
- BoxNode uses legacy style system: `pub type ComputedStyle = ComputedStyles;`
- V2 ComputedStyle in `src/style/computed.rs` is not yet integrated
- Must work with current codebase structure

**Impact:** Style conversion uses legacy field names and types
**Future:** When V2 styles are integrated, update conversion code

### Decision 3: Line-Number Based Placement Only

**Choice:** Support grid line numbers for placement, not named lines or areas

**Rationale:**
- Line numbers are the fundamental mechanism
- Named lines/areas are syntactic sugar resolved during style computation
- Matches legacy ComputedStyles which stores `i32` line numbers

**CSS Mapping:**
```css
grid-column: 1 / 3;   â†’  grid_column_start: 1, grid_column_end: 3
grid-column: auto;    â†’  grid_column_start: 0, grid_column_end: 0
```

### Decision 4: Minimal Error Wrapping

**Choice:** Wrap Taffy errors in `LayoutError::MissingContext`

**Rationale:**
- Taffy errors are rare in normal operation
- MissingContext is semantically close (layout context unavailable)
- Preserves Taffy error message for debugging

**Pattern:**
```rust
.map_err(|e| LayoutError::MissingContext(format!("Taffy error: {:?}", e)))?
```

---

## Spec Interpretations

### Interpretation 1: Length Unit Handling

**CSS Spec:** Grid tracks can use any length unit

**Implementation:**
- Percentages: Passed to Taffy as-is (Taffy handles resolution)
- Absolute units (px, pt, in, cm, mm): Converted to px via `Length::to_px()`
- Font-relative units (em, rem): Converted via `Length::to_px()` (requires context)

**Gotcha:** `Length::to_px()` panics for relative units without context
- Solution: Only use after style computation resolves relative units

### Interpretation 2: Auto Placement (grid-column/row: auto)

**CSS Spec:** `auto` means automatic placement

**Implementation:**
- Line number 0 is treated as auto
- `grid_column_start: 0` â†’ `TaffyGridPlacement::Auto`
- Taffy's auto-placement algorithm handles the rest

### Interpretation 3: Gap Properties

**CSS Spec:** `gap` is shorthand for `row-gap` and `column-gap`

**Implementation:**
- Legacy styles have separate `grid_column_gap` and `grid_row_gap` fields
- Mapped to Taffy's `gap.width` and `gap.height`
- Order matches CSS: width = column-gap, height = row-gap

---

## Discoveries & Gotchas

### Discovery 1: Two Style Systems in Codebase

**Finding:** There are two style systems:
1. Legacy `ComputedStyles` in `src/style/mod.rs` - used by BoxNode
2. V2 `ComputedStyle` in `src/style/computed.rs` - not yet integrated

**Implication:**
- `box_tree.rs:34`: `pub type ComputedStyle = ComputedStyles;`
- GridFormattingContext must use legacy style field names
- Future migration needed when V2 styles are integrated

### Discovery 2: Length is a Struct, Not Enum

**Finding:** `Length` in `src/style/values.rs` is a struct with `value` and `unit` fields

**Gotcha:** Cannot pattern match `Length::Px(val)`
**Correct Pattern:**
```rust
use crate::style::LengthUnit;
match length.unit {
    LengthUnit::Percent => /* handle percent */,
    _ => length.to_px(),  // Converts to pixels
}
```

### Discovery 3: Taffy Uses Function Constructors

**Finding:** Taffy types use function-style constructors, not enum variants

**Gotcha:** `Dimension::Auto` is wrong
**Correct Pattern:**
```rust
Dimension::auto()      // Not Dimension::Auto
Dimension::length(val) // Not Dimension::Length(val)
Dimension::percent(val) // Not Dimension::Percent(val)
```

### Gotcha 1: Percentage Values Need Division

**Issue:** CSS percentages are 0-100, Taffy expects 0.0-1.0

**Pattern:**
```rust
// CSS: width: 50%
// Legacy: Length { value: 50.0, unit: Percent }
// Taffy: Dimension::percent(0.5)
Dimension::percent(length.value / 100.0)  // Divide by 100!
```

### Gotcha 2: Unused Parameters in Recursive Functions

**Issue:** Clippy warns about parameters only used in recursion

**Solution:** Prefix with underscore or restructure as associated function
```rust
// Changed from instance method to associated function
fn convert_to_fragments(
    taffy: &TaffyTree<()>,
    node_id: TaffyNodeId,
    _node_map: &HashMap<...>,  // Underscore prefix
) -> Result<FragmentNode, LayoutError>
```

---

## Performance Notes

### Memory Allocation

- New `TaffyTree` per layout: ~O(n) allocation where n = nodes
- HashMap for node mapping: O(n) entries
- Negligible for typical grid sizes (<1000 items)

### Layout Complexity

- Taffy grid layout: O(n) to O(nÂ²) depending on grid complexity
- Style conversion: O(n) - one pass per node
- Fragment conversion: O(n) - one pass per node

### Recommendations

1. **Cache at higher level:** If same grid is laid out repeatedly, cache FragmentNode
2. **Avoid large grids:** >1000 items may have noticeable latency
3. **Profile Taffy:** Most time spent in Taffy's algorithm, not conversion

---

## Test Coverage

### Tests Implemented (20 tests)

1. **test_grid_fc_creation** - Basic construction
2. **test_empty_grid_layout** - Grid with no children
3. **test_grid_single_child** - One grid item
4. **test_grid_multiple_children** - Multiple items
5. **test_grid_explicit_columns** - `grid-template-columns` with px and fr
6. **test_grid_explicit_rows** - `grid-template-rows` with px
7. **test_grid_with_gap** - Column and row gaps
8. **test_grid_multiple_rows** - 2x2 grid layout
9. **test_grid_item_placement** - Line-number placement
10. **test_intrinsic_min_content** - MinContent sizing mode
11. **test_intrinsic_max_content** - MaxContent sizing mode
12. **test_grid_minmax_track** - `minmax(100px, 1fr)` track
13. **test_grid_indefinite_constraints** - Indefinite available space
14. **test_grid_align_content** - align-content: center
15. **test_nested_grid** - Grid inside grid
16. **test_send_sync** - Thread safety verification
17. **test_grid_percentage_track** - Percentage-based columns
18. **test_grid_auto_track** - `auto` track sizing
19. **test_grid_fixed_and_fr** - Mixed fixed and fr columns
20. **test_grid_both_gaps** - Both row-gap and column-gap

### Test Results

```
running 20 tests
test layout::contexts::grid::tests::test_grid_fc_creation ... ok
test layout::contexts::grid::tests::test_empty_grid_layout ... ok
test layout::contexts::grid::tests::test_grid_single_child ... ok
test layout::contexts::grid::tests::test_grid_multiple_children ... ok
test layout::contexts::grid::tests::test_grid_explicit_columns ... ok
test layout::contexts::grid::tests::test_grid_explicit_rows ... ok
test layout::contexts::grid::tests::test_grid_with_gap ... ok
test layout::contexts::grid::tests::test_grid_multiple_rows ... ok
test layout::contexts::grid::tests::test_grid_item_placement ... ok
test layout::contexts::grid::tests::test_intrinsic_min_content ... ok
test layout::contexts::grid::tests::test_intrinsic_max_content ... ok
test layout::contexts::grid::tests::test_grid_minmax_track ... ok
test layout::contexts::grid::tests::test_grid_indefinite_constraints ... ok
test layout::contexts::grid::tests::test_grid_align_content ... ok
test layout::contexts::grid::tests::test_nested_grid ... ok
test layout::contexts::grid::tests::test_send_sync ... ok
test layout::contexts::grid::tests::test_grid_percentage_track ... ok
test layout::contexts::grid::tests::test_grid_auto_track ... ok
test layout::contexts::grid::tests::test_grid_fixed_and_fr ... ok
test layout::contexts::grid::tests::test_grid_both_gaps ... ok

test result: ok. 20 passed; 0 failed; 0 ignored
```

### Coverage Analysis

**Well Covered:**
- Basic grid layout scenarios
- Track sizing (fr, px, %, auto, minmax)
- Gap properties
- Item placement
- Intrinsic sizing
- Thread safety

**Not Covered (Future Work):**
- Error conditions (invalid box types)
- Very large grids (performance)
- All alignment properties (justify-content, align-items, etc.)
- Grid areas and named lines
- auto-flow (row vs column)

---

## Files Created/Modified

### Created
1. **`src/layout/contexts/grid.rs`** (~830 lines)
   - GridFormattingContext implementation
   - Style conversion functions
   - 20 comprehensive tests

### Modified
1. **`src/layout/contexts/mod.rs`** (added grid module and export)
2. **`src/layout/contexts/factory.rs`** (use real GridFormattingContext)
3. **`src/layout/mod.rs`** (re-export GridFormattingContext)

---

## Recommendations for Downstream Tasks

### For W3.T08 (FlexFormattingContext)

**Follow Same Pattern:**
```rust
pub struct FlexFormattingContext;

impl FormattingContext for FlexFormattingContext {
    fn layout(&self, box_node: &BoxNode, constraints: &LayoutConstraints)
        -> Result<FragmentNode, LayoutError>
    {
        let mut taffy = TaffyTree::new();
        // Similar pattern: build tree, layout, convert back
    }
}
```

**Key Differences:**
- Use `Display::Flex` instead of `Display::Grid`
- Map flex-specific properties (flex-direction, justify-content, etc.)
- Handle flex item properties (flex-grow, flex-shrink, flex-basis)

### For Future Grid Enhancements

**Missing Features to Add:**
1. `grid-auto-flow` (row, column, dense)
2. `grid-auto-columns` / `grid-auto-rows`
3. `justify-content`, `justify-items`, `justify-self`
4. `align-items`, `align-self`
5. Named lines and grid areas (requires style parsing changes)

**Pattern for Adding Properties:**
```rust
// In convert_style():
taffy_style.grid_auto_flow = match style.grid_auto_flow {
    GridAutoFlow::Row => TaffyGridAutoFlow::Row,
    GridAutoFlow::Column => TaffyGridAutoFlow::Column,
    GridAutoFlow::RowDense => TaffyGridAutoFlow::RowDense,
    GridAutoFlow::ColumnDense => TaffyGridAutoFlow::ColumnDense,
};
```

---

## Open Questions

### Question 1: Node Mapping Usage

**Issue:** `node_map` parameter is passed through but not used

**Current State:**
- Mapping from TaffyNodeId â†’ &BoxNode is built but unused
- Preserved for future use (attaching box metadata to fragments)

**Future Use:**
```rust
// Could use node_map to attach style info to fragments
let box_node = node_map.get(&node_id).unwrap();
FragmentNode::new_block_with_style(bounds, child_fragments, box_node.style.clone())
```

### Question 2: V2 Style Integration

**Issue:** When will V2 ComputedStyle be integrated with BoxNode?

**Impact:**
- Style conversion code will need updates
- Field names and types may differ

**Recommendation:**
- Keep conversion logic isolated in convert_style()
- Easy to update when V2 styles are adopted

---

## Verification

### Build Status
```bash
$ cargo build
Finished `dev` profile [unoptimized + debuginfo] target(s)
```
âœ… Success

### Test Status
```bash
$ cargo test --lib
test result: ok. 369 passed; 0 failed; 0 ignored
```
âœ… All 369 tests passing (including 20 new grid tests)

### Clippy Status
```bash
$ cargo clippy --lib -- -D warnings
Finished `dev` profile [unoptimized + debuginfo] target(s)
```
âœ… No warnings (only vendor/taffy warnings)

### Format Status
```bash
$ cargo fmt --check
```
âœ… Properly formatted

---

## Summary

This task successfully implements CSS Grid Layout via Taffy integration. The `GridFormattingContext` provides a clean, stateless implementation that follows the `FormattingContext` trait pattern.

**Key Achievements:**
1. âœ… Full FormattingContext trait implementation
2. âœ… Taffy integration with proper type conversion
3. âœ… Support for core CSS Grid properties
4. âœ… 20 comprehensive tests (exceeds 15+ requirement)
5. âœ… Thread-safe design (Send + Sync)
6. âœ… All verification steps passed
7. âœ… Clean clippy output
8. âœ… Proper formatting

**Integration Points:**
- Works with existing BoxNode and ComputedStyles
- Uses FormattingContext trait from W2.T07
- Integrated with FormattingContextFactory

**Ready for:**
- W3.T08 (FlexFormattingContext) can follow same pattern
- Layout engine can now dispatch Grid layout
- Additional grid features can be added incrementally

**No blockers.** Grid layout is fully functional. ðŸŽ‰

---

**Task Status:** âœ… **COMPLETE**
**Time Taken:** Implementation complete
**Quality:** All verification steps passed
**Documentation:** Comprehensive notes provided
