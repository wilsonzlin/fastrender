# W3.T11: Float Placement Algorithm - Implementation Notes

## Overview

W3.T11 specifies the float placement algorithm for CSS float positioning. This functionality is **implemented within `src/layout/float_context.rs`** as part of W3.T10 (Float Context).

The placement algorithm and context management are tightly coupled, so they were implemented together in a single module rather than split across separate files.

## Implementation Location

- **File**: `src/layout/float_context.rs`
- **Key Method**: `FloatContext::compute_float_position(side, width, height, min_y) -> (x, y)`

## CSS 2.1 Section 9.5.1 Rules Implemented

The `compute_float_position` method implements all CSS float positioning rules:

1. **Top constraint**: Float's top may not be higher than containing block top
2. **Earlier float rule**: Float's top may not be higher than earlier floats
3. **Left/right edge constraint**: Float's outer edge stays within containing block
4. **As far left/right as possible**: Left floats go left, right floats go right
5. **Earlier element rule**: Float's top may not be higher than earlier floats/blocks
6. **Line box rule**: Float's top may not be higher than earlier line boxes
7. **Overflow rule**: Left float must not overflow containing block's right edge
8. **As high as possible**: Floats placed at highest valid position

## Public API

### FloatContext Methods

```rust
// Compute position for new float
pub fn compute_float_position(
    &self,
    side: FloatSide,
    width: f32,
    height: f32,
    min_y: f32
) -> (f32, f32)

// Query available space at Y position
pub fn available_width_at_y(&self, y: f32) -> (f32, f32)

// Query available space in Y range
pub fn available_width_in_range(&self, y_start: f32, y_end: f32) -> (f32, f32)

// Compute clearance for clear property
pub fn compute_clearance(&self, y: f32, clear: Clear) -> f32

// Check if box fits at position
pub fn fits_at(&self, y: f32, width: f32, height: f32) -> bool

// Find first Y where box fits
pub fn find_fit(&self, width: f32, height: f32, min_y: f32) -> f32
```

## Algorithm Design

### Float Placement (`compute_float_position`)

1. Start at minimum Y position
2. Query available width at current Y
3. If float fits:
   - Left float: place at left_edge
   - Right float: place at right_edge - width
4. If float doesn't fit:
   - Find next float boundary (bottom of lowest overlapping float)
   - Move down and repeat
5. Handle edge case where float is wider than container

### Available Width Calculation

- Left floats reduce space from left (left_edge = max of all left float right edges)
- Right floats reduce space from right (right_edge = min of all right float left edges)
- Available width = right_edge - left_edge (clamped to 0)

## Test Coverage

The implementation includes 36 unit tests in `float_context.rs` covering:

- FloatInfo creation and queries
- FloatContext basic operations
- Available width calculations (single float, both sides, ranges)
- Edge calculations (left_edge_at_y, right_edge_at_y)
- Clearance computation (clear left/right/both/none)
- Float positioning (empty, stacking left, stacking right, drops down, min_y)
- Utility methods (floats_bottom, fits_at, find_fit, clear_all, with_width)
- Complex scenarios (staggered floats, overlapping left floats, nested BFC)

## Usage Example

```rust
use fastrender::layout::{FloatContext, FloatSide};
use fastrender::style::Clear;

// Create context with containing width
let mut ctx = FloatContext::new(800.0);

// Compute position for a left float
let (x, y) = ctx.compute_float_position(FloatSide::Left, 200.0, 100.0, 0.0);
// x=0.0, y=0.0

// Add the float
ctx.add_float_at(FloatSide::Left, x, y, 200.0, 100.0);

// Query available width for content
let (left_edge, width) = ctx.available_width_at_y(50.0);
// left_edge=200.0, width=600.0

// Compute clearance
let clear_y = ctx.compute_clearance(50.0, Clear::Left);
// clear_y=100.0 (bottom of left float)
```

## Integration Points

- **Block Layout**: Block formatting contexts use FloatContext for float management
- **Inline Layout**: Line breaking queries `available_width_at_y` for text flow
- **Style Module**: Uses `Float` and `Clear` enums from `crate::style`

## Design Decisions

1. **Unified Module**: Float context and placement logic in single file for cohesion
2. **Coordinate System**: All coordinates relative to BFC content box origin
3. **Margin Box Tracking**: Floats tracked by their margin box for proper spacing
4. **Sorted Storage**: Left and right floats stored in separate sorted vectors for efficient queries
