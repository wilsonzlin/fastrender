# W3.T12: Positioned Layout Base - Implementation Notes

## Task Summary

Implemented the base infrastructure for CSS positioned layout, covering:
- **Position types**: Static, Relative, Absolute, Fixed, Sticky
- **Relative positioning**: Offset from normal flow position
- **Absolute positioning**: Position and size calculation
- **Containing block determination**: Per CSS specification
- **Stacking context detection**: For z-index ordering
- **Sticky constraints**: For scroll-dependent behavior

## Files Created

1. **`src/layout/contexts/positioned.rs`** - Core implementation
2. **`tests/layout/test_positioned.rs`** - Comprehensive integration tests
3. **`outputs/notes/W3.T12-notes.md`** - This file

## Architecture Decisions

### 1. PositionedLayout is NOT a FormattingContext

This is a key architectural insight. Positioned layout is a **post-process** that adjusts positions after normal layout, not a standalone formatting context.

```rust
// Correct mental model:
// 1. Block/Inline/Flex layout computes size and initial position
// 2. PositionedLayout adjusts position based on offsets
```

Rationale:
- Positioned elements still participate in their parent's layout (for relative)
- The size/position calculation is separate from child layout
- Cleaner separation of concerns

### 2. Reused Existing Position Enum

Instead of creating a duplicate `PositionType` enum, we reuse the existing `Position` enum from `src/style/position.rs`. This avoids:
- Code duplication
- Potential inconsistencies
- Conversion overhead

### 3. ContainingBlock Abstraction

Created a dedicated `ContainingBlock` struct that encapsulates:
- The rectangle (origin + size)
- Factory methods for different use cases

This makes the API cleaner and more type-safe.

### 4. StickyConstraints for Render-Time Behavior

Sticky positioning is computed at layout time but applied at render time based on scroll position. We extract the constraints during layout and store them for the renderer.

## CSS Specification Compliance

### Relative Positioning (CSS 2.1 Section 9.3.2)

- Element is offset from its normal flow position
- Original space is preserved in document flow
- `top` takes precedence over `bottom` (horizontal writing mode)
- `left` takes precedence over `right` (LTR)

### Absolute Positioning (CSS 2.1 Section 10.3.7, 10.6.4)

The constraint equations are implemented:
```
left + margin-left + border-left + padding-left + width +
padding-right + border-right + margin-right + right = CB width
```

Cases handled:
1. All specified → ignore `right`/`bottom` (overconstrained)
2. `left` + `width` → compute from left
3. `right` + `width` → compute from right
4. `left` + `right` → stretch width/height
5. Only `left`/`top` → use intrinsic size
6. Only `right`/`bottom` → position from far edge
7. Only `width`/`height` → use static position
8. All auto → static position + intrinsic size

### Containing Block Determination (CSS 2.1 Section 10.1)

| Position | Containing Block |
|----------|-----------------|
| static   | Content box of nearest block container ancestor |
| relative | Content box of nearest block container ancestor |
| sticky   | Content box of nearest block container ancestor |
| absolute | Padding box of nearest positioned ancestor |
| fixed    | Viewport (initial containing block) |

### Stacking Context Creation

An element creates a stacking context if:
- `position != static` AND `z-index != auto`
- `opacity < 1`
- (Future: `transform`, `filter`, `isolation`, etc.)

## API Overview

### Core Types

```rust
/// Containing block for positioned elements
pub struct ContainingBlock {
    pub rect: Rect,
}

/// Sticky positioning constraints
pub struct StickyConstraints {
    pub top: Option<f32>,
    pub right: Option<f32>,
    pub bottom: Option<f32>,
    pub left: Option<f32>,
}

/// Main positioned layout handler
pub struct PositionedLayout;
```

### Key Methods

```rust
impl PositionedLayout {
    /// Apply relative positioning offset
    pub fn apply_relative_positioning(
        &self,
        fragment: &FragmentNode,
        style: &ComputedStyle,
        containing_block: &ContainingBlock,
    ) -> Result<FragmentNode, LayoutError>;

    /// Compute absolute position and size
    pub fn compute_absolute_position(
        &self,
        style: &ComputedStyle,
        containing_block: &ContainingBlock,
        intrinsic_size: Size,
    ) -> Result<(Point, Size), LayoutError>;

    /// Determine containing block for element
    pub fn determine_containing_block(
        &self,
        position: Position,
        viewport_size: Size,
        positioned_ancestor_rect: Option<Rect>,
        block_ancestor_rect: Option<Rect>,
    ) -> ContainingBlock;

    /// Check if element creates stacking context
    pub fn creates_stacking_context(&self, style: &ComputedStyle) -> bool;
}
```

## Test Coverage

### Unit Tests (in positioned.rs)
- 30+ tests covering all functionality
- ContainingBlock creation and accessors
- StickyConstraints building
- Relative positioning all combinations
- Absolute positioning all cases
- Containing block determination
- Stacking context detection

### Integration Tests (in test_positioned.rs)
- 45+ additional tests
- End-to-end scenario testing
- Edge cases (zero size, large values)
- Comprehensive relative positioning
- Comprehensive absolute positioning
- All containing block cases

## Integration Points

### With BoxNode
```rust
// BoxNode provides computed style
let style = &box_node.style;
```

### With FragmentNode
```rust
// FragmentNode gets adjusted bounds
let adjusted = layout.apply_relative_positioning(&fragment, &style, &cb)?;
```

### With LayoutEngine
```rust
// Engine determines containing blocks during tree traversal
let cb = layout.determine_containing_block(
    style.position,
    viewport_size,
    positioned_ancestor,
    block_ancestor,
);
```

## Future Work

### W3.T13: Full Absolute Layout
- Integration with LayoutEngine for tree traversal
- Ancestor tracking for containing block lookup
- Out-of-flow element collection and deferred layout

### W3.T14: Fixed Positioning
- Viewport attachment
- Scroll-independent rendering

### W3.T15: Sticky Positioning
- Scroll container tracking
- Dynamic constraint application during rendering
- Intersection with scrollable overflow

### Additional Considerations
- RTL text direction (right takes precedence over left)
- Vertical writing modes (block/inline axis mapping)
- Transform on containing block ancestors

## Dependencies

- Uses `Position` from `src/style/position.rs` (W2.T07)
- Uses `FragmentNode` from `src/tree/fragment_tree.rs` (W2.T06)
- Uses `ComputedStyle` from `src/style/computed.rs`
- Uses geometry types from `src/geometry.rs`
- Uses `LayoutError` from `src/layout/formatting_context.rs` (W2.T07)

## Performance Considerations

1. **Stateless Design**: `PositionedLayout` has no internal state, enabling:
   - Zero-cost cloning
   - Sharing across threads
   - No synchronization overhead

2. **Minimal Allocations**:
   - Offset computation is stack-only
   - Fragment cloning only when position changes

3. **Early Exit**: Static positioned elements return immediately

## Verification Checklist

- [x] Builds without errors
- [x] All unit tests pass
- [x] All integration tests pass
- [x] No clippy warnings
- [x] Code formatted with rustfmt
- [x] Documentation complete
