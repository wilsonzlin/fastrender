# W5.T11: Counter System Implementation Notes

## Overview

Implemented a comprehensive CSS Counter System as specified in CSS Lists and Counters Module Level 3. The system manages CSS counters during document tree traversal and provides support for:

- `counter-reset` - Create/reset counter instances
- `counter-increment` - Increment counter values
- `counter-set` - Set counter values directly
- `counter()` - Format a single counter value
- `counters()` - Format nested counter values with separators

## Files Created

- `src/style/counters.rs` - Core counter system implementation
- `tests/test_counters.rs` - Comprehensive integration tests (74 tests)

## Files Modified

- `src/style/mod.rs` - Added module export and re-exports

## Architecture

### Core Types

#### `CounterSet`
Represents a list of counter specifications for CSS properties:

```rust
// Parse counter-reset: chapter 0 section 0
let set = CounterSet::parse_reset("chapter 0 section 0").unwrap();

// Parse counter-increment: chapter (defaults to +1)
let inc = CounterSet::parse_increment("chapter").unwrap();

// Single counter
let single = CounterSet::single("chapter", 0);
```

#### `CounterSetItem`
A single counter name-value pair:

```rust
pub struct CounterSetItem {
    pub name: String,
    pub value: i32,
}
```

#### `CounterManager`
Manages counter scopes during tree traversal:

```rust
let mut manager = CounterManager::new();

// Enter element scope
manager.enter_scope();
manager.apply_reset(&CounterSet::single("chapter", 0));
manager.apply_increment(&CounterSet::single("chapter", 1));

// Get counter value
let value = manager.get("chapter"); // Some(1)

// Format for display
let formatted = manager.format("chapter", CounterStyle::Decimal); // "1"

// Leave scope
manager.leave_scope();
```

#### `CounterProperties`
Aggregates counter properties for a single element:

```rust
pub struct CounterProperties {
    pub counter_reset: Option<CounterSet>,
    pub counter_increment: Option<CounterSet>,
    pub counter_set: Option<CounterSet>,
}
```

## CSS Scoping Rules

Per CSS specification:

1. **`counter-reset`** creates a new counter instance in the current scope, shadowing any counter with the same name in ancestor scopes.

2. **`counter-increment`** modifies the innermost counter with that name. If no counter exists, one is implicitly created with value 0 and then incremented.

3. **`counter-set`** modifies the innermost counter without creating a new scope.

4. Counter scopes follow DOM tree structure - a counter reset on an element is visible to that element's descendants.

## Counter Styles

The system integrates with `CounterStyle` from `src/style/content.rs`:

- `Decimal` - 1, 2, 3...
- `LowerAlpha` - a, b, c...
- `UpperAlpha` - A, B, C...
- `LowerRoman` - i, ii, iii, iv...
- `UpperRoman` - I, II, III, IV...
- `Disc`, `Circle`, `Square` - List markers

## Usage Patterns

### Chapter/Section Numbering
```css
body { counter-reset: chapter; }
.chapter { counter-increment: chapter; counter-reset: section; }
.section { counter-increment: section; }
```

```rust
// body
manager.enter_scope();
manager.apply_reset(&CounterSet::single("chapter", 0));

// Chapter 1
manager.enter_scope();
manager.apply_increment(&CounterSet::single("chapter", 1));
manager.apply_reset(&CounterSet::single("section", 0));
// ... sections are children of chapter
manager.leave_scope();
```

### Nested Lists
```css
ol { counter-reset: item; }
li { counter-increment: item; }
li::before { content: counters(item, "."); }
```

```rust
// First ol
manager.enter_scope();
manager.apply_reset(&CounterSet::single("item", 0));

// li in first ol
manager.enter_scope();
manager.apply_increment(&CounterSet::single("item", 1));
// format: "1"

// Nested ol
manager.enter_scope();
manager.apply_reset(&CounterSet::single("item", 0));

// li in nested ol
manager.enter_scope();
manager.apply_increment(&CounterSet::single("item", 1));
let result = manager.format_all("item", ".", CounterStyle::Decimal);
// result: "1.1"
```

## Integration Points

### With Content Generation (W5.T10)
The `CounterManager` can be used during content generation when processing `counter()` and `counters()` functions in `content` property values:

```rust
// In content generation:
fn resolve_counter(&self, name: &str, style: CounterStyle) -> String {
    self.counter_manager.format(name, style)
}

fn resolve_counters(&self, name: &str, sep: &str, style: CounterStyle) -> String {
    self.counter_manager.format_all(name, sep, style)
}
```

### With Box Generation
Counter properties should be applied during tree traversal:

```rust
// During tree walk:
for element in tree.iter() {
    counter_manager.enter_scope();

    if let Some(reset) = element.style.counter_reset {
        counter_manager.apply_reset(&reset);
    }
    if let Some(increment) = element.style.counter_increment {
        counter_manager.apply_increment(&increment);
    }

    // Process element with current counter values...

    counter_manager.leave_scope();
}
```

## API Summary

### CounterSet Methods
| Method | Description |
|--------|-------------|
| `parse_reset(s)` | Parse counter-reset value (default: 0) |
| `parse_increment(s)` | Parse counter-increment value (default: 1) |
| `parse_set(s)` | Parse counter-set value (default: 0) |
| `single(name, value)` | Create set with one counter |
| `add(name, value)` | Add counter to set |
| `get(name)` | Get counter value by name |
| `is_empty()` | Check if set is empty |
| `len()` | Get number of counters |

### CounterManager Methods
| Method | Description |
|--------|-------------|
| `new()` | Create manager with root scope |
| `enter_scope()` | Enter new scope (element start) |
| `leave_scope()` | Leave current scope (element end) |
| `apply_reset(set)` | Apply counter-reset |
| `apply_increment(set)` | Apply counter-increment |
| `apply_set(set)` | Apply counter-set |
| `get(name)` | Get counter value (None if not found) |
| `get_or_zero(name)` | Get counter value (0 if not found) |
| `get_all(name)` | Get all nested counter values |
| `format(name, style)` | Format single counter |
| `format_all(name, sep, style)` | Format nested counters |
| `has(name)` | Check if counter exists |
| `depth()` | Get current scope depth |
| `reset()` | Reset to initial state |

## Test Coverage

The implementation includes 116 tests total:
- 42 unit tests in `src/style/counters.rs`
- 74 integration tests in `tests/test_counters.rs`

Test categories:
- CounterSet parsing
- CounterManager basic operations
- Counter reset and increment
- Scope management
- get_all for counters() function
- Counter formatting
- CounterProperties
- Real-world usage scenarios
- Edge cases

## Future Considerations

1. **CSS Property Parsing Integration**: The `CounterSet::parse_*` methods can be called from CSS property parsing when `counter-reset`, `counter-increment`, or `counter-set` properties are encountered.

2. **List Item Counter**: HTML `<li>` elements have implicit `counter-increment: list-item`. This can be handled during box generation.

3. **`<ol start>` Attribute**: The `start` attribute on ordered lists maps to `counter-reset: list-item <start-1>`.

4. **`<li value>` Attribute**: The `value` attribute on list items maps to `counter-set: list-item <value>`.

5. **@counter-style Rule**: Future support for custom counter styles via `@counter-style` at-rule.
