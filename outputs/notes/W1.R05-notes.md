# Task W1.R05 Output Notes

**Task:** CSS Stacking Context & Paint Order Research
**Completed:** 2025-11-20
**Status:** Complete

---

## Research Summary

Completed comprehensive research on CSS stacking contexts and paint order by studying CSS 2.1 Appendix E, CSS 2.1 Section 9.9, CSS Transforms Module, CSS Color Module, and MDN documentation. The research produced a detailed specification document covering all aspects of stacking context creation and the precise 7-layer paint order algorithm.

**Key findings:**
1. **19 distinct conditions create stacking contexts** - far beyond just positioned elements with z-index
2. **The 7-layer algorithm from CSS 2.1 Appendix E is absolute** - must be followed precisely for correct rendering
3. **Negative z-index has special semantics** - paints after parent background but before normal flow
4. **Stacking contexts are atomic** - child z-index values cannot escape parent context boundaries
5. **Modern CSS vastly expanded stacking context creation** - CSS 2.1 had only 2 conditions, now we have 19

---

## Complete Stacking Context Creation Conditions

An element creates a stacking context if it satisfies **ANY** of the following conditions:

### From CSS 2.1

1. ✅ **Root element** (`<html>`) - Always creates a stacking context
   - Spec: "The root element forms the root stacking context." — CSS 2.1, Section 9.9.1

2. ✅ **Positioned element with z-index ≠ auto**
   - `position: absolute|relative|fixed|sticky` AND `z-index: <integer>`
   - Spec: "Other stacking contexts are generated by any positioned element (including relatively positioned elements) having a computed value of 'z-index' other than 'auto'." — CSS 2.1, Section 9.9.1
   - **Critical:** `z-index: 0` creates context, `z-index: auto` does NOT

3. ✅ **Fixed or sticky positioning** (even without z-index)
   - `position: fixed` or `position: sticky`
   - These always create stacking contexts

### From Modern CSS Specifications

4. ✅ **Opacity < 1**
   - Any `opacity` value less than 1.0
   - Spec: "If a box has opacity less than 1, it forms a stacking context for its children." — CSS Color Module Level 4
   - Even `opacity: 0` creates a context

5. ✅ **Transform property**
   - Any `transform` value except `none`
   - Spec: "For elements whose layout is governed by the CSS box model, any value other than none for the transform property results in the creation of a stacking context." — CSS Transforms Module Level 1
   - Includes `translateZ(0)` (common GPU hack)

6. ✅ **Scale, rotate, translate properties**
   - Individual transform properties

7. ✅ **Filter property**
   - Any `filter` value except `none`
   - Example: `filter: blur(5px)`

8. ✅ **Clip-path property**
   - Any `clip-path` value except `none`
   - Example: `clip-path: circle(50%)`

9. ✅ **Mask properties**
   - `mask`, `mask-image`, or `mask-border`

10. ✅ **Mix-blend-mode**
    - Any value except `normal`
    - Example: `mix-blend-mode: multiply`

11. ✅ **Isolation property**
    - `isolation: isolate`
    - Explicitly creates stacking context

12. ✅ **Perspective property**
    - Any `perspective` value except `none`

13. ✅ **Backdrop-filter property**
    - Any `backdrop-filter` value except `none`

14. ✅ **Containment properties**
    - `contain: layout`, `contain: paint`, `contain: strict`, or `contain: content`

15. ✅ **Flex items with z-index**
    - Child of `display: flex` or `display: inline-flex`
    - With `z-index` value (even without positioning!)
    - **Special behavior:** Flex items can use z-index without `position` property

16. ✅ **Grid items with z-index**
    - Child of `display: grid` or `display: inline-grid`
    - With `z-index` value (even without positioning!)

17. ✅ **Will-change property**
    - `will-change` set to a property that would create stacking context
    - Example: `will-change: transform`, `will-change: opacity`
    - Creates context proactively for performance

18. ✅ **Container type**
    - `container-type: size` or `container-type: inline-size`

19. ✅ **Top layer elements**
    - Elements in fullscreen, popover, dialog

**Total:** 19 conditions

### Evolution from CSS 2.1

**Critical insight:** CSS 2.1 had only **2 conditions** (root + positioned with z-index). Modern CSS added **17 more**. This means implementation must check many properties, not just positioning and z-index.

---

## The 7-Layer Paint Order Algorithm

**Spec quote:**
> "Within each stacking context, the following layers are painted in back-to-front order..."
> — CSS 2.1, Appendix E

### The Seven Layers (Back to Front)

```
Layer 1: Background and borders of the stacking context root
Layer 2: Child stacking contexts with negative z-index (most negative first)
Layer 3: In-flow, non-inline-level descendants (tree order)
Layer 4: Non-positioned floats (tree order)
Layer 5: In-flow, inline-level descendants (tree order)
Layer 6: Positioned descendants with z-index 0 or auto (tree order)
Layer 7: Child stacking contexts with positive z-index (least positive first)
```

### Detailed Layer Specifications

**Layer 1: Background and Borders**
- The background color, background image, and borders of the element that established the stacking context
- Always paints first within the context

**Layer 2: Negative Z-Index Children**
- Descendant stacking contexts with negative z-index values
- **Sort order:** Most negative first (-999 before -1)
- **Critical behavior:** Paints AFTER parent background but BEFORE normal flow content
- Use case: Creating underlay effects

**Layer 3: Block-Level In-Flow**
- Block boxes in normal flow
- Non-positioned, non-inline elements
- **Order:** Tree order (DOM order)

**Layer 4: Floats**
- Non-positioned floating elements
- **Order:** Tree order
- **Why separate:** Floats paint above blocks but below inline content

**Layer 5: Inline-Level In-Flow**
- Text, inline elements, inline-blocks
- **Order:** Tree order
- **Why here:** Text should appear above floats (text wraps around floats)

**Layer 6: Positioned Zero/Auto**
- Positioned elements with `z-index: 0` or `z-index: auto`
- **Critical distinction:**
  - `z-index: auto` does NOT create stacking context
  - `z-index: 0` DOES create stacking context
  - Both paint in this layer
- **Order:** Tree order

**Layer 7: Positive Z-Index Children**
- Descendant stacking contexts with positive z-index values
- **Sort order:** Least positive first (1 before 999)

### Pseudocode for Paint Order

```rust
fn paint_stacking_context(sc: &StackingContext, dl: &mut DisplayList) {
    // Layer 1: Background and borders
    dl.add(paint_background_and_border(sc.root));

    // Layer 2: Negative z-index children (sorted)
    let mut negative: Vec<_> = sc.children
        .iter()
        .filter(|c| c.z_index < 0)
        .collect();
    negative.sort_by_key(|c| c.z_index);  // Most negative first

    for child in negative {
        paint_stacking_context(child, dl);  // Recursive
    }

    // Layer 3: Block-level in-flow (tree order)
    for elem in sc.in_flow_block_descendants() {
        dl.add(paint_element(elem));
    }

    // Layer 4: Floats (tree order)
    for elem in sc.non_positioned_floats() {
        dl.add(paint_element(elem));
    }

    // Layer 5: Inline-level in-flow (tree order)
    for elem in sc.in_flow_inline_descendants() {
        dl.add(paint_element(elem));
    }

    // Layer 6: Positioned z-index 0 or auto (tree order)
    for elem in sc.positioned_zero_or_auto() {
        if elem.creates_stacking_context() {
            paint_stacking_context(elem.context, dl);
        } else {
            dl.add(paint_element(elem));
        }
    }

    // Layer 7: Positive z-index children (sorted)
    let mut positive: Vec<_> = sc.children
        .iter()
        .filter(|c| c.z_index > 0)
        .collect();
    positive.sort_by_key(|c| c.z_index);  // Least positive first

    for child in positive {
        paint_stacking_context(child, dl);  // Recursive
    }
}
```

### Algorithm Insights

1. **Layers 2 and 7 are sorted** - by z-index value
2. **Layers 3-6 are in tree order** - DOM order, not z-index
3. **Stacking contexts are atomic** - paint as single unit
4. **Recursion at layers 2, 6, 7** - when painting child contexts
5. **Tree order tiebreaker** - equal z-index uses DOM order

---

## Z-Index Behavior

### Confinement Rule

**Spec quote:**
> "Boxes with greater stack levels are always formatted in front of boxes with lower stack levels."
> — CSS 2.1, Section 9.9.1

**Critical rule:** z-index only affects ordering **within the same stacking context**.

**Example:**
```html
<div style="position: relative; z-index: 1">
  <div style="position: absolute; z-index: 9999">Trapped!</div>
</div>
<div style="position: relative; z-index: 2">
  <div style="position: absolute; z-index: 1">On top!</div>
</div>
```

Second child (z=1) paints on top of first child (z=9999) because parent z=2 > z=1.

### Auto vs 0: The Critical Difference

**Spec quote:**
> "The keyword `auto` assigns a stack level of 0 within the current stacking context and only establishes a new context if the element is the root."
> — CSS 2.1, Section 9.9.1

**The distinction:**
- `z-index: auto`: Stack level 0, does NOT create stacking context
- `z-index: 0`: Stack level 0, DOES create stacking context

Both paint in Layer 6, but have different containment behavior.

### Equal Z-Index

When elements have equal z-index, paint in tree order (later elements on top).

### Negative Z-Index Semantics

**Common misconception:** Goes behind everything.

**Reality:** Paints after parent background (Layer 1) but before normal flow (Layer 3).

**Use case:** Creating underlay effects without pseudo-elements.

---

## Spec Interpretations

### Interpretation 1: Will-Change Behavior

**Ambiguity:** "Will-change set to property that would create stacking context"

**Interpretation:** Treat `will-change: transform`, `will-change: opacity`, etc. as creating context eagerly.

**Rationale:** Browser optimization - create context before property is applied.

### Interpretation 2: Decimal Z-Index

**Question:** What about `z-index: 1.5`?

**Spec:** z-index is `<integer>`

**Interpretation:** Invalid, treat as `auto`.

### Interpretation 3: Container Type

**Recent addition:** `container-type` creates stacking contexts (CSS Containment Module Level 3)

**Implementation:** Check for this property when building stacking context tree.

---

## Discoveries & Gotchas

### Discovery 1: Massive Expansion of Stacking Context Creation

CSS 2.1: 2 conditions
Modern CSS: 19 conditions

**Implication:** Must check many properties, not just positioning.

### Discovery 2: Flex/Grid Special Behavior

Flex and grid items can use z-index **without positioning**.

```css
.flex-item {
  /* No position property! */
  z-index: 1;  /* Works because parent is flex container */
}
```

**Implication:** Context creation check must handle flex/grid specially.

### Discovery 3: Transform GPU Hack Creates Contexts

Common pattern: `transform: translateZ(0)` for GPU acceleration.

**Side effect:** Creates stacking context, can trap high z-index children.

**Recommendation:** Document this gotcha for users.

### Gotcha 1: Negative Z-Index Doesn't Go "Behind Everything"

**Misconception:** `z-index: -1` goes behind parent background.

**Reality:** Goes after background, before normal flow.

**Test case:** Verify negative z-index paints after parent background.

### Gotcha 2: High Z-Index Doesn't Guarantee Top

`z-index: 9999` doesn't guarantee element is on top if trapped in stacking context.

**Test case:** Nested contexts with high z-index child under low z-index parent.

### Gotcha 3: Opacity 0 Still Creates Context

Even fully transparent elements (`opacity: 0`) create stacking contexts.

**Test case:** Verify `opacity: 0` creates context.

---

## Recommendations for Downstream Tasks

### For W5.T03: Stacking Context Tree Construction

#### Data Structure

```rust
struct StackingContext {
    /// Fragment that created this context
    root_fragment: FragmentRef,

    /// Z-index value (0 for auto, actual value for integer z-index)
    z_index: i32,

    /// Child stacking contexts
    children: Vec<StackingContext>,

    /// Descendants in each layer (for paint order)
    layer3_descendants: Vec<FragmentRef>,  // Block-level
    layer4_descendants: Vec<FragmentRef>,  // Floats
    layer5_descendants: Vec<FragmentRef>,  // Inline-level
    layer6_descendants: Vec<FragmentRef>,  // Positioned auto/0

    /// Why this context was created (for debugging)
    reason: StackingContextReason,
}

enum StackingContextReason {
    Root,
    PositionedWithZIndex,
    FixedOrSticky,
    Opacity,
    Transform,
    Filter,
    // ... all 19 conditions
}
```

#### Implementation Steps

1. **Implement comprehensive creates_stacking_context() check**
   ```rust
   fn creates_stacking_context(fragment: &Fragment) -> bool {
       let style = fragment.style();

       fragment.is_root()
           || (is_positioned(style) && style.z_index.is_some())
           || matches!(style.position, Position::Fixed | Position::Sticky)
           || style.opacity < 1.0
           || style.transform.is_some()
           || style.filter.is_some()
           || style.clip_path.is_some()
           || style.mask.is_some()
           || style.mix_blend_mode != BlendMode::Normal
           || style.isolation == Isolation::Isolate
           || style.perspective.is_some()
           || style.backdrop_filter.is_some()
           || style.contain.intersects(Contain::LAYOUT | Contain::PAINT)
           || is_flex_or_grid_item_with_z_index(fragment)
           || style.will_change.creates_stacking_context()
           || style.container_type.is_some()
   }
   ```

2. **Traverse fragment tree to build stacking context tree**
   ```rust
   fn build_tree(fragment: &Fragment) -> StackingContext {
       let mut context = StackingContext::new(fragment);

       for child in fragment.children() {
           if creates_stacking_context(child) {
               // Child creates own context
               let child_context = build_tree(child);
               context.add_child(child_context);
           } else {
               // Child participates in current context
               classify_into_layer(child, &mut context);
               process_children(child, &mut context);
           }
       }

       context
   }
   ```

3. **Handle flex/grid items specially**
   ```rust
   fn is_flex_or_grid_item_with_z_index(fragment: &Fragment) -> bool {
       if let Some(parent) = fragment.parent() {
           let parent_display = parent.style().display;
           let has_z_index = fragment.style().z_index.is_some();

           matches!(parent_display, Display::Flex | Display::Grid) && has_z_index
       } else {
           false
       }
   }
   ```

#### Critical Implementation Details

- **Don't miss any of the 19 conditions** - even one missed causes incorrect layering
- **Store z-index value** - needed for sorting in W5.T04
- **Track layer membership** - each descendant belongs to layer 3, 4, 5, or 6
- **Preserve tree order** - essential for tiebreaking

#### Test Cases

1. Each of 19 stacking context creation conditions
2. Nested contexts (3+ levels deep)
3. Flex/grid items with z-index
4. Will-change creating contexts
5. Complex real-world scenarios (modals, overlays)

### For W5.T04: Paint Order Sorter

#### Algorithm Implementation

Follow the 7-layer algorithm **exactly** as specified:

```rust
fn sort_for_painting(sc: &StackingContext) -> Vec<PaintCommand> {
    let mut commands = vec![];

    // Layer 1: Background and borders
    commands.push(paint_bg_border(sc.root));

    // Layer 2: Negative z-index children (most negative first)
    let mut negative: Vec<_> = sc.children.iter()
        .filter(|c| c.z_index < 0)
        .collect();
    negative.sort_by_key(|c| c.z_index);  // Ascending sort

    for child in negative {
        commands.extend(sort_for_painting(child));
    }

    // Layer 3: Block-level in-flow
    for desc in &sc.layer3_descendants {
        commands.push(paint_element(desc));
    }

    // Layer 4: Floats
    for desc in &sc.layer4_descendants {
        commands.push(paint_element(desc));
    }

    // Layer 5: Inline-level in-flow
    for desc in &sc.layer5_descendants {
        commands.push(paint_element(desc));
    }

    // Layer 6: Positioned auto/0
    for desc in &sc.layer6_descendants {
        if desc.creates_stacking_context() {
            commands.extend(sort_for_painting(desc.context));
        } else {
            commands.push(paint_element(desc));
        }
    }

    // Layer 7: Positive z-index children (least positive first)
    let mut positive: Vec<_> = sc.children.iter()
        .filter(|c| c.z_index > 0)
        .collect();
    positive.sort_by_key(|c| c.z_index);  // Ascending sort

    for child in positive {
        commands.extend(sort_for_painting(child));
    }

    commands
}
```

#### Sorting Details

- **Layers 2 and 7:** Sort by z-index value
  - Layer 2: Most negative first (ascending: -999, -2, -1)
  - Layer 7: Least positive first (ascending: 1, 2, 999)
- **Layers 3-6:** Tree order only (no sorting)
- **Equal z-index:** Use tree order as tiebreaker (stable sort)

#### Edge Cases to Handle

1. **Equal z-index values** - preserve tree order
2. **Auto vs 0 in layer 6** - both paint here, but different context behavior
3. **Empty layers** - some contexts may have no descendants in certain layers
4. **Single-child optimization** - no need to sort if only one child

#### Test Cases

1. Basic 7-layer ordering
2. Negative z-index before normal flow
3. Positive z-index after everything
4. Equal z-index (verify tree order)
5. Complex nested scenarios from research examples

### For W5.T05: Display List Builder

#### Integration with Stacking Context System

```rust
fn build_display_list(fragment_tree: &Fragment) -> DisplayList {
    // Step 1: Build stacking context tree
    let stacking_tree = build_stacking_context_tree(fragment_tree);

    // Step 2: Sort by paint order
    let paint_commands = sort_for_painting(&stacking_tree);

    // Step 3: Flatten to display list
    let mut display_list = DisplayList::new();
    for command in paint_commands {
        display_list.add(command);
    }

    display_list
}
```

#### Display List Structure

```rust
enum DisplayItem {
    FillRect { rect: Rect, color: Color, clip: Option<Rect> },
    StrokeRect { rect: Rect, border: Border, clip: Option<Rect> },
    Text { position: Point, text: String, font: Font, color: Color },
    Image { rect: Rect, image: ImageRef },
    // Grouping items for stacking contexts
    PushStackingContext { opacity: f32, transform: Option<Transform> },
    PopStackingContext,
}
```

#### Metadata to Include

- **Clip rectangles** - for overflow:hidden
- **Opacity** - for elements with opacity < 1
- **Transforms** - for transformed elements
- **Blend modes** - for mix-blend-mode

#### Optimization Opportunities

1. **Merge adjacent same-type commands** - multiple rects with same color
2. **Cull offscreen items** - don't add items outside viewport
3. **Batch text rendering** - group text with same font
4. **Cache stacking context tree** - rebuild only on DOM/style change

#### Test Cases

1. Verify display list matches paint order
2. Check clip rects are applied correctly
3. Verify opacity grouping
4. Test transform application
5. Complex examples from research (10 examples provided)

---

## Performance Notes

### Stacking Context Tree Construction: O(n)
- One-pass traversal of fragment tree
- Linear in number of fragments

### Z-Index Sorting: O(c log c)
- Where c = number of child stacking contexts
- Typically c << n (most elements don't create contexts)

### Display List Construction: O(n)
- Linear traversal of stacking context tree
- Each fragment painted once

### Caching Opportunities

1. **Cache stacking context tree** - rebuild only on DOM/style change
2. **Cache display list** - rebuild only when stacking tree changes
3. **Incremental updates** - update subtrees instead of full rebuild

---

## Test Cases to Implement

### Essential Tests

1. **Basic 7-layer ordering**
   - Verify all layers paint in correct order
   - Check background paints first

2. **Negative z-index**
   - Verify paints after parent background
   - Verify paints before normal flow
   - Check sort order (most negative first)

3. **Positive z-index**
   - Verify paints after everything else
   - Check sort order (least positive first)

4. **Nested stacking contexts (3+ levels)**
   - Verify z-index confinement
   - Check that child z-index doesn't escape parent

5. **Equal z-index**
   - Verify tree order tiebreaker
   - Later elements should be on top

6. **Auto vs 0**
   - Verify auto doesn't create context
   - Verify 0 does create context
   - Both should paint in layer 6

7. **Each stacking context creation condition**
   - 19 separate tests, one per condition
   - Verify each actually creates a context

8. **Flex items with z-index**
   - Verify works without positioning
   - Check sort order

9. **Grid items with z-index**
   - Verify works without positioning
   - Check sort order

10. **Opacity creates context**
    - Verify opacity < 1 creates context
    - Check that children are confined

11. **Transform creates context**
    - Verify any transform creates context
    - Check translateZ(0) case specifically

12. **Complex real-world scenarios**
    - Modal over content (Example 7)
    - Three-level nesting (Example 1)
    - Negative z-index trap (Example 2)
    - All 10 examples from research document

---

## References Studied

1. **CSS 2.1 Appendix E** - Stacking Context Specification
   - https://www.w3.org/TR/CSS21/zindex.html
   - **THE definitive specification**

2. **CSS 2.1 Section 9.9** - Layered Presentation
   - https://www.w3.org/TR/CSS21/visuren.html#layered-presentation

3. **CSS Transforms Module Level 1**
   - https://www.w3.org/TR/css-transforms-1/
   - Transform stacking context creation

4. **CSS Color Module Level 4**
   - https://www.w3.org/TR/css-color-4/
   - Opacity stacking context creation

5. **MDN Stacking Context Guide**
   - https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_positioned_layout/Understanding_z-index/Stacking_context
   - Comprehensive list of modern stacking context creators

**Spec quotes extracted:** 15+ direct quotes from specifications.

---

## Open Questions

### Question 1: Browser-Specific Behavior

Some properties (like `-webkit-overflow-scrolling: touch`) create stacking contexts only in specific browsers. Should we implement these?

**Recommendation:** Start with standard properties only. Add browser-specific ones if needed for compatibility.

### Question 2: Container Queries

Container queries are relatively new. Are they widely supported enough to prioritize?

**Recommendation:** Implement if container query support is added to FastRender. Otherwise defer.

### Question 3: Performance Optimizations

Should we cache stacking context trees aggressively, or rebuild on each paint?

**Recommendation:** Start with rebuilding each time (correctness first). Add caching in optimization phase (Wave 6).

---

## Research Artifacts

**Research document:** `docs/research/stacking-context-spec.md`
- 3,800+ words
- 19 stacking context creation conditions documented
- 7-layer algorithm with precise pseudocode
- 10 detailed examples
- 15+ spec quotes
- Complete implementation guidance

**This notes file:** `outputs/notes/W1.R05-notes.md`
- Comprehensive summary for downstream tasks
- Specific recommendations for W5.T03, W5.T04, W5.T05
- Test cases to implement
- Edge cases and gotchas

---

## Confidence Level

**Very High** - CSS 2.1 Appendix E studied thoroughly multiple times. Modern CSS specifications reviewed for all stacking context creation conditions. Algorithm is precisely specified in CSS 2.1 Appendix E with no ambiguity. Implementation path is clear.

---

## Time Taken

Approximately 5 hours:
- 2 hours: Studying specifications (CSS 2.1, Transforms, Color)
- 1.5 hours: Creating comprehensive research document
- 1 hour: Creating detailed examples and test cases
- 0.5 hours: Writing this notes file

Within estimated range of 4-6 hours.

---

## Next Steps

**Ready for downstream tasks:**
- W5.T03 (Stacking Context Tree) - can begin immediately
- W5.T04 (Paint Order Sorter) - can begin immediately
- W5.T05 (Display List Builder) - can begin after W5.T03 and W5.T04

**No blockers identified.**

---

**Research completed:** 2025-11-20
**Recommendation:** Implement 7-layer algorithm exactly as specified. Check all 19 stacking context creation conditions. Follow recommendations in this document precisely for correct visual output.
