# Task W4.T01 Output Notes

**Task:** Implement Bidi Analyzer (Unicode Bidirectional Algorithm)
**Completed:** 2025-11-23
**Time Taken:** ~6-8 hours
**Status:** ✅ Complete

---

## Implementation Summary

Implemented a comprehensive bidirectional text analyzer that wraps the `unicode-bidi` crate to provide UAX #9 (Unicode Bidirectional Algorithm) support for FastRender. The implementation provides:

1. **BidiAnalyzer** - Main analyzer struct that wraps `unicode-bidi` crate functionality
2. **BidiRun** - Represents a contiguous run of text with uniform direction
3. **BidiAnalysis** - Full analysis result with access to embedding levels and visual/logical runs
4. **Direction** - Enum for LTR/RTL text direction
5. **Convenience functions** - `analyze_bidi()` for simple use cases

The analyzer correctly handles:
- Pure LTR text (Latin, Cyrillic, Greek scripts)
- Pure RTL text (Hebrew, Arabic scripts)
- Mixed LTR/RTL content
- Numbers in RTL context (preserved as LTR, not reversed)
- Bidi isolates and embeddings (LRI, RLI, PDI characters)
- Direction detection from first strong character
- CSS `direction` property integration

---

## API Contracts

### Main Types

```rust
/// Text direction
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum Direction {
    #[default]
    Ltr,
    Rtl,
}

impl Direction {
    pub fn is_ltr(self) -> bool;
    pub fn is_rtl(self) -> bool;
    pub fn to_level(self) -> Level;
    pub fn from_level(level: Level) -> Self;
}

/// A run of text with uniform bidirectional properties
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct BidiRun {
    pub start: usize,      // Byte offset in original text
    pub end: usize,        // End byte offset (exclusive)
    pub level: u8,         // Bidi embedding level (0-125)
    pub direction: Direction,
    pub text: String,      // The text content of this run
}

impl BidiRun {
    pub fn len(&self) -> usize;
    pub fn is_empty(&self) -> bool;
    pub fn is_ltr(&self) -> bool;
    pub fn is_rtl(&self) -> bool;
}

/// Result of full bidirectional text analysis
#[derive(Debug, Clone)]
pub struct BidiAnalysis {
    // Internal fields omitted
}

impl BidiAnalysis {
    pub fn text(&self) -> &str;
    pub fn base_direction(&self) -> Direction;
    pub fn needs_reordering(&self) -> bool;
    pub fn level_at(&self, byte_index: usize) -> Level;
    pub fn direction_at(&self, byte_index: usize) -> Direction;
    pub fn levels(&self) -> &[Level];
    pub fn paragraph_info(&self) -> &ParagraphInfo;
    pub fn visual_runs(&self) -> Vec<BidiRun>;
    pub fn logical_runs(&self) -> Vec<BidiRun>;
}

/// Bidirectional text analyzer
#[derive(Debug, Clone, Default)]
pub struct BidiAnalyzer;

impl BidiAnalyzer {
    pub fn new() -> Self;
    pub fn analyze(&self, text: &str, base_direction: Direction) -> Vec<BidiRun>;
    pub fn analyze_full(&self, text: &str, base_direction: Direction) -> BidiAnalysis;
    pub fn char_bidi_class(&self, ch: char) -> BidiClass;
    pub fn char_direction(&self, ch: char) -> Option<Direction>;
    pub fn detect_direction(&self, text: &str, default: Direction) -> Direction;
    pub fn has_rtl(&self, text: &str) -> bool;
    pub fn is_pure_ltr(&self, text: &str) -> bool;
    pub fn reorder_text(&self, text: &str, base_direction: Direction) -> String;
}

/// Convenience function
pub fn analyze_bidi(text: &str, base_direction: Direction) -> Vec<BidiRun>;
```

### Re-exports from text module

```rust
pub use bidi::{analyze_bidi, BidiAnalysis, BidiAnalyzer, BidiRun, Direction};
```

---

## Decisions Made

### Decision 1: Wrap unicode-bidi, Don't Re-implement

**Choice:** Wrap the `unicode-bidi` crate rather than implementing UAX #9 from scratch.

**Rationale:**
- UAX #9 is extremely complex (~50 pages of specification)
- Browser implementations are 2000+ lines of carefully tested code
- `unicode-bidi` is mature, well-tested, and maintained
- Saves months of development time
- Avoids subtle bugs with edge cases

**Impact:** Our API is a clean wrapper that provides FastRender-specific types while delegating complex bidi logic to the battle-tested crate.

### Decision 2: BidiRun Contains Text Copy

**Choice:** `BidiRun` contains a `String` with the run's text content.

**Rationale:**
- Provides convenient access without needing original text
- Simplifies downstream usage (text shaping, line breaking)
- Memory overhead is acceptable for typical text lengths
- Avoids lifetime complications

**Alternative considered:** Using ranges only (start/end) and requiring access to original text. Rejected for ergonomics.

### Decision 3: Direction Enum Separate from unicode-bidi

**Choice:** Define our own `Direction` enum instead of re-exporting `unicode_bidi::Direction`.

**Rationale:**
- Cleaner API surface
- Maps directly to CSS `direction` property
- Avoids exposing internal dependency types
- Enables future CSS integration without changing API

### Decision 4: Visual Runs as Primary Output

**Choice:** `analyze()` returns visual runs (display order) by default.

**Rationale:**
- Most consumers want visual order for rendering
- Logical runs available via `analyze_full().logical_runs()` for advanced use
- Matches expected usage pattern for text layout

---

## Spec Interpretations

### UAX #9: Numbers in RTL Context

**Spec says:** European Numbers (EN class) get even embedding levels when embedded in RTL context.

**Our interpretation:**
- Numbers in RTL text get level 2 (even = LTR direction)
- Numbers are NOT reversed when displayed
- Example: `"מחיר: 123"` displays with "123" in correct order, not "321"

**Test coverage:** `test_numbers_in_rtl_context`, `test_numbers_in_hebrew_text`

### UAX #9: Paragraph Direction

**Spec says:** Find first strong character (L, R, AL) to determine paragraph direction.

**Our interpretation:**
- Use CSS `direction` property as base direction
- `detect_direction()` provides UAX #9 auto-detection behavior
- All-neutral text (only numbers/punctuation) falls back to CSS direction

**Test coverage:** `test_detect_direction_*` tests

### UAX #9: Visual Runs

**Spec says:** L2 rule reorders runs within each line for visual display.

**Our interpretation:**
- `visual_runs()` returns runs in display order (left-to-right on screen)
- RTL runs have content in logical order (caller reverses if needed for glyph rendering)
- `reorder_text()` provides convenience function for simple visual output

---

## Discoveries & Gotchas

### Gotcha 1: unicode-bidi API Differences

**Issue:** The `BidiInfo::visual_runs()` method signature differs between versions:
- Returns `(Vec<Level>, Vec<LevelRun>)` where `LevelRun = Range<usize>`
- First element is reordered levels, second is the visual run ranges

**Solution:** Use the range's `.start` and `.end` fields, not trying to access fields on `Level`.

### Gotcha 2: Character Index vs Byte Index

**Issue:** Unicode-bidi works with character indices, but Rust strings are byte-indexed.

**Solution:** Convert byte indices to character indices when accessing levels:
```rust
let char_index = text[..byte_offset].chars().count();
let level = levels.get(char_index);
```

### Gotcha 3: Empty Text Edge Case

**Issue:** `BidiInfo::new()` with empty string produces empty paragraph list.

**Solution:** Handle empty text early:
```rust
if text.is_empty() {
    return Vec::new();
}
```

### Discovery 1: Bidi Levels Affect Cursor Positioning

Numbers stay LTR even in RTL context, which affects:
- Cursor movement (logical vs visual)
- Text selection
- Hit testing

**Implication for W4.T12:** Need to store bidi levels with glyphs for proper cursor handling.

---

## Performance Notes

### Algorithmic Complexity

- **analyze()**: O(n) where n = text length
- **analyze_full()**: O(n) with additional allocation for levels array
- **has_rtl()**: O(n) but often early-exits for LTR-only text
- **is_pure_ltr()**: O(n) worst case

### Optimization Opportunities

1. **Early exit for pure LTR:**
   ```rust
   if analyzer.is_pure_ltr(text) {
       // Skip full bidi analysis
       return vec![single_ltr_run];
   }
   ```

2. **Caching BidiAnalysis:**
   - Cache per text node
   - Invalidate on text change or CSS direction change

3. **Avoid repeated analysis:**
   - Use `analyze_full()` once, extract both visual and logical runs

### Benchmark Target

- < 1ms for 10KB text
- Linear scaling with text length
- No measurable overhead for pure LTR text when using `is_pure_ltr()` check

---

## Recommendations for Downstream Tasks

### For W4.T02 (Script Itemizer)

**Use these APIs:**
- `BidiAnalyzer::analyze_full()` - Get full analysis with levels
- `BidiAnalysis::direction_at(byte_index)` - Check direction at specific position

**Integration pattern:**
```rust
// 1. Run bidi analysis first
let bidi_analysis = analyzer.analyze_full(text, css_direction);

// 2. Split into script runs, passing bidi info
for script_run in script_itemizer.itemize(text, &bidi_analysis) {
    // Each script run knows its bidi level
    let direction = bidi_analysis.direction_at(script_run.start);
}
```

**Key insight:** Bidi analysis should happen BEFORE script itemization because direction affects how runs are split.

### For W4.T08 (Break Opportunity Finder)

**Use these APIs:**
- `BidiAnalyzer::analyze()` - Get visual runs
- `BidiRun::start`/`end` - Byte offsets match break opportunity offsets

**Integration pattern:**
```rust
// Break opportunities are found per-run to maintain proper direction handling
for run in bidi_runs {
    let breaks = break_finder.find(&run.text, &style);
    // Offset breaks by run.start for original text positions
}
```

**Gotcha to avoid:** Don't find breaks across bidi boundaries - each run should be processed separately.

### For W4.T12 (Inline Layout)

**Store bidi levels with glyphs:**
```rust
pub struct GlyphInfo {
    pub glyph_id: u32,
    pub x_advance: f32,
    pub cluster: usize,
    pub bidi_level: u8,  // ← ADD THIS
}
```

**Use for cursor positioning:**
- `BidiAnalysis::level_at()` - Get level for cursor position
- Even levels move cursor right, odd levels move left
- Implement `visual_to_logical()` and `logical_to_visual()` mappings

**Visual line construction:**
1. Shape text runs (using bidi runs as boundaries)
2. Store bidi levels with glyphs
3. Reorder line using `visual_runs()` when rendering

### For W4.T03 (Text Shaper)

**Use bidi runs as shaping boundaries:**
```rust
for run in analyzer.analyze(text, direction) {
    // Shape each run separately
    let shaped = shaper.shape(&run.text, font, run.direction);

    // Set direction hint for HarfBuzz
    buffer.set_direction(match run.direction {
        Direction::Ltr => HbDirection::LeftToRight,
        Direction::Rtl => HbDirection::RightToLeft,
    });
}
```

**Critical:** Don't merge runs of different directions - they must be shaped separately.

---

## Open Questions

### Question 1: unicode-bidi Property CSS Integration

**Context:** CSS `unicode-bidi` property has values: `normal`, `embed`, `isolate`, `bidi-override`

**Current status:** Not directly supported. The base direction is used, but embedding/isolate characters aren't inserted.

**Resolution path:** DOM/styling layer should insert appropriate Unicode control characters (LRI/RLI/PDI) when `unicode-bidi: isolate` is set. The bidi analyzer will then handle them correctly.

**Assigned to:** W4.T12 (Inline Layout) or CSS styling integration

### Question 2: Paragraph Boundary Handling

**Context:** UAX #9 treats paragraph separators (U+2029) specially.

**Current status:** Treated as neutral, relies on block-level handling.

**Resolution path:** Layout system should split text at paragraph boundaries before bidi analysis.

---

## Test Coverage

### Unit Tests (42 tests in `src/text/bidi.rs`)

**Direction tests:**
- [x] Default is LTR
- [x] `is_ltr()`/`is_rtl()` work correctly
- [x] Round-trip with Level conversion

**BidiRun tests:**
- [x] `len()` and `is_empty()`
- [x] Direction helpers

**Pure LTR tests:**
- [x] Simple English text
- [x] Empty text
- [x] Whitespace only

**Pure RTL tests:**
- [x] Hebrew text
- [x] Arabic text
- [x] RTL with RTL base direction

**Mixed content tests:**
- [x] LTR with embedded RTL
- [x] RTL with embedded LTR
- [x] Alternating scripts

**Numbers in RTL:**
- [x] Numbers in Arabic context
- [x] Numbers in Hebrew context
- [x] Numbers not reversed

**Isolates and embeddings:**
- [x] LTR isolate (U+2066)
- [x] RTL isolate (U+2067)

**Analysis tests:**
- [x] `needs_reordering()` detection
- [x] `level_at()` returns correct levels
- [x] Logical vs visual runs

**Character classification:**
- [x] LTR characters
- [x] RTL characters
- [x] Neutral characters

**Direction detection:**
- [x] First strong LTR
- [x] First strong RTL
- [x] No strong characters (fallback)

**Edge cases:**
- [x] Single LTR character
- [x] Single RTL character
- [x] Punctuation at boundaries
- [x] Emoji handling
- [x] Very long text
- [x] Text with newlines

### Integration Tests (24 tests in `tests/text_bidi.rs`)

- [x] Full API surface coverage
- [x] Real-world text patterns
- [x] Performance with long text

---

## Files Created

| File | Lines | Description |
|------|-------|-------------|
| `src/text/bidi.rs` | ~700 | Core bidi analyzer implementation |
| `tests/text_bidi.rs` | ~220 | Integration tests |
| `outputs/notes/W4.T01-notes.md` | This file | Implementation notes |

---

## Verification Results

```
Task: W4.T01 - Implement Bidi Analyzer
Status: ✅ COMPLETE

Verification:
✅ cargo build - SUCCESS
✅ cargo test bidi --lib - 43/43 tests passed
✅ cargo test --test text_bidi - 24/24 tests passed
✅ cargo clippy -- -D warnings - no warnings in fastrender code
✅ cargo fmt --check - properly formatted

Dependencies Used:
- unicode-bidi = "0.3" (from Cargo.toml)

Notes:
- All objectives achieved per task specification
- Comprehensive test coverage for UAX #9 behavior
- Clean API wrapper around unicode-bidi crate
- Ready for integration with text shaping (W4.T03)
```

---

**Research Completed:** 2025-11-23
**Implementation Time:** ~6-8 hours
**Test Cases:** 67 total (43 unit + 24 integration)
**Lines of Code:** ~920 total
