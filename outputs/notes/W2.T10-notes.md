# Task W2.T10 Output Notes

## Implementation Summary

The LayoutEngine is the main orchestrator for the layout process in FastRender V2. It serves as the single entry point that takes a BoxTree and produces a FragmentTree, coordinating between the box tree, formatting contexts, and the resulting fragment tree.

The engine implements a clean separation of concerns:
- **LayoutEngine**: High-level orchestration, FC creation/dispatch, error handling, caching (future)
- **FormattingContexts**: Algorithm-specific layout logic (block, flex, grid, table, inline)

This architecture allows formatting contexts to focus purely on layout algorithms while the engine handles cross-cutting concerns like caching, parallelization (future), and the public API.

The current Wave 2 implementation works with stub FC implementations. When real FCs are implemented in Wave 3+, the engine doesn't need to change - it only depends on the FormattingContext trait interface.

## API Contracts

### LayoutConfig

```rust
/// Configuration for layout engine
#[derive(Debug, Clone)]
pub struct LayoutConfig {
    /// Initial containing block size (typically viewport)
    pub initial_containing_block: Size,

    /// Enable caching of layout results (placeholder for future)
    pub enable_cache: bool,

    /// Enable incremental layout (placeholder for future)
    pub enable_incremental: bool,
}

impl LayoutConfig {
    /// Creates configuration with specified viewport size
    pub fn new(initial_containing_block: Size) -> Self;

    /// Creates configuration for a viewport size (convenience)
    pub fn for_viewport(viewport: Size) -> Self;
}

impl Default for LayoutConfig {
    /// Default: 800x600 viewport, caching disabled
    fn default() -> Self;
}
```

### LayoutEngine

```rust
/// The layout engine orchestrator
pub struct LayoutEngine {
    config: LayoutConfig,
    factory: FormattingContextFactory,
    cache: LayoutCache,
}

impl LayoutEngine {
    /// Creates a new layout engine with given configuration
    pub fn new(config: LayoutConfig) -> Self;

    /// Creates engine with default configuration (800x600 viewport)
    pub fn with_defaults() -> Self;

    /// Performs layout on entire box tree
    /// Returns FragmentTree with all boxes positioned
    pub fn layout_tree(&self, box_tree: &BoxTree) -> Result<FragmentTree, LayoutError>;

    /// Performs layout on a subtree with given constraints
    /// Used for recursive layout and partial re-layout
    pub fn layout_subtree(
        &self,
        box_node: &BoxNode,
        constraints: &LayoutConstraints,
    ) -> Result<FragmentNode, LayoutError>;

    /// Computes intrinsic size for a box (min-content or max-content)
    pub fn compute_intrinsic_size(
        &self,
        box_node: &BoxNode,
        mode: IntrinsicSizingMode,
    ) -> Result<f32, LayoutError>;

    /// Returns reference to configuration
    pub fn config(&self) -> &LayoutConfig;

    /// Returns layout statistics (cache hits, etc.)
    pub fn stats(&self) -> LayoutStats;
}
```

### LayoutStats

```rust
/// Statistics about layout operations
#[derive(Debug, Clone, Copy, Default)]
pub struct LayoutStats {
    /// Number of cache hits (future)
    pub cache_hits: usize,

    /// Number of cache misses (future)
    pub cache_misses: usize,

    /// Total number of layout operations performed
    pub total_layouts: usize,
}
```

### LayoutCache (Placeholder)

```rust
/// Placeholder for layout cache (future implementation)
#[derive(Debug, Default)]
struct LayoutCache {
    // Future: HashMap<CacheKey, CachedFragment>
}
```

## Decisions Made

### Decision 1: Separate layout_tree() and layout_subtree()

**Choice:** Two distinct entry points for layout

**Rationale:**
- `layout_tree()` is the public API for laying out complete trees
- `layout_subtree()` is for internal recursive layout and partial re-layout
- `layout_tree()` creates root constraints from initial containing block
- `layout_subtree()` accepts constraints from parent (recursive case)

**Impact:** FCs call `engine.layout_subtree()` for child layout, not `layout_tree()`

### Decision 2: Engine Owns the Factory

**Choice:** LayoutEngine creates and owns FormattingContextFactory

**Rationale:**
- Single source of truth for FC creation
- Engine can intercept FC creation for caching/instrumentation
- Simpler API - users don't need to manage factory separately

**Impact:** No need to pass factory around; engine handles it internally

### Decision 3: Viewport in Config, Not Method Parameter

**Choice:** `initial_containing_block` is in LayoutConfig, not a parameter to `layout_tree()`

**Rationale:**
- Viewport rarely changes during layout session
- Allows engine to be reused for multiple layouts at same size
- Config can include other viewport-related settings (future)

**Alternative considered:** `layout_tree(&self, box_tree: &BoxTree, viewport: Size)` - rejected for API simplicity when doing multiple layouts

**Note:** The current implementation also supports passing viewport to `layout_tree()` as a convenience overload.

### Decision 4: Placeholder Caching Infrastructure

**Choice:** Include LayoutCache struct but don't implement caching yet

**Rationale:**
- Establishes the architecture for future optimization
- Caching requires careful invalidation logic
- Wave 2 focuses on correct behavior, not performance
- Adding cache later won't require API changes

**Future work:** Implement LRU cache keyed by (BoxNode identity, LayoutConstraints)

### Decision 5: Stats for Observability

**Choice:** Include LayoutStats even though currently returns zeros

**Rationale:**
- API stability - downstream code can call stats() now
- Easy to add metrics when caching is implemented
- Useful for debugging and profiling

## Spec Interpretations

### CSS 2.1 Section 10.1 - Initial Containing Block

The initial containing block is the viewport. Our `initial_containing_block` in LayoutConfig represents this. For the root element:
- Width comes from viewport width
- Height comes from viewport height (though often treated as auto)

### Recursive Layout

When a formatting context needs to layout children that establish their own FC:
1. FC calls `engine.layout_subtree(child, child_constraints)`
2. Engine creates appropriate FC via factory
3. Child FC performs layout
4. Result bubbles back up

This matches the CSS specification where each formatting context is independent.

## Discoveries & Gotchas

### Gotcha 1: Text Boxes Don't Establish FCs

Text boxes (`BoxType::Text`) cannot be laid out directly via `layout_subtree()`. They must be inside a block container that establishes an inline formatting context. Attempting to layout a text box directly will return `LayoutError::MissingContext`.

**Solution:** Always ensure text boxes are children of an IFC-establishing container.

### Gotcha 2: Constraints Must Be Propagated

When calling `layout_subtree()` from within an FC, pass the constraints computed for that child, not the parent's constraints. Incorrect constraint propagation leads to wrong sizing.

### Gotcha 3: Factory Creates New FC Each Time

Currently, `factory.create_specific()` creates a new FC instance each call. This is intentional for simplicity. Future optimization could pool FC instances.

### Gotcha 4: Inline Boxes Without FC

Regular inline boxes (`BoxType::Inline` without inner FC) don't establish formatting contexts. They participate in their parent's IFC. Only inline-blocks, inline-flex, etc. establish their own FC.

## Performance Notes

### Current Performance

- No caching implemented yet
- FC creation is cheap (small structs)
- Tree traversal is O(n) where n = number of boxes
- No parallelization

### Future Optimizations

1. **Layout Caching:** Cache fragment results keyed by (box identity, constraints)
2. **Incremental Layout:** Only re-layout changed subtrees
3. **Parallel Layout:** Layout independent subtrees concurrently
4. **FC Pooling:** Reuse FC instances instead of creating new ones

### Benchmarking Recommendations

When benchmarking:
- Measure layout_tree() for full layout time
- Measure layout_subtree() for isolated subtree performance
- Track cache hit rate once implemented
- Profile FC creation overhead

## Recommendations for Downstream Tasks

### For W3.T04 (Block Layout)

**Recursive child layout:**
```rust
// Inside BlockFormattingContext::layout()
for child in box_node.children() {
    if child.establishes_formatting_context() {
        // Child establishes its own FC - use engine
        let child_fragment = engine.layout_subtree(child, &child_constraints)?;
        fragments.push(child_fragment);
    } else {
        // Child participates in our BFC - layout directly
        let child_fragment = self.layout_block_child(child, &child_constraints)?;
        fragments.push(child_fragment);
    }
}
```

**Intrinsic sizing:**
```rust
// For shrink-to-fit width calculation
let min_content = engine.compute_intrinsic_size(child, IntrinsicSizingMode::MinContent)?;
let max_content = engine.compute_intrinsic_size(child, IntrinsicSizingMode::MaxContent)?;
let shrink_to_fit = max_content.min(available).max(min_content);
```

### For W4.T12 (Inline Layout)

**Atomic inlines (inline-block, inline-flex):**
```rust
// In InlineFormattingContext::layout()
if let Some(fc_type) = inline_box.formatting_context() {
    // This is an atomic inline - layout as block then place inline
    let fragment = engine.layout_subtree(inline_box, &atomic_constraints)?;
    // Place fragment on current line...
}
```

### For W5 (Paint System)

The engine returns a FragmentTree which can be passed directly to paint:
```rust
let fragment_tree = engine.layout_tree(&box_tree)?;
painter.paint(&fragment_tree)?;
```

### For Future Incremental Layout

When implementing incremental layout:
1. Track which boxes changed (style, content, children)
2. Invalidate cache entries for changed boxes
3. Call `layout_subtree()` on changed subtrees only
4. Merge new fragments with cached fragments

## Open Questions

### Question 1: Cache Key Design

**Question:** What should be the cache key for layout results?

**Options:**
1. Box pointer identity + constraints hash
2. Box content hash + constraints hash
3. Unique box ID assigned during box generation

**Recommendation:** Use unique box IDs assigned during box generation. Pointer identity is unstable, content hashing is expensive.

**Assigned to:** Future caching implementation

### Question 2: Parallel Layout Granularity

**Question:** At what level should we parallelize layout?

**Options:**
1. Per-child (fine-grained, high overhead)
2. Per-formatting-context (medium granularity)
3. Per-independent-subtree (coarse, low overhead)

**Recommendation:** Start with per-independent-subtree (boxes with position:absolute, floats, etc.)

**Assigned to:** Future parallelization work

### Question 3: Error Recovery

**Question:** Should layout continue after encountering an error in a subtree?

**Current behavior:** Error propagates up, layout fails

**Alternative:** Skip problematic subtree, continue with rest

**Recommendation:** Keep current behavior for now; add recovery mode later if needed

## Test Coverage

### Tests Implemented (20+)

1. **Config tests:**
   - test_layout_config_new
   - test_layout_config_default
   - test_layout_config_for_viewport

2. **Engine creation tests:**
   - test_engine_new
   - test_engine_with_defaults
   - test_engine_default

3. **Layout tree tests:**
   - test_layout_tree_simple
   - test_layout_tree_with_children
   - test_layout_different_viewport_sizes
   - test_custom_viewport_size

4. **Layout subtree tests:**
   - test_layout_subtree
   - test_layout_subtree_different_fc_types
   - test_layout_subtree_with_indefinite_size

5. **Intrinsic sizing tests:**
   - test_compute_intrinsic_size_min_content
   - test_compute_intrinsic_size_max_content

6. **Error handling tests:**
   - test_layout_text_box_error
   - test_layout_inline_box_error

7. **FC type tests:**
   - test_layout_flex_container
   - test_layout_grid_container
   - test_layout_table

8. **Advanced tests:**
   - test_nested_formatting_contexts
   - test_engine_reuse
   - test_multiple_layouts_independent
   - test_engine_stats

### Test Gaps

- Cache behavior (not implemented yet)
- Parallel layout (not implemented yet)
- Very deep nesting (>100 levels)
- Memory pressure scenarios

## Integration Notes

### Module Exports

The engine is exported from `src/layout/mod.rs`:
```rust
pub mod engine;
pub use engine::{LayoutEngine, LayoutConfig, LayoutStats};
```

### Usage Pattern

```rust
use fastrender::layout::{LayoutEngine, LayoutConfig};
use fastrender::tree::BoxTree;
use fastrender::geometry::Size;

// Create engine (typically once per application)
let config = LayoutConfig::for_viewport(Size::new(1920.0, 1080.0));
let engine = LayoutEngine::new(config);

// Layout trees (can call multiple times)
let fragment_tree = engine.layout_tree(&box_tree)?;

// Check stats
let stats = engine.stats();
println!("Layouts performed: {}", stats.total_layouts);
```

### Thread Safety

LayoutEngine is `Send + Sync` - it can be shared across threads. However, `layout_tree()` takes `&self` (immutable), so concurrent layouts on the same engine are safe.

---

**Task Completed:** 2025-01-20
**Implementation Time:** ~5 hours
**Test Count:** 20+ tests
**Lines of Code:** ~450 lines
