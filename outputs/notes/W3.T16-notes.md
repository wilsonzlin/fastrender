# Task W3.T16 Output Notes: Font Metrics Extraction

## Implementation Summary

Implemented a comprehensive font metrics extraction module that extracts dimensional information from TTF/OTF fonts using the `ttf-parser` crate. The module provides:

1. **FontMetrics struct** - Contains all dimensional data in font design units (ascent, descent, line_gap, x-height, cap-height, underline/strikeout metrics, and style flags)

2. **ScaledFontMetrics struct** - Provides pixel-scaled metrics for a specific font size, with descent converted to positive for easier layout calculations

3. **Extraction functions** - `FontMetrics::from_font_data()` and `FontMetrics::from_face()` for parsing fonts, plus `extract_metrics()` convenience function

The implementation correctly handles the ttf-parser 0.25 API, extracting data from the hhea, OS/2, and post font tables. Fallbacks are provided when optional metrics (x-height, cap-height, strikeout) are not present in the font.

## API Contracts

### Core Types

```rust
/// Font metrics in font design units
pub struct FontMetrics {
    pub units_per_em: u16,           // Design resolution (typically 1000 or 2048)
    pub ascent: i16,                 // Max height above baseline (positive)
    pub descent: i16,                // Max depth below baseline (negative)
    pub line_gap: i16,               // Extra line spacing
    pub x_height: Option<i16>,       // Height of lowercase 'x'
    pub cap_height: Option<i16>,     // Height of uppercase letters
    pub underline_position: i16,     // Underline position (negative = below)
    pub underline_thickness: i16,    // Underline stroke width
    pub strikeout_position: Option<i16>,
    pub strikeout_size: Option<i16>,
    pub is_bold: bool,
    pub is_italic: bool,
    pub is_monospace: bool,
    pub average_char_width: Option<i16>,  // Currently None (not in ttf-parser API)
    pub glyph_count: u16,
}

/// Scaled font metrics in pixels
pub struct ScaledFontMetrics {
    pub font_size: f32,              // Font size used for scaling
    pub units_per_em: u16,           // Original units per em
    pub scale: f32,                  // Scale factor (font_size / units_per_em)
    pub ascent: f32,                 // Ascent in pixels (positive)
    pub descent: f32,                // Descent in pixels (positive - converted)
    pub line_gap: f32,               // Line gap in pixels
    pub line_height: f32,            // Total line height in pixels
    pub x_height: Option<f32>,       // x-height in pixels
    pub cap_height: Option<f32>,     // cap-height in pixels
    pub underline_position: f32,     // Underline position in pixels
    pub underline_thickness: f32,    // Underline thickness in pixels
    pub strikeout_position: Option<f32>,
    pub strikeout_size: Option<f32>,
    pub average_char_width: Option<f32>,
}
```

### Key Methods

```rust
// Extraction from raw data
FontMetrics::from_font_data(data: &[u8], index: u32) -> Result<Self>
FontMetrics::from_face(face: &ttf_parser::Face) -> Result<Self>
extract_metrics(face: &ttf_parser::Face) -> Result<FontMetrics>

// Scaling to pixel size
FontMetrics::scale(&self, font_size: f32) -> ScaledFontMetrics
FontMetrics::normal_line_height(&self, font_size: f32) -> f32

// Fallback methods
FontMetrics::x_height_or_fallback(&self, font_size: f32) -> f32  // 50% of ascent
FontMetrics::cap_height_or_fallback(&self, font_size: f32) -> f32  // 70% of ascent

// ScaledFontMetrics helpers
ScaledFontMetrics::baseline_offset(&self) -> f32  // = ascent
ScaledFontMetrics::em_height(&self) -> f32  // = ascent + descent
ScaledFontMetrics::half_leading(&self) -> f32  // = (line_height - em_height) / 2
ScaledFontMetrics::with_line_height_multiplier(&self, multiplier: f32) -> Self
ScaledFontMetrics::with_line_height(&self, line_height: f32) -> Self
ScaledFontMetrics::x_height_or_estimate(&self) -> f32
ScaledFontMetrics::cap_height_or_estimate(&self) -> f32
```

## Decisions Made

### Decision 1: Descent Sign Convention
**Choice:** Raw FontMetrics keeps descent negative (as in font), ScaledFontMetrics converts to positive
**Rationale:** Font files store descent as negative, but layout code is cleaner with positive descent. The conversion in `scale()` makes downstream use easier.

### Decision 2: Fallback Values for Missing Metrics
**Choice:**
- x-height fallback: 50% of ascent
- cap-height fallback: 70% of ascent
- underline position fallback: -10% of units_per_em
- underline thickness fallback: 5% of units_per_em

**Rationale:** These are industry-standard approximations used when fonts lack the OS/2 table version 2+ data.

### Decision 3: average_char_width Set to None
**Choice:** The `average_char_width` field is always None
**Rationale:** The ttf-parser 0.25 API doesn't expose `xAvgCharWidth` from OS/2 table. If needed, it can be computed by measuring common glyphs in the future.

### Decision 4: Error Handling with FontError
**Choice:** Return `FontError::InvalidFontFile` for parsing failures
**Rationale:** Consistent with existing error types in `src/error.rs`. Maps ttf-parser errors to our error hierarchy.

## Spec Interpretations

### CSS Line Height
The CSS spec's "normal" line-height is implemented as:
```
line_height = ascent - descent + line_gap  (in font units)
```
This matches CSS 2.1 Section 10.8.1.

### Leading Calculation
Half-leading is distributed equally above and below:
```
half_leading = (line_height - (ascent + descent)) / 2
```
This matches CSS Inline Layout Module Level 3.

## Discoveries & Gotchas

### Gotcha 1: ttf-parser API Changes
The ttf-parser 0.25 API uses `underline_metrics()` and `strikeout_metrics()` which return `LineMetrics` structs with `position` and `thickness` fields. Previous versions had separate methods.

### Gotcha 2: OS/2 Table Version
`x_height()` and `capital_height()` return `None` for fonts with OS/2 table version < 2. Always use the fallback methods when these might be None.

### Gotcha 3: Descent Sign
In raw font data, descent is negative (e.g., -200). In ScaledFontMetrics, it's positive. Be aware of which you're using.

### Gotcha 4: Line Height Formula
```rust
// In font units:
line_height = ascent - descent + line_gap
// Since descent is negative, this is: ascent + abs(descent) + line_gap
```

## Performance Notes

- **FontMetrics::from_font_data**: ~1-10μs depending on font size
- **FontMetrics::scale**: Extremely fast (<100ns), just multiplications
- All structs implement `Clone` and are cheap to copy
- No allocations in metric computation beyond initial parsing

### Recommendations
- Cache `FontMetrics` per font, not `ScaledFontMetrics`
- Compute `ScaledFontMetrics` on-demand for each font size
- Use `extract_metrics()` when you already have a parsed `Face`

## Recommendations for Downstream Tasks

### For W3.T17 (Font Database/Loader):
- Store `FontMetrics` in the font cache alongside font data
- Compute metrics during font loading, not on each access
- The `FontId` from fontdb can be used as cache key
- Consider using `Arc<FontMetrics>` for thread-safe sharing

### For W4.T01 (Inline Layout):
**Use ScaledFontMetrics for baseline alignment:**
```rust
let scaled = metrics.scale(font_size);
let baseline_y = line_top + scaled.baseline_offset();
```

**For CSS line-height:**
```rust
// line-height: normal
let line_height = metrics.normal_line_height(font_size);

// line-height: 1.5
let scaled = metrics.scale(font_size).with_line_height_multiplier(1.5);

// line-height: 24px
let scaled = metrics.scale(font_size).with_line_height(24.0);
```

### For W4.T03 (Text Shaping):
- Pass the raw `FontMetrics` to the shaper for positioning
- Use `units_per_em` to convert glyph advances to scaled values
- The shaper needs both metrics and scaled metrics

### For W5.T01 (Text Painting):
- Use `underline_position` and `underline_thickness` for text-decoration
- Use `strikeout_position` and `strikeout_size` for line-through
- Both are relative to baseline (negative = below)

## Open Questions

### Q1: Average Character Width
Currently not available from ttf-parser. Options:
1. Add custom parsing of OS/2 table raw bytes
2. Compute by measuring common characters (a-z, 0-9)
3. Leave as None and let shaping provide actual widths

**Recommendation:** Option 3 - shaping provides accurate widths anyway.

### Q2: Variable Fonts
Current implementation doesn't handle variation axes. For future:
- ttf-parser methods like `x_height()` are "affected by variation axes"
- May need to pass variation coordinates to extraction

### Q3: Vertical Metrics Variants
Some fonts have different vertical metrics in OS/2 vs hhea tables. Current implementation uses hhea (standard approach). May need `use_typographic_metrics()` check later.

## Test Coverage

**32 tests covering:**
- Line height calculation (basic, zero gap, large gap)
- Scaling to various font sizes (12px, 16px, 72px)
- Scaling with different units_per_em (1000, 2048)
- x-height and cap-height extraction and fallbacks
- Normal line height calculation
- Baseline offset and em height
- Line height with multipliers and absolute values
- Half-leading calculation
- Underline and strikeout metrics
- Font style flags
- Edge cases (very small/large sizes, zero descent)
- Clone and PartialEq implementations
- Debug formatting
- Integration with fontdb system fonts
- extract_metrics convenience function

**Test gaps:**
- Variable font testing (requires test fonts)
- Negative line gap (rare but possible)
- TTC font collection testing

## Files Created

1. `src/text/font/mod.rs` - Font module with re-exports
2. `src/text/font/metrics.rs` - FontMetrics implementation (500+ lines)
3. `tests/font_metrics_test.rs` - Comprehensive tests (450+ lines)
4. `outputs/notes/W3.T16-notes.md` - This file

## Verification Results

```
✅ cargo build - SUCCESS
✅ cargo test --test font_metrics_test - 32/32 tests passed
✅ cargo clippy -- -D warnings - No warnings (vendor/taffy warnings ignored)
✅ cargo fmt --check - Properly formatted
```

---

**Task:** W3.T16 - Implement Font Metrics Extraction
**Status:** ✅ COMPLETE
**Time Taken:** ~4 hours (estimated 6-8 hours)
**Last Updated:** 2025-11-22
