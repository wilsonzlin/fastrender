# W4.T15: Integrate Inline Layout with Float Context - Output Notes

## Implementation Summary

Implemented the float integration layer for inline layout that enables inline content (text, inline boxes) to wrap around floated elements per CSS 2.1 Section 9.5. This module provides the bridge between the `FloatContext` (implemented in W3.T10) and inline formatting context layout.

The implementation includes:

1. **LineSpace** - A struct representing available horizontal space for a line at a given Y position
2. **InlineFloatIntegration** - Read-only helper for querying float positions during inline layout
3. **InlineFloatIntegrationMut** - Mutable helper for both querying and placing inline-level floats
4. **LineSpaceIterator** - Iterator over line spaces at float boundaries

The module enables inline layout algorithms to:
- Query available width at any Y position accounting for floats
- Find space for lines that require minimum widths
- Handle clearance when elements have the `clear` property
- Place inline-level floats during inline layout
- Iterate over line spaces to understand where available width changes

## Files Created/Modified

### New Files

1. **`src/layout/inline/mod.rs`** - Module declaration and re-exports
   - Re-exports all public types from `float_integration`

2. **`src/layout/inline/float_integration.rs`** - Main implementation
   - `LineSpace` struct with helper methods
   - `LineSpaceOptions` for configuring line space queries
   - `InlineFloatIntegration` for read-only float queries
   - `InlineFloatIntegrationMut` for mutable float operations
   - `LineSpaceIterator` for iterating over float boundaries
   - `PlacedInlineFloat` result type
   - Comprehensive unit tests (27 tests)

3. **`tests/layout/test_inline_float.rs`** - Integration tests
   - Tests for LineSpace construction and methods
   - Tests for LineSpaceOptions builder pattern
   - Integration tests for read-only queries
   - Integration tests for mutable operations
   - Complex scenario tests (narrow passages, stacked floats, etc.)

### Modified Files

1. **`src/layout/mod.rs`** - Added inline module declaration and comment
2. **`tests/layout/mod.rs`** - Added test_inline_float module

## API Contracts

### LineSpace

```rust
/// Describes the available space for a line box
pub struct LineSpace {
    pub y: f32,           // Y position where this line space applies
    pub left_edge: f32,   // X coordinate where content can begin
    pub width: f32,       // Available width for content
    pub right_edge: f32,  // X coordinate where content must end
}

impl LineSpace {
    pub fn new(y: f32, left_edge: f32, width: f32) -> Self;
    pub fn full_width(y: f32, containing_width: f32) -> Self;
    pub fn has_space(&self) -> bool;
    pub fn fits(&self, required_width: f32) -> bool;
}
```

### LineSpaceOptions

```rust
/// Options for finding line space
pub struct LineSpaceOptions {
    pub min_width: f32,      // Minimum width required for the line
    pub line_height: f32,    // Height of the line box
    pub allow_zero_width: bool,
}

impl LineSpaceOptions {
    pub fn default() -> Self;
    pub fn with_min_width(min_width: f32) -> Self;
    pub fn with_line_height(line_height: f32) -> Self;
    pub fn min_width(mut self, min_width: f32) -> Self;
    pub fn line_height(mut self, line_height: f32) -> Self;
}
```

### InlineFloatIntegration (Read-Only)

```rust
/// Integration helper for inline layout with floats
pub struct InlineFloatIntegration<'a> {
    float_ctx: &'a FloatContext,
}

impl<'a> InlineFloatIntegration<'a> {
    pub fn new(float_ctx: &'a FloatContext) -> Self;
    pub fn containing_width(&self) -> f32;
    pub fn has_floats(&self) -> bool;
    pub fn get_line_space(&self, y: f32) -> LineSpace;
    pub fn get_line_space_in_range(&self, y_start: f32, y_end: f32) -> LineSpace;
    pub fn find_line_space(&self, start_y: f32, options: LineSpaceOptions) -> LineSpace;
    pub fn find_line_space_with_clear(&self, start_y: f32, clear: Clear, options: LineSpaceOptions) -> LineSpace;
    pub fn left_edge_at(&self, y: f32) -> f32;
    pub fn right_edge_at(&self, y: f32) -> f32;
    pub fn floats_bottom(&self) -> f32;
    pub fn line_fits_at(&self, y: f32, width: f32, height: f32) -> bool;
}
```

### InlineFloatIntegrationMut (Mutable)

```rust
/// Mutable integration helper for inline layout with floats
pub struct InlineFloatIntegrationMut<'a> {
    float_ctx: &'a mut FloatContext,
}

impl<'a> InlineFloatIntegrationMut<'a> {
    pub fn new(float_ctx: &'a mut FloatContext) -> Self;
    // All read methods from InlineFloatIntegration...
    pub fn place_inline_float(&mut self, side: FloatSide, width: f32, height: f32, current_line_y: f32) -> PlacedInlineFloat;
    pub fn compute_clearance(&self, y: f32, clear: Clear) -> f32;
    pub fn clearance_amount(&self, y: f32, clear: Clear) -> f32;
    pub fn set_current_y(&mut self, y: f32);
    pub fn current_y(&self) -> f32;
}
```

### PlacedInlineFloat

```rust
/// Result of placing an inline float
pub struct PlacedInlineFloat {
    pub rect: Rect,         // The computed position for the float
    pub side: FloatSide,    // Which side the float is placed on
    pub next_line_y: f32,   // Y position after placing this float
}
```

### LineSpaceIterator

```rust
/// Iterator over line spaces at float boundaries
pub struct LineSpaceIterator<'a>;

impl<'a> Iterator for LineSpaceIterator<'a> {
    type Item = LineSpace;
    fn next(&mut self) -> Option<Self::Item>;
}

/// Factory function
pub fn line_spaces<'a>(float_ctx: &'a FloatContext, start_y: f32, end_y: f32) -> LineSpaceIterator<'a>;
```

## Decisions Made

### 1. Separate Read-Only and Mutable Helpers

**Decision:** Created two separate structs - `InlineFloatIntegration` (read-only) and `InlineFloatIntegrationMut` (mutable).

**Rationale:**
- During most of inline layout, only read operations are needed
- Separating concerns allows compile-time enforcement of borrow rules
- The mutable version is only needed when placing inline-level floats

### 2. LineSpace as Value Type

**Decision:** `LineSpace` is a simple struct with public fields rather than an opaque type.

**Rationale:**
- Inline layout needs direct access to left_edge, width, right_edge
- No complex invariants to maintain
- Encourages functional style: get space, use values, get new space

### 3. Builder Pattern for Options

**Decision:** Used builder pattern for `LineSpaceOptions`.

**Rationale:**
- Allows optional configuration without many constructor variants
- Makes calling code self-documenting
- Easy to extend with new options in the future

### 4. Float Placement Respects Current Line

**Decision:** When placing inline floats, the float's top cannot be higher than `current_line_y`.

**Rationale:**
- CSS 2.1 Section 9.5.1: "A floating box's outer top may not be higher than the top of any line-box containing a box generated by an element earlier in the source document"
- This ensures floats appear at or below the line where they're encountered

## Spec Interpretations

### CSS 2.1 Section 9.5 - Float Behavior

1. **Line shortening:** "Line boxes next to a float are shortened to make room for the float's margin box." - Implemented via `get_line_space()` which computes available width accounting for floats.

2. **Insufficient space:** "If there is not enough horizontal room for the float, it is shifted downward until either it fits or there are no more floats present." - Implemented via `find_line_space()` which searches downward for space.

3. **Clearance:** "The 'clear' property indicates which sides of an element's box(es) may not be adjacent to an earlier floating box." - Implemented via `find_line_space_with_clear()`.

### CSS 2.1 Section 9.5.1 - Float Position

1. **Float placement from inline content:** When a float is encountered during inline layout, it's placed with `min_y` set to the current line's Y position. This ensures the float appears at or below the current line.

## Discoveries & Gotchas

### 1. Range vs. Point Queries

**Discovery:** Line space queries come in two forms:
- Point query: What's available at exactly this Y?
- Range query: What's the minimum available over this Y range?

**Gotcha:** Using point queries for tall elements will miss float interference at the bottom of the element. Always use range queries for elements with known height.

### 2. Float Boundaries and Line Breaking

**Discovery:** When laying out text that spans a float boundary (e.g., float ends at y=100, text goes from y=80 to y=120), the conservative approach is to use the most constrained width.

**Gotcha:** The `LineSpaceIterator` yields line spaces at float boundaries, making it easy to handle this case by iterating and breaking appropriately.

### 3. Zero-Width Passages

**Discovery:** Floats can completely fill the available width, leaving zero space for content.

**Gotcha:** Always check `LineSpace::has_space()` before attempting to place content. The `find_line_space()` method will push content down past such passages when searching for space.

### 4. Inline Float Placement Timing

**Discovery:** When an inline-level float is encountered during inline layout, it affects subsequent content on the same line.

**Gotcha:** After placing an inline float, re-query available space before continuing to lay out content on the same line.

## Performance Notes

### Time Complexity

- `get_line_space()`: O(n) where n is the number of floats (must check all floats at Y)
- `find_line_space()`: O(n*m) where m is the number of float boundaries searched
- `line_spaces()` iterator: O(n) per iteration

### Optimization Opportunities

1. **Interval Tree:** For documents with many floats, an interval tree would allow O(log n) queries instead of O(n).

2. **Float Bands:** Pre-computing "bands" of constant available width would accelerate repeated queries at similar Y positions.

3. **Caching:** The `LineSpaceIterator` could cache float boundaries instead of recomputing them.

### Current Implementation

The current O(n) implementation is appropriate for typical documents with few floats. The linear scan is cache-friendly and has low constant factors.

## Recommendations for Downstream Tasks

### For Inline Formatting Context (W4.T12)

**Integration Pattern:**
```rust
// Create integration helper
let mut float_ctx = FloatContext::new(containing_width);
let mut integration = InlineFloatIntegrationMut::new(&mut float_ctx);

// For each line being laid out:
let space = integration.get_line_space(current_y);
// Use space.left_edge and space.width for line breaking

// When encountering an inline float:
let result = integration.place_inline_float(side, width, height, current_y);
// Re-query space after placing float

// For elements with clear property:
let space = integration.find_line_space_with_clear(current_y, clear, opts);
```

**Key Methods:**
- Use `get_line_space()` for simple width queries
- Use `get_line_space_in_range()` when element spans multiple Y values
- Use `find_line_space()` when minimum width is required
- Use `place_inline_float()` to add floats encountered in inline content

### For Block Layout (W3.T04)

Block layout should create the `FloatContext` and pass it to inline layout when processing inline children:

```rust
let mut float_ctx = FloatContext::new(containing_width);

// Process block children...

// When encountering inline children:
let inline_integration = InlineFloatIntegration::new(&float_ctx);
// Pass to inline formatting context
```

### For Line Breaking

When breaking lines, query the available space at each potential line position:

```rust
let opts = LineSpaceOptions::with_min_width(word_width).line_height(line_height);
let space = integration.find_line_space(current_y, opts);

// space.y may be greater than current_y if content was pushed down
// space.width is guaranteed to be >= word_width (or 0 if impossible)
```

## Open Questions

### 1. Inline Float Stacking Order

**Question:** When multiple inline floats are placed on the same line, what's the correct stacking order for z-index?

**Status:** Not currently addressed. May need to track float insertion order for painting.

### 2. Percentage-Based Float Widths

**Question:** Should percentage-based float widths be resolved before or during inline layout?

**Status:** Assumed floats have resolved dimensions. Block layout should resolve percentages before creating `FloatContext`.

### 3. Nested BFC Handling

**Question:** When inline content creates a new BFC (e.g., inline-block), should inner floats be visible to outer inline layout?

**Status:** No - each BFC contains its own floats. Inner floats don't affect outer inline content.

## Test Coverage

### Unit Tests (27 tests in float_integration.rs)

- LineSpace construction and methods (5 tests)
- LineSpaceOptions construction and builder (4 tests)
- InlineFloatIntegration basic queries (5 tests)
- Range queries and find operations (4 tests)
- InlineFloatIntegrationMut operations (5 tests)
- LineSpaceIterator (4 tests)
- Complex scenarios (3 tests)

### Integration Tests (tests/layout/test_inline_float.rs)

- LineSpace tests (6 tests)
- LineSpaceOptions tests (4 tests)
- Integration basic tests (5 tests)
- Range query tests (3 tests)
- Find line space tests (4 tests)
- Clear tests (5 tests)
- Edge query tests (3 tests)
- Mutable integration tests (5 tests)
- Iterator tests (5 tests)
- Complex scenarios (6 tests)
- Clear integration tests (3 tests)
- Floats bottom tests (4 tests)

### Coverage Gaps

1. Text direction (RTL) - not yet implemented
2. Writing modes (vertical) - not yet implemented
3. CSS Shapes integration - future enhancement

## Verification

All verification steps pass:

- `cargo build` - Builds without errors
- `cargo test float_integration` - 27/27 tests pass
- `cargo clippy` - No warnings on new code
- `cargo fmt --check` - Properly formatted

## CSS Specification References

- CSS 2.1 Section 9.4.2: Inline formatting contexts - https://www.w3.org/TR/CSS21/visuren.html#inline-formatting
- CSS 2.1 Section 9.5: Floats - https://www.w3.org/TR/CSS21/visuren.html#floats
- CSS 2.1 Section 9.5.1: Positioning the float - https://www.w3.org/TR/CSS21/visuren.html#float-position
- CSS 2.1 Section 9.5.2: Clear property - https://www.w3.org/TR/CSS21/visuren.html#propdef-clear
