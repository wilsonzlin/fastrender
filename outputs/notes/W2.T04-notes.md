# Task W2.T04 Output Notes

## Implementation Summary

Implemented layout constraints system:
- **AvailableSpace enum**: 4 variants (Definite, Indefinite, MinContent, MaxContent)
- **LayoutConstraints struct**: Width and height constraints
- **Helper methods**: Constructors, shrinking, querying, clamping
- **Comprehensive tests**: 28 tests covering all operations

Constraints describe available space for layout algorithms.

## API Contracts

### Public Types

```rust
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum AvailableSpace {
    Definite(f32),
    Indefinite,
    MinContent,
    MaxContent,
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub struct LayoutConstraints {
    pub available_width: AvailableSpace,
    pub available_height: AvailableSpace,
}
```

### Key Methods

```rust
impl AvailableSpace {
    pub fn is_definite(self) -> bool;
    pub fn to_option(self) -> Option<f32>;
    pub fn shrink_by(self, amount: f32) -> Self;
    pub fn map<F>(self, f: F) -> Self;
}

impl LayoutConstraints {
    pub const fn new(width: AvailableSpace, height: AvailableSpace) -> Self;
    pub const fn definite(width: f32, height: f32) -> Self;
    pub const fn definite_width(width: f32) -> Self;
    pub fn shrink_width_by(self, amount: f32) -> Self;
    pub fn shrink_by(self, width: f32, height: f32) -> Self;
    pub fn is_width_definite(&self) -> bool;
    pub fn width(&self) -> Option<f32>;
    pub fn height(&self) -> Option<f32>;
    pub fn clamp_size(&self, size: Size) -> Size;
}
```

## Decisions Made

### Decision 1: Copy for LayoutConstraints

**Choice:** LayoutConstraints derives Copy
**Rationale:**
- Small type (2 enums, ~16 bytes)
- Frequently passed to functions
- Immutable by design
- No allocation needed

**Impact:** Can pass by value efficiently

### Decision 2: Builder Pattern for Modifications

**Choice:** Methods return new constraints (not &mut self)
**Rationale:**
- Encourages immutability
- Allows method chaining
- Clearer API
- Matches Rust idioms

**Example:** `constraints.shrink_width_by(20).shrink_height_by(10)`

### Decision 3: Separate Min/Max Content

**Choice:** MinContent and MaxContent as separate variants
**Rationale:**
- CSS defines these as distinct sizing modes
- Different algorithms for each
- Not a simple numeric comparison
- Clearer than bool flag

### Decision 4: Getter Method Names

**Choice:** Named getters `width()` and `height()` instead of `definite_width()` and `definite_height()`
**Rationale:**
- Avoids naming conflict with constructors
- More idiomatic Rust (shorter, clearer)
- Rust doesn't support method overloading
- Returns Option<f32> makes "definite" implied

**Impact:** Constructors keep their names (e.g., `definite_width(800.0)`), getters are simpler (e.g., `constraints.width()`)

## Spec Interpretations

### Available Space

**Spec says:** CSS Sizing Level 3 defines available space modes
**Interpretation:** Implemented as enum with 4 variants
**Reasoning:** Direct mapping from spec to code
**Test coverage:** All variants tested

## Discoveries & Gotchas

### Discovery 1: Shrinking Indefinite

**What:** Shrinking indefinite space remains indefinite
**Why it matters:** Margins/padding don't make indefinite definite
**Recommendation:** Always check result after shrinking

### Gotcha 1: Percentage Resolution

**Problem:** Constraints don't resolve percentages
**Solution:** Layout algorithms must resolve based on constraint value
**Warning:** Percentage of indefinite is special case (usually treated as auto)

### Gotcha 2: Min/Max Content vs Intrinsic

**Problem:** Min/max content constraints trigger special sizing
**Solution:** Layout algorithms must have separate code paths
**Example:** Text doesn't wrap for max-content, wraps to min for min-content

### Gotcha 3: Method Naming in Rust

**Problem:** Rust doesn't support method overloading
**Solution:** Cannot have both a constructor and getter with the same name
**Impact:** Used `width()` and `height()` for getters instead of `definite_width()` and `definite_height()`
**Recommendation:** This is more idiomatic Rust anyway - getters should be short

## Performance Notes

### Performance Characteristics
- All operations O(1)
- No allocations
- Copy is fast (small type)
- Pattern matching optimized by compiler

## Recommendations for Downstream Tasks

### For Task W2.T07 (FormattingContext):
- Take LayoutConstraints as first parameter
- Return Size or Rect
- Use `width()` and `height()` methods to check if dimensions are known
- Shrink constraints for child margins/padding

**Example:**
```rust
pub trait FormattingContext {
    fn layout(&self, constraints: LayoutConstraints) -> Size;
}
```

### For Task W3.T04 (Block Layout):
- Use `width()` for width computation
- Height usually indefinite (size to content)
- Shrink by padding/border before child layout
- Clamp child sizes with clamp_size()

**Example:**
```rust
let inner_constraints = constraints
    .shrink_by(padding.horizontal(), padding.vertical());

let child_size = layout_child(child, inner_constraints);
let clamped_size = constraints.clamp_size(child_size);
```

### For Task W4.T12 (Inline Layout):
- Use `width()` for line width
- Create constraints for child inline boxes
- Min/max content for intrinsic width calculation

**Example:**
```rust
let line_width = if let Some(w) = constraints.width() {
    w
} else {
    // Indefinite width - size to content
    compute_intrinsic_width()
};
```

### For Task W4.T15 (Flex Layout):
- Use constraints to determine flex basis
- MinContent/MaxContent for flex sizing algorithm
- Distribute available definite space to flex items

**Example:**
```rust
let available = constraints.width().unwrap_or(0.0);
distribute_space_to_flex_items(available);
```

## Open Questions

None - constraints design is well-defined by CSS spec.

## Test Coverage

### What's Tested
-  All AvailableSpace variants and methods
-  All LayoutConstraints constructors
-  Builder pattern methods
-  Shrinking operations
-  Query methods
-  Size clamping
-  Edge cases (negative shrink, indefinite operations)

### Test Statistics
- Unit tests: 28 tests
- All tests pass: 
- Coverage: All public methods

## Code Quality
-  Clippy passes
-  Rustfmt applied
-  Full documentation
-  Display trait implemented

## References Used
1. CSS Sizing Module Level 3: https://www.w3.org/TR/css-sizing-3/
2. W1.T01-notes.md (Geometry types)
3. W1.T03-notes.md (Length types)

---

**Task completed:** 2025-01-21
**Time taken:** 3.5 hours
**Tests passing:** 28/28
