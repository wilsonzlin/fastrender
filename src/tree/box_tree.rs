//! Box Tree - Represents CSS boxes before layout
//!
//! The box tree is generated from the styled DOM tree and represents
//! the CSS box model. It's independent of layout - it only represents
//! what boxes exist and their styling, not where they're positioned.
//!
//! # Separation of Concerns
//!
//! **Box Tree (this module)**:
//! - Immutable
//! - No positions or final sizes
//! - Represents "what to layout"
//! - Generated once from DOM
//!
//! **Fragment Tree**:
//! - Result of layout
//! - Has positions and sizes
//! - Represents "what was laid out"
//! - Generated per layout pass
//!
//! Reference: CSS Display Module Level 3
//! https://www.w3.org/TR/css-display-3/

use crate::geometry::Size;
use crate::style::display::FormattingContextType;
use crate::style::ComputedStyles;
use std::fmt;
use std::sync::Arc;

// Re-export ComputedStyle as ComputedStyle for compatibility
pub type ComputedStyle = ComputedStyles;

/// Debug information for a box
///
/// This information is optional and used only for debugging/dev tools.
/// It helps identify which DOM element generated a box.
#[derive(Debug, Clone)]
pub struct DebugInfo {
    /// Element tag name (if from element)
    pub tag_name: Option<String>,

    /// Element classes
    pub classes: Vec<String>,

    /// Element ID
    pub id: Option<String>,
}

impl DebugInfo {
    /// Creates debug info from element attributes
    pub fn new(tag_name: Option<String>, id: Option<String>, classes: Vec<String>) -> Self {
        Self { tag_name, classes, id }
    }

    /// Formats as a CSS selector-like string
    ///
    /// # Examples
    ///
    /// - `div#header.navbar` for div with id="header" class="navbar"
    /// - `span.highlight` for span with class="highlight"
    pub fn to_selector(&self) -> String {
        let mut s = String::new();

        if let Some(tag) = &self.tag_name {
            s.push_str(tag);
        }

        if let Some(id) = &self.id {
            s.push('#');
            s.push_str(id);
        }

        for class in &self.classes {
            s.push('.');
            s.push_str(class);
        }

        s
    }
}

/// Types of replaced elements
#[derive(Debug, Clone, PartialEq)]
pub enum ReplacedType {
    /// Image element
    Image {
        /// Source URL or data URI
        src: String,
    },

    /// Video element
    Video {
        /// Source URL
        src: String,
    },

    /// Canvas element
    Canvas,

    /// SVG embedded content
    Svg {
        /// SVG content (inline or reference)
        content: String,
    },

    /// Iframe (nested browsing context)
    Iframe {
        /// Source URL
        src: String,
    },
}

/// Types of boxes in the box tree, categorized by layout behavior
#[derive(Debug, Clone, PartialEq)]
pub enum BoxType {
    /// Block-level box using flow layout
    Block {
        /// What formatting context does this establish?
        formatting_context: FormattingContextType,
    },

    /// Inline-level box using flow layout
    Inline {
        /// For inline-block, this establishes a formatting context
        /// For regular inline, this is None
        formatting_context: Option<FormattingContextType>,
    },

    /// Text box containing actual text content
    Text {
        /// The text content
        text: String,
    },

    /// Replaced element box
    Replaced {
        /// Type of replaced element
        replaced_type: ReplacedType,
        /// Intrinsic size (if known)
        intrinsic_size: Option<Size>,
        /// Intrinsic aspect ratio (width / height)
        aspect_ratio: Option<f32>,
    },

    /// Anonymous box generated by layout
    Anonymous {
        /// Is this a block or inline anonymous box?
        is_block: bool,
    },
}

impl BoxType {
    /// Returns true if this box type is block-level
    pub fn is_block_level(&self) -> bool {
        matches!(
            self,
            BoxType::Block { .. } | BoxType::Replaced { .. } | BoxType::Anonymous { is_block: true }
        )
    }

    /// Returns true if this box type is inline-level
    pub fn is_inline_level(&self) -> bool {
        matches!(
            self,
            BoxType::Inline { .. } | BoxType::Text { .. } | BoxType::Anonymous { is_block: false }
        )
    }

    /// Returns true if this is a text box
    pub fn is_text(&self) -> bool {
        matches!(self, BoxType::Text { .. })
    }

    /// Returns true if this is a replaced element
    pub fn is_replaced(&self) -> bool {
        matches!(self, BoxType::Replaced { .. })
    }

    /// Returns true if this is an anonymous box
    pub fn is_anonymous(&self) -> bool {
        matches!(self, BoxType::Anonymous { .. })
    }

    /// Gets the formatting context this box establishes (if any)
    pub fn formatting_context(&self) -> Option<FormattingContextType> {
        match self {
            BoxType::Block { formatting_context } => Some(*formatting_context),
            BoxType::Inline { formatting_context } => *formatting_context,
            BoxType::Replaced { .. } => Some(FormattingContextType::Block),
            _ => None,
        }
    }
}

impl fmt::Display for BoxType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            BoxType::Block { .. } => write!(f, "Block"),
            BoxType::Inline { .. } => write!(f, "Inline"),
            BoxType::Text { .. } => write!(f, "Text"),
            BoxType::Replaced { .. } => write!(f, "Replaced"),
            BoxType::Anonymous { is_block } => {
                if *is_block {
                    write!(f, "AnonymousBlock")
                } else {
                    write!(f, "AnonymousInline")
                }
            }
        }
    }
}

/// A single box in the box tree
///
/// Represents a CSS box (could be element, text, anonymous, etc.)
///
/// # Important Properties
///
/// - **Immutable**: Once created, a BoxNode doesn't change
/// - **No Position**: Boxes don't know where they'll be positioned (that's fragments)
/// - **Shared Styles**: ComputedStyle is Arc-ed and shared with fragments
/// - **Recursive**: Children form a tree
#[derive(Debug, Clone)]
pub struct BoxNode {
    /// Computed style for this box (shared with fragments)
    pub style: Arc<ComputedStyle>,

    /// What kind of box is this?
    pub box_type: BoxType,

    /// Child boxes in document order
    pub children: Vec<BoxNode>,

    /// Debug information (element name, class, id)
    pub debug_info: Option<DebugInfo>,
}

impl BoxNode {
    /// Creates a new block box
    pub fn new_block(style: Arc<ComputedStyle>, fc: FormattingContextType, children: Vec<BoxNode>) -> Self {
        Self {
            style,
            box_type: BoxType::Block { formatting_context: fc },
            children,
            debug_info: None,
        }
    }

    /// Creates a new inline box
    pub fn new_inline(style: Arc<ComputedStyle>, children: Vec<BoxNode>) -> Self {
        Self {
            style,
            box_type: BoxType::Inline {
                formatting_context: None,
            },
            children,
            debug_info: None,
        }
    }

    /// Creates a new inline-block box
    pub fn new_inline_block(style: Arc<ComputedStyle>, fc: FormattingContextType, children: Vec<BoxNode>) -> Self {
        Self {
            style,
            box_type: BoxType::Inline {
                formatting_context: Some(fc),
            },
            children,
            debug_info: None,
        }
    }

    /// Creates a new text box
    pub fn new_text(style: Arc<ComputedStyle>, text: String) -> Self {
        Self {
            style,
            box_type: BoxType::Text { text: text.clone() },
            children: Vec::new(),
            debug_info: None,
        }
    }

    /// Creates a new replaced box
    pub fn new_replaced(
        style: Arc<ComputedStyle>,
        replaced_type: ReplacedType,
        intrinsic_size: Option<Size>,
        aspect_ratio: Option<f32>,
    ) -> Self {
        Self {
            style,
            box_type: BoxType::Replaced {
                replaced_type,
                intrinsic_size,
                aspect_ratio,
            },
            children: Vec::new(),
            debug_info: None,
        }
    }

    /// Creates an anonymous block box
    pub fn new_anonymous_block(style: Arc<ComputedStyle>, children: Vec<BoxNode>) -> Self {
        Self {
            style,
            box_type: BoxType::Anonymous { is_block: true },
            children,
            debug_info: None,
        }
    }

    /// Adds debug information
    pub fn with_debug_info(mut self, info: DebugInfo) -> Self {
        self.debug_info = Some(info);
        self
    }

    /// Returns true if this is a block-level box
    pub fn is_block_level(&self) -> bool {
        self.box_type.is_block_level()
    }

    /// Returns true if this is an inline-level box
    pub fn is_inline_level(&self) -> bool {
        self.box_type.is_inline_level()
    }

    /// Returns true if this is a text box
    pub fn is_text(&self) -> bool {
        self.box_type.is_text()
    }

    /// Returns true if this is a replaced element
    pub fn is_replaced(&self) -> bool {
        self.box_type.is_replaced()
    }

    /// Returns true if this is an anonymous box
    pub fn is_anonymous(&self) -> bool {
        self.box_type.is_anonymous()
    }

    /// Gets the formatting context this box establishes (if any)
    pub fn formatting_context(&self) -> Option<FormattingContextType> {
        self.box_type.formatting_context()
    }

    /// Gets text content if this is a text box
    pub fn text(&self) -> Option<&str> {
        match &self.box_type {
            BoxType::Text { text } => Some(text),
            _ => None,
        }
    }

    /// Returns the number of children
    pub fn child_count(&self) -> usize {
        self.children.len()
    }

    /// Returns an iterator over children
    pub fn children_iter(&self) -> impl Iterator<Item = &BoxNode> {
        self.children.iter()
    }
}

/// A tree of CSS boxes
///
/// The box tree is generated from styled DOM and consumed by layout algorithms.
/// It's immutable after construction.
#[derive(Debug, Clone)]
pub struct BoxTree {
    /// The root box (typically the root element's principal box)
    pub root: BoxNode,
}

impl BoxTree {
    /// Creates a new box tree with the given root
    pub fn new(root: BoxNode) -> Self {
        Self { root }
    }

    /// Counts total boxes in the tree (including root)
    pub fn count_boxes(&self) -> usize {
        fn count_recursive(node: &BoxNode) -> usize {
            1 + node.children.iter().map(count_recursive).sum::<usize>()
        }
        count_recursive(&self.root)
    }

    /// Counts text boxes in the tree
    pub fn count_text_boxes(&self) -> usize {
        fn count_recursive(node: &BoxNode) -> usize {
            let self_count = usize::from(node.is_text());
            self_count + node.children.iter().map(count_recursive).sum::<usize>()
        }
        count_recursive(&self.root)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn default_style() -> Arc<ComputedStyle> {
        Arc::new(ComputedStyle::default())
    }

    #[test]
    fn test_create_block_box() {
        let box_node = BoxNode::new_block(default_style(), FormattingContextType::Block, vec![]);

        assert!(box_node.is_block_level());
        assert!(!box_node.is_inline_level());
        assert_eq!(box_node.formatting_context(), Some(FormattingContextType::Block));
    }

    #[test]
    fn test_create_inline_box() {
        let box_node = BoxNode::new_inline(default_style(), vec![]);

        assert!(box_node.is_inline_level());
        assert!(!box_node.is_block_level());
        assert_eq!(box_node.formatting_context(), None);
    }

    #[test]
    fn test_create_text_box() {
        let box_node = BoxNode::new_text(default_style(), "Hello".to_string());

        assert!(box_node.is_inline_level());
        assert!(box_node.is_text());
        assert_eq!(box_node.text(), Some("Hello"));
        assert_eq!(box_node.children.len(), 0);
    }

    #[test]
    fn test_box_hierarchy() {
        let text1 = BoxNode::new_text(default_style(), "Text 1".to_string());
        let text2 = BoxNode::new_text(default_style(), "Text 2".to_string());

        let inline_box = BoxNode::new_inline(default_style(), vec![text1, text2]);

        let block_box = BoxNode::new_block(default_style(), FormattingContextType::Block, vec![inline_box]);

        assert_eq!(block_box.children.len(), 1);
        assert_eq!(block_box.children[0].children.len(), 2);
        assert_eq!(block_box.child_count(), 1);
    }

    #[test]
    fn test_debug_info() {
        let debug_info = DebugInfo::new(
            Some("div".to_string()),
            Some("header".to_string()),
            vec!["navbar".to_string(), "sticky".to_string()],
        );

        assert_eq!(debug_info.to_selector(), "div#header.navbar.sticky");

        let box_node =
            BoxNode::new_block(default_style(), FormattingContextType::Block, vec![]).with_debug_info(debug_info);

        assert!(box_node.debug_info.is_some());
    }

    #[test]
    fn test_box_tree() {
        let root = BoxNode::new_block(
            default_style(),
            FormattingContextType::Block,
            vec![
                BoxNode::new_text(default_style(), "Text".to_string()),
                BoxNode::new_block(default_style(), FormattingContextType::Block, vec![]),
            ],
        );

        let tree = BoxTree::new(root);

        assert_eq!(tree.count_boxes(), 3); // root + text + block
        assert_eq!(tree.count_text_boxes(), 1);
    }
}
