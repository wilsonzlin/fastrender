//! BoxType enum for categorizing boxes by layout behavior
//!
//! This module provides the BoxType enum which categorizes CSS boxes
//! based on what layout algorithm they need. This is derived from the
//! Display property but simplified for internal use.
//!
//! # Display vs BoxType
//!
//! - **Display**: CSS property value (external API)
//! - **BoxType**: Layout category (internal classification)
//!
//! Multiple Display values can map to the same BoxType when they use
//! the same layout algorithm.
//!
//! # Examples
//!
//! ```
//! use fastrender::tree::BoxType;
//! use fastrender::style::Display;
//!
//! let box_type = BoxType::from(Display::Flex);
//! assert!(box_type.generates_formatting_context());
//! ```

use crate::style::Display;
use std::fmt;

/// Types of boxes in the box tree, categorized by layout behavior
///
/// This enum represents the different kinds of boxes that exist after
/// box generation. Each type requires a different layout algorithm.
///
/// # Variants
///
/// The variants are organized by layout algorithm:
/// - Flow layout: Block, Inline, Text, InlineBlock
/// - Replaced: Replaced
/// - Modern layout: Flex, Grid
/// - Table layout: Table, TableRow, TableCell, etc.
/// - Generated: Anonymous
///
/// # Examples
///
/// ```
/// use fastrender::tree::BoxType;
///
/// let block = BoxType::Block;
/// assert!(block.is_block_container());
///
/// let flex = BoxType::Flex;
/// assert!(flex.generates_formatting_context());
/// ```
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum BoxType {
    /// Block-level box using flow layout
    ///
    /// Generated from: `display: block`, `display: flow-root`, `display: list-item`
    ///
    /// Participates as: Block-level child in BFC
    /// Establishes: Block formatting context
    ///
    /// Examples: div, p, h1, section
    Block,

    /// Inline-level box using flow layout
    ///
    /// Generated from: `display: inline`
    ///
    /// Participates as: Inline-level child in IFC
    /// Establishes: Nothing (participates in parent's IFC)
    ///
    /// Examples: span, a, em, strong
    Inline,

    /// Text content box
    ///
    /// Generated from: Text nodes in DOM
    ///
    /// Participates as: Inline-level child in IFC
    /// Establishes: Nothing
    ///
    /// Contains actual text to be shaped and rendered
    Text,

    /// Replaced element box
    ///
    /// Generated from: `<img>`, `<video>`, `<canvas>`, etc.
    ///
    /// Participates as: Block or inline depending on display
    /// Establishes: Nothing (content is external)
    ///
    /// Has intrinsic dimensions and aspect ratio
    Replaced,

    /// Inline-block box
    ///
    /// Generated from: `display: inline-block`
    ///
    /// Participates as: Inline-level child in IFC
    /// Establishes: Block formatting context
    ///
    /// Acts like inline externally, block internally
    InlineBlock,

    /// Flex container box
    ///
    /// Generated from: `display: flex`, `display: inline-flex`
    ///
    /// Participates as: Block or inline depending on outer display
    /// Establishes: Flex formatting context
    ///
    /// Children are flex items
    Flex,

    /// Grid container box
    ///
    /// Generated from: `display: grid`, `display: inline-grid`
    ///
    /// Participates as: Block or inline depending on outer display
    /// Establishes: Grid formatting context
    ///
    /// Children are grid items
    Grid,

    /// Table wrapper box
    ///
    /// Generated from: `display: table`, `display: inline-table`
    ///
    /// Participates as: Block or inline depending on outer display
    /// Establishes: Table formatting context
    ///
    /// Contains table-internal boxes
    Table,

    /// Table row box
    ///
    /// Generated from: `display: table-row`
    ///
    /// Participates as: Table-internal element
    /// Establishes: Table row context
    TableRow,

    /// Table cell box
    ///
    /// Generated from: `display: table-cell`
    ///
    /// Participates as: Table-internal element
    /// Establishes: Block formatting context
    ///
    /// Acts like block container internally
    TableCell,

    /// Other table-internal boxes
    ///
    /// Generated from: `display: table-*` variants
    ///
    /// Includes: table-row-group, table-header-group, table-footer-group,
    /// table-column, table-column-group, table-caption
    TableOther,

    /// Anonymous box generated by layout
    ///
    /// Generated from: Layout algorithm, not DOM
    ///
    /// Examples:
    /// - Anonymous block box wrapping inline children in block container
    /// - Anonymous inline box wrapping text nodes
    /// - Anonymous table boxes
    Anonymous,
}

impl From<Display> for BoxType {
    /// Converts a Display value to a BoxType
    ///
    /// This simplifies the Display value into the box category needed
    /// for layout purposes. Multiple Display values may map to the same BoxType.
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::tree::BoxType;
    /// use fastrender::style::Display;
    ///
    /// assert_eq!(BoxType::from(Display::Block), BoxType::Block);
    /// assert_eq!(BoxType::from(Display::Flex), BoxType::Flex);
    /// assert_eq!(BoxType::from(Display::InlineFlex), BoxType::Flex);
    /// ```
    ///
    /// # Mapping Rules
    ///
    /// - `block`, `flow-root`, `list-item` → Block
    /// - `inline` → Inline
    /// - `inline-block` → InlineBlock
    /// - `flex`, `inline-flex` → Flex (outer display handled elsewhere)
    /// - `grid`, `inline-grid` → Grid
    /// - `table`, `inline-table` → Table
    /// - `table-row` → TableRow
    /// - `table-cell` → TableCell
    /// - Other table internals → TableOther
    ///
    /// # Note on Outer Display
    ///
    /// The outer display type (block vs inline) is handled by looking at
    /// the Display value separately. BoxType represents the inner layout mode.
    fn from(display: Display) -> Self {
        match display {
            Display::Block | Display::FlowRoot | Display::ListItem => BoxType::Block,
            Display::Inline => BoxType::Inline,
            Display::InlineBlock => BoxType::InlineBlock,
            Display::Flex | Display::InlineFlex => BoxType::Flex,
            Display::Grid | Display::InlineGrid => BoxType::Grid,
            Display::Table | Display::InlineTable => BoxType::Table,
            Display::TableRow => BoxType::TableRow,
            Display::TableCell => BoxType::TableCell,
            Display::TableRowGroup
            | Display::TableHeaderGroup
            | Display::TableFooterGroup
            | Display::TableColumn
            | Display::TableColumnGroup
            | Display::TableCaption => BoxType::TableOther,
            Display::Contents => {
                // display: contents boxes are special - they don't generate boxes
                // This should be handled during box generation, not here
                // But if we need a type, treat as anonymous
                BoxType::Anonymous
            }
            Display::None => {
                // display: none doesn't generate boxes
                // This should never be converted to BoxType
                // But if it happens, use Anonymous as placeholder
                BoxType::Anonymous
            }
        }
    }
}

impl BoxType {
    /// Returns true if this box type is a block container
    ///
    /// Block containers can contain block-level children and establish
    /// a block formatting context.
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::tree::BoxType;
    ///
    /// assert!(BoxType::Block.is_block_container());
    /// assert!(BoxType::InlineBlock.is_block_container());
    /// assert!(BoxType::TableCell.is_block_container());
    /// assert!(!BoxType::Inline.is_block_container());
    /// assert!(!BoxType::Flex.is_block_container());
    /// ```
    pub fn is_block_container(self) -> bool {
        matches!(self, BoxType::Block | BoxType::InlineBlock | BoxType::TableCell)
    }

    /// Returns true if this box type is an inline container
    ///
    /// Inline containers can contain inline-level children.
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::tree::BoxType;
    ///
    /// assert!(BoxType::Inline.is_inline_container());
    /// assert!(!BoxType::Block.is_inline_container());
    /// ```
    pub fn is_inline_container(self) -> bool {
        matches!(self, BoxType::Inline)
    }

    /// Returns true if this box type generates a formatting context
    ///
    /// Boxes that generate formatting contexts are independent layout roots.
    /// Their internal layout doesn't affect outside, and vice versa.
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::tree::BoxType;
    ///
    /// assert!(BoxType::Flex.generates_formatting_context());
    /// assert!(BoxType::Grid.generates_formatting_context());
    /// assert!(BoxType::InlineBlock.generates_formatting_context());
    /// assert!(!BoxType::Inline.generates_formatting_context());
    /// ```
    pub fn generates_formatting_context(self) -> bool {
        matches!(
            self,
            BoxType::Block | BoxType::InlineBlock | BoxType::Flex | BoxType::Grid | BoxType::Table | BoxType::TableCell
        )
    }

    /// Returns the type of formatting context this box establishes
    ///
    /// Returns None if this box doesn't establish a formatting context.
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::tree::{BoxType, FormattingContextType};
    ///
    /// assert_eq!(
    ///     BoxType::Flex.formatting_context_type(),
    ///     Some(FormattingContextType::Flex)
    /// );
    /// assert_eq!(
    ///     BoxType::Block.formatting_context_type(),
    ///     Some(FormattingContextType::Block)
    /// );
    /// assert_eq!(BoxType::Inline.formatting_context_type(), None);
    /// ```
    pub fn formatting_context_type(self) -> Option<FormattingContextType> {
        match self {
            BoxType::Block | BoxType::InlineBlock | BoxType::TableCell => Some(FormattingContextType::Block),
            BoxType::Flex => Some(FormattingContextType::Flex),
            BoxType::Grid => Some(FormattingContextType::Grid),
            BoxType::Table | BoxType::TableRow | BoxType::TableOther => Some(FormattingContextType::Table),
            BoxType::Inline | BoxType::Text | BoxType::Replaced | BoxType::Anonymous => None,
        }
    }

    /// Returns true if this is a table-internal box type
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::tree::BoxType;
    ///
    /// assert!(BoxType::TableRow.is_table_internal());
    /// assert!(BoxType::TableCell.is_table_internal());
    /// assert!(!BoxType::Table.is_table_internal());
    /// ```
    pub fn is_table_internal(self) -> bool {
        matches!(self, BoxType::TableRow | BoxType::TableCell | BoxType::TableOther)
    }

    /// Returns true if this is a replaced element
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::tree::BoxType;
    ///
    /// assert!(BoxType::Replaced.is_replaced());
    /// assert!(!BoxType::Block.is_replaced());
    /// ```
    pub fn is_replaced(self) -> bool {
        matches!(self, BoxType::Replaced)
    }

    /// Returns true if this is a text box
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::tree::BoxType;
    ///
    /// assert!(BoxType::Text.is_text());
    /// assert!(!BoxType::Inline.is_text());
    /// ```
    pub fn is_text(self) -> bool {
        matches!(self, BoxType::Text)
    }

    /// Returns true if this is an anonymous box
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::tree::BoxType;
    ///
    /// assert!(BoxType::Anonymous.is_anonymous());
    /// assert!(!BoxType::Block.is_anonymous());
    /// ```
    pub fn is_anonymous(self) -> bool {
        matches!(self, BoxType::Anonymous)
    }

    /// Returns a human-readable name for this box type
    ///
    /// # Examples
    ///
    /// ```
    /// use fastrender::tree::BoxType;
    ///
    /// assert_eq!(BoxType::Block.name(), "Block");
    /// assert_eq!(BoxType::Flex.name(), "Flex");
    /// ```
    pub fn name(self) -> &'static str {
        match self {
            BoxType::Block => "Block",
            BoxType::Inline => "Inline",
            BoxType::Text => "Text",
            BoxType::Replaced => "Replaced",
            BoxType::InlineBlock => "InlineBlock",
            BoxType::Flex => "Flex",
            BoxType::Grid => "Grid",
            BoxType::Table => "Table",
            BoxType::TableRow => "TableRow",
            BoxType::TableCell => "TableCell",
            BoxType::TableOther => "TableOther",
            BoxType::Anonymous => "Anonymous",
        }
    }
}

/// Types of formatting contexts
///
/// This enum represents the different formatting contexts that boxes can establish.
/// It's used by the layout system to dispatch to the correct layout algorithm.
///
/// # Examples
///
/// ```
/// use fastrender::tree::FormattingContextType;
///
/// let fc_type = FormattingContextType::Flex;
/// ```
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum FormattingContextType {
    /// Block formatting context
    Block,
    /// Inline formatting context
    Inline,
    /// Flex formatting context
    Flex,
    /// Grid formatting context
    Grid,
    /// Table formatting context
    Table,
}

impl fmt::Display for BoxType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.name())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    // Conversion tests
    #[test]
    fn test_display_to_boxtype_block() {
        assert_eq!(BoxType::from(Display::Block), BoxType::Block);
        assert_eq!(BoxType::from(Display::FlowRoot), BoxType::Block);
        assert_eq!(BoxType::from(Display::ListItem), BoxType::Block);
    }

    #[test]
    fn test_display_to_boxtype_inline() {
        assert_eq!(BoxType::from(Display::Inline), BoxType::Inline);
    }

    #[test]
    fn test_display_to_boxtype_inline_block() {
        assert_eq!(BoxType::from(Display::InlineBlock), BoxType::InlineBlock);
    }

    #[test]
    fn test_display_to_boxtype_flex() {
        // Both flex and inline-flex map to Flex
        assert_eq!(BoxType::from(Display::Flex), BoxType::Flex);
        assert_eq!(BoxType::from(Display::InlineFlex), BoxType::Flex);
    }

    #[test]
    fn test_display_to_boxtype_grid() {
        // Both grid and inline-grid map to Grid
        assert_eq!(BoxType::from(Display::Grid), BoxType::Grid);
        assert_eq!(BoxType::from(Display::InlineGrid), BoxType::Grid);
    }

    #[test]
    fn test_display_to_boxtype_table() {
        assert_eq!(BoxType::from(Display::Table), BoxType::Table);
        assert_eq!(BoxType::from(Display::InlineTable), BoxType::Table);
    }

    #[test]
    fn test_display_to_boxtype_table_internals() {
        assert_eq!(BoxType::from(Display::TableRow), BoxType::TableRow);
        assert_eq!(BoxType::from(Display::TableCell), BoxType::TableCell);
        assert_eq!(BoxType::from(Display::TableRowGroup), BoxType::TableOther);
        assert_eq!(BoxType::from(Display::TableHeaderGroup), BoxType::TableOther);
        assert_eq!(BoxType::from(Display::TableFooterGroup), BoxType::TableOther);
        assert_eq!(BoxType::from(Display::TableColumn), BoxType::TableOther);
        assert_eq!(BoxType::from(Display::TableColumnGroup), BoxType::TableOther);
        assert_eq!(BoxType::from(Display::TableCaption), BoxType::TableOther);
    }

    #[test]
    fn test_display_to_boxtype_special_cases() {
        // Contents and None should map to Anonymous
        assert_eq!(BoxType::from(Display::Contents), BoxType::Anonymous);
        assert_eq!(BoxType::from(Display::None), BoxType::Anonymous);
    }

    // is_block_container tests
    #[test]
    fn test_is_block_container() {
        assert!(BoxType::Block.is_block_container());
        assert!(BoxType::InlineBlock.is_block_container());
        assert!(BoxType::TableCell.is_block_container());

        assert!(!BoxType::Inline.is_block_container());
        assert!(!BoxType::Text.is_block_container());
        assert!(!BoxType::Flex.is_block_container());
        assert!(!BoxType::Grid.is_block_container());
        assert!(!BoxType::Replaced.is_block_container());
    }

    // is_inline_container tests
    #[test]
    fn test_is_inline_container() {
        assert!(BoxType::Inline.is_inline_container());

        assert!(!BoxType::Block.is_inline_container());
        assert!(!BoxType::Text.is_inline_container());
    }

    // generates_formatting_context tests
    #[test]
    fn test_generates_formatting_context() {
        assert!(BoxType::Block.generates_formatting_context());
        assert!(BoxType::InlineBlock.generates_formatting_context());
        assert!(BoxType::Flex.generates_formatting_context());
        assert!(BoxType::Grid.generates_formatting_context());
        assert!(BoxType::Table.generates_formatting_context());
        assert!(BoxType::TableCell.generates_formatting_context());

        assert!(!BoxType::Inline.generates_formatting_context());
        assert!(!BoxType::Text.generates_formatting_context());
        assert!(!BoxType::Replaced.generates_formatting_context());
    }

    // formatting_context_type tests
    #[test]
    fn test_formatting_context_type() {
        assert_eq!(
            BoxType::Block.formatting_context_type(),
            Some(FormattingContextType::Block)
        );
        assert_eq!(
            BoxType::InlineBlock.formatting_context_type(),
            Some(FormattingContextType::Block)
        );
        assert_eq!(
            BoxType::TableCell.formatting_context_type(),
            Some(FormattingContextType::Block)
        );
        assert_eq!(
            BoxType::Flex.formatting_context_type(),
            Some(FormattingContextType::Flex)
        );
        assert_eq!(
            BoxType::Grid.formatting_context_type(),
            Some(FormattingContextType::Grid)
        );
        assert_eq!(
            BoxType::Table.formatting_context_type(),
            Some(FormattingContextType::Table)
        );
        assert_eq!(
            BoxType::TableRow.formatting_context_type(),
            Some(FormattingContextType::Table)
        );
        assert_eq!(
            BoxType::TableOther.formatting_context_type(),
            Some(FormattingContextType::Table)
        );

        assert_eq!(BoxType::Inline.formatting_context_type(), None);
        assert_eq!(BoxType::Text.formatting_context_type(), None);
        assert_eq!(BoxType::Replaced.formatting_context_type(), None);
        assert_eq!(BoxType::Anonymous.formatting_context_type(), None);
    }

    // is_table_internal tests
    #[test]
    fn test_is_table_internal() {
        assert!(BoxType::TableRow.is_table_internal());
        assert!(BoxType::TableCell.is_table_internal());
        assert!(BoxType::TableOther.is_table_internal());

        assert!(!BoxType::Table.is_table_internal());
        assert!(!BoxType::Block.is_table_internal());
    }

    // Type check tests
    #[test]
    fn test_is_replaced() {
        assert!(BoxType::Replaced.is_replaced());
        assert!(!BoxType::Block.is_replaced());
        assert!(!BoxType::Text.is_replaced());
    }

    #[test]
    fn test_is_text() {
        assert!(BoxType::Text.is_text());
        assert!(!BoxType::Inline.is_text());
        assert!(!BoxType::Block.is_text());
    }

    #[test]
    fn test_is_anonymous() {
        assert!(BoxType::Anonymous.is_anonymous());
        assert!(!BoxType::Block.is_anonymous());
        assert!(!BoxType::Inline.is_anonymous());
    }

    // name tests
    #[test]
    fn test_name() {
        assert_eq!(BoxType::Block.name(), "Block");
        assert_eq!(BoxType::Inline.name(), "Inline");
        assert_eq!(BoxType::Flex.name(), "Flex");
        assert_eq!(BoxType::Text.name(), "Text");
    }

    // Display trait test
    #[test]
    fn test_display_formatting() {
        assert_eq!(format!("{}", BoxType::Block), "Block");
        assert_eq!(format!("{}", BoxType::Flex), "Flex");
        assert_eq!(format!("{}", BoxType::TableCell), "TableCell");
    }

    // Comprehensive conversion tests
    #[test]
    fn test_all_display_variants_convert() {
        // Ensure every Display variant has a BoxType mapping
        let _ = BoxType::from(Display::None);
        let _ = BoxType::from(Display::Block);
        let _ = BoxType::from(Display::Inline);
        let _ = BoxType::from(Display::InlineBlock);
        let _ = BoxType::from(Display::Flex);
        let _ = BoxType::from(Display::InlineFlex);
        let _ = BoxType::from(Display::Grid);
        let _ = BoxType::from(Display::InlineGrid);
        let _ = BoxType::from(Display::Table);
        let _ = BoxType::from(Display::InlineTable);
        let _ = BoxType::from(Display::TableRow);
        let _ = BoxType::from(Display::TableCell);
        let _ = BoxType::from(Display::TableRowGroup);
        let _ = BoxType::from(Display::TableHeaderGroup);
        let _ = BoxType::from(Display::TableFooterGroup);
        let _ = BoxType::from(Display::TableColumn);
        let _ = BoxType::from(Display::TableColumnGroup);
        let _ = BoxType::from(Display::TableCaption);
        let _ = BoxType::from(Display::ListItem);
        let _ = BoxType::from(Display::FlowRoot);
        let _ = BoxType::from(Display::Contents);
    }

    // Edge cases
    #[test]
    fn test_boxtype_equality() {
        assert_eq!(BoxType::Block, BoxType::Block);
        assert_ne!(BoxType::Block, BoxType::Inline);
    }

    #[test]
    fn test_boxtype_copy() {
        let bt1 = BoxType::Flex;
        let bt2 = bt1;
        assert_eq!(bt1, bt2);
    }

    #[test]
    fn test_formatting_context_type_equality() {
        assert_eq!(FormattingContextType::Block, FormattingContextType::Block);
        assert_ne!(FormattingContextType::Block, FormattingContextType::Flex);
    }
}
