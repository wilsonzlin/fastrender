//! Float Context for CSS float layout
//!
//! This module implements the float context that manages floated boxes within
//! a block formatting context. It tracks float positions and computes available
//! space for content and new floats.
//!
//! # CSS Float Layout Algorithm
//!
//! According to CSS 2.1 Section 9.5, floats are positioned as follows:
//!
//! 1. The float's top may not be higher than the top of its containing block
//! 2. The float's top may not be higher than the top of any earlier float
//! 3. A float's left (or right) outer edge may not be to the left (or right)
//!    of its containing block's edge
//! 4. A left-floating box must be as far left as possible; a right-floating
//!    box must be as far right as possible
//! 5. The outer top of a floating box may not be higher than the outer top
//!    of any block or floated box generated by an element earlier in the source
//! 6. A floating box's outer top may not be higher than the top of any line-box
//!    containing a box generated by an element earlier in the source
//! 7. A left-floating box that has another left-floating box to its left may
//!    not have its right outer edge to the right of its containing block's
//!    right edge
//! 8. A floating box must be placed as high as possible
//! 9. A left-floating box must be put as far to the left as possible, a
//!    right-floating box must be put as far to the right as possible
//!
//! # Clear Property
//!
//! CSS 2.1 Section 9.5.2 defines the `clear` property which introduces
//! clearance - extra space above an element's margin-top that pushes the
//! element below any floats.
//!
//! # References
//!
//! - CSS 2.1 Section 9.5: <https://www.w3.org/TR/CSS21/visuren.html#floats>
//! - CSS 2.1 Section 9.5.1: <https://www.w3.org/TR/CSS21/visuren.html#float-position>
//! - CSS 2.1 Section 9.5.2: <https://www.w3.org/TR/CSS21/visuren.html#propdef-clear>

use crate::debug::runtime;
use crate::error::{RenderError, RenderStage};
use crate::geometry::Rect;
use crate::layout::float_shape::FloatShape;
use crate::layout::formatting_context::LayoutError;
use crate::render_control::check_active_periodic;
use crate::style::float::Clear;
use crate::style::float::Float;
use std::cell::{Cell, RefCell};
use std::cmp::{Ordering, Reverse};
use std::collections::BinaryHeap;
use std::sync::atomic::AtomicU64;
use std::sync::atomic::Ordering as AtomicOrdering;
use std::sync::Arc;
use std::time::Duration;

/// Side on which a float is placed
///
/// This enum represents the physical side where a float is positioned,
/// derived from the CSS `float` property value.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum FloatSide {
  /// Float is positioned on the left side
  Left,
  /// Float is positioned on the right side
  Right,
}

impl From<Float> for Option<FloatSide> {
  fn from(float: Float) -> Self {
    match float {
      Float::Left => Some(FloatSide::Left),
      Float::Right => Some(FloatSide::Right),
      Float::None => None,
    }
  }
}

/// Information about a single float
///
/// Stores the position and dimensions of a floated box within a BFC.
/// All coordinates are relative to the BFC's origin.
#[derive(Debug, Clone, PartialEq)]
pub struct FloatInfo {
  /// The side on which this float is placed
  pub side: FloatSide,

  /// The float's bounding rectangle (margin box)
  ///
  /// Coordinates are relative to the containing block formatting context.
  /// This is the margin box of the float, including margins.
  pub rect: Rect,

  /// Optional wrapping shape from `shape-outside`.
  pub shape: Option<Arc<FloatShape>>,
}

impl FloatInfo {
  /// Create a new float info
  pub fn new(side: FloatSide, rect: Rect) -> Self {
    Self {
      side,
      rect,
      shape: None,
    }
  }

  pub fn new_with_shape(side: FloatSide, rect: Rect, shape: Option<Arc<FloatShape>>) -> Self {
    Self { side, rect, shape }
  }

  /// Create a left float at the given position
  pub fn new_left(x: f32, y: f32, width: f32, height: f32) -> Self {
    Self {
      side: FloatSide::Left,
      rect: Rect::from_xywh(x, y, width, height),
      shape: None,
    }
  }

  /// Create a right float at the given position
  pub fn new_right(x: f32, y: f32, width: f32, height: f32) -> Self {
    Self {
      side: FloatSide::Right,
      rect: Rect::from_xywh(x, y, width, height),
      shape: None,
    }
  }

  /// Returns the top edge of the float
  pub fn top(&self) -> f32 {
    self.rect.y()
  }

  /// Returns the bottom edge of the float (y + height)
  pub fn bottom(&self) -> f32 {
    self.rect.y() + self.rect.height()
  }

  /// Returns the left edge of the float
  pub fn left_edge(&self) -> f32 {
    self.rect.x()
  }

  /// Returns the right edge of the float (x + width)
  pub fn right_edge(&self) -> f32 {
    self.rect.x() + self.rect.width()
  }

  /// Returns true if the float overlaps vertically with a given y range
  pub fn overlaps_y_range(&self, y_start: f32, y_end: f32) -> bool {
    // Float overlaps if it starts before y_end and ends after y_start
    self.top() < y_end && self.bottom() > y_start
  }

  /// Returns true if the float contains the given y coordinate
  pub fn contains_y(&self, y: f32) -> bool {
    y >= self.top() && y < self.bottom()
  }
}

#[derive(Debug, Clone, Copy)]
struct FloatRef {
  side: FloatSide,
  index: usize,
}

#[derive(Debug, Clone, Copy)]
struct FloatKey(f32);

impl PartialEq for FloatKey {
  fn eq(&self, other: &Self) -> bool {
    self.0.to_bits() == other.0.to_bits()
  }
}

impl Eq for FloatKey {}

impl PartialOrd for FloatKey {
  fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
    self
      .0
      .partial_cmp(&other.0)
      .or_else(|| Some(Ordering::Equal))
  }
}

impl Ord for FloatKey {
  fn cmp(&self, other: &Self) -> Ordering {
    self.partial_cmp(other).unwrap_or(Ordering::Equal)
  }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum FloatEventKind {
  Start,
  End,
}

#[derive(Debug, Clone, Copy)]
struct FloatEvent {
  y: f32,
  kind: FloatEventKind,
  float_id: usize,
}

#[derive(Debug, Clone)]
struct FloatSweepState {
  current_y: f32,
  event_cursor: usize,
  active: Vec<bool>,
  active_left: BinaryHeap<(FloatKey, usize)>,
  active_right: BinaryHeap<(Reverse<FloatKey>, usize)>,
  active_shape_left: Vec<usize>,
  active_shape_right: Vec<usize>,
}

impl FloatSweepState {
  fn new(float_count: usize) -> Self {
    Self {
      current_y: f32::NEG_INFINITY,
      event_cursor: 0,
      active: vec![false; float_count],
      active_left: BinaryHeap::new(),
      active_right: BinaryHeap::new(),
      active_shape_left: Vec::new(),
      active_shape_right: Vec::new(),
    }
  }
}

#[derive(Debug, Clone, Copy)]
struct ClearanceSideState {
  cursor: usize,
  current_y: f32,
  max_bottom: f32,
}

impl ClearanceSideState {
  fn new() -> Self {
    Self {
      cursor: 0,
      current_y: f32::NEG_INFINITY,
      max_bottom: f32::NEG_INFINITY,
    }
  }

  fn reset(&mut self) {
    *self = Self::new();
  }
}

#[derive(Debug, Clone, Copy)]
struct ClearanceSweepState {
  left: ClearanceSideState,
  right: ClearanceSideState,
}

impl ClearanceSweepState {
  fn new() -> Self {
    Self {
      left: ClearanceSideState::new(),
      right: ClearanceSideState::new(),
    }
  }
}

#[derive(Debug, Clone, Copy, Default)]
pub struct FloatProfileStats {
  pub width_queries: u64,
  pub range_queries: u64,
  pub boundary_steps: u64,
  pub clearance_queries: u64,
  pub clearance_steps: u64,
}

static FLOAT_WIDTH_QUERIES: AtomicU64 = AtomicU64::new(0);
static FLOAT_RANGE_QUERIES: AtomicU64 = AtomicU64::new(0);
static FLOAT_BOUNDARY_STEPS: AtomicU64 = AtomicU64::new(0);
static FLOAT_CLEARANCE_QUERIES: AtomicU64 = AtomicU64::new(0);
static FLOAT_CLEARANCE_STEPS: AtomicU64 = AtomicU64::new(0);

#[cfg(test)]
thread_local! {
  static FLOAT_PROFILE_OVERRIDE: Cell<Option<bool>> = Cell::new(None);
}

fn profile_enabled() -> bool {
  #[cfg(test)]
  if let Some(enabled) = FLOAT_PROFILE_OVERRIDE.with(|cell| cell.get()) {
    return enabled;
  }
  runtime::runtime_toggles().truthy("FASTR_LAYOUT_PROFILE")
}

fn profile_count_width_query() {
  if profile_enabled() {
    FLOAT_WIDTH_QUERIES.fetch_add(1, AtomicOrdering::Relaxed);
  }
}

fn profile_count_range_query() {
  if profile_enabled() {
    FLOAT_RANGE_QUERIES.fetch_add(1, AtomicOrdering::Relaxed);
  }
}

fn profile_count_boundary_step(delta: u64) {
  if profile_enabled() {
    FLOAT_BOUNDARY_STEPS.fetch_add(delta, AtomicOrdering::Relaxed);
  }
}

fn profile_count_clearance_query() {
  if profile_enabled() {
    FLOAT_CLEARANCE_QUERIES.fetch_add(1, AtomicOrdering::Relaxed);
  }
}

fn profile_count_clearance_step(delta: u64) {
  if profile_enabled() {
    FLOAT_CLEARANCE_STEPS.fetch_add(delta, AtomicOrdering::Relaxed);
  }
}

fn clamp_positive_finite(value: f32) -> f32 {
  if value.is_finite() && value > 0.0 {
    value
  } else {
    0.0
  }
}

pub fn reset_float_profile_counters() {
  FLOAT_WIDTH_QUERIES.store(0, AtomicOrdering::Relaxed);
  FLOAT_RANGE_QUERIES.store(0, AtomicOrdering::Relaxed);
  FLOAT_BOUNDARY_STEPS.store(0, AtomicOrdering::Relaxed);
  FLOAT_CLEARANCE_QUERIES.store(0, AtomicOrdering::Relaxed);
  FLOAT_CLEARANCE_STEPS.store(0, AtomicOrdering::Relaxed);
}

pub fn float_profile_stats() -> FloatProfileStats {
  FloatProfileStats {
    width_queries: FLOAT_WIDTH_QUERIES.load(AtomicOrdering::Relaxed),
    range_queries: FLOAT_RANGE_QUERIES.load(AtomicOrdering::Relaxed),
    boundary_steps: FLOAT_BOUNDARY_STEPS.load(AtomicOrdering::Relaxed),
    clearance_queries: FLOAT_CLEARANCE_QUERIES.load(AtomicOrdering::Relaxed),
    clearance_steps: FLOAT_CLEARANCE_STEPS.load(AtomicOrdering::Relaxed),
  }
}

fn float_vertical_span(float: &FloatInfo) -> (f32, f32) {
  let a = float.top();
  let b = float.bottom();
  (a.min(b), a.max(b))
}

/// Float context for managing floats within a block formatting context
///
/// A FloatContext is created for each block formatting context (BFC) and
/// tracks all floats within that context. It provides methods for:
///
/// - Adding new floats and computing their positions
/// - Computing available width at a given vertical position
/// - Computing clearance for elements with the `clear` property
///
/// # Coordinate System
///
/// All coordinates in FloatContext are relative to the BFC's content box origin.
/// The Y axis increases downward. X increases to the right.
///
/// # Example
///
/// ```
/// use fastrender::{FloatContext, FloatSide};
///
/// // Create a context with a 800px wide containing block
/// let mut ctx = FloatContext::new(800.0);
///
/// // Add a left float at position (0, 0) that is 200x100
/// ctx.add_float_at(
///     FloatSide::Left,
///     0.0, 0.0, 200.0, 100.0
/// );
///
/// // Query available width at y=50 (within the float's vertical extent)
/// let (left_edge, available_width) = ctx.available_width_at_y(50.0);
/// assert_eq!(left_edge, 200.0); // Left edge is pushed right by the float
/// assert_eq!(available_width, 600.0); // 800 - 200 = 600
///
/// // Query available width at y=150 (below the float)
/// let (left_edge, available_width) = ctx.available_width_at_y(150.0);
/// assert_eq!(left_edge, 0.0); // No float interference
/// assert_eq!(available_width, 800.0); // Full width available
/// ```
#[derive(Debug, Clone)]
pub struct FloatContext {
  /// Width of the containing block
  containing_block_width: f32,

  /// List of left floats, in insertion order
  left_floats: Vec<FloatInfo>,

  /// List of right floats, in insertion order
  right_floats: Vec<FloatInfo>,

  /// Map from float id -> backing storage (left/right vector + index).
  float_map: Vec<FloatRef>,

  /// Sorted list of float start/end events for sweep queries.
  events: Vec<FloatEvent>,

  /// Sweep state used to answer monotonic Y queries efficiently.
  sweep_state: RefCell<FloatSweepState>,

  clearance_state: RefCell<ClearanceSweepState>,

  clearance_left_ordered: bool,
  clearance_right_ordered: bool,

  /// Recorded timeout if any float queries exceed the layout deadline.
  timeout_elapsed: Cell<Option<Duration>>,

  /// Current Y position for float placement
  /// This tracks the "float ceiling" - the lowest point we've processed
  current_y: f32,
}

impl FloatContext {
  /// Create a new float context for a containing block of the given width
  ///
  /// # Arguments
  ///
  /// * `containing_block_width` - The width of the BFC's content box
  ///
  /// # Example
  ///
  /// ```
  /// use fastrender::FloatContext;
  ///
  /// let ctx = FloatContext::new(800.0);
  /// assert_eq!(ctx.containing_block_width(), 800.0);
  /// ```
  pub fn new(containing_block_width: f32) -> Self {
    Self {
      containing_block_width,
      left_floats: Vec::new(),
      right_floats: Vec::new(),
      float_map: Vec::new(),
      events: Vec::new(),
      sweep_state: RefCell::new(FloatSweepState::new(0)),
      clearance_state: RefCell::new(ClearanceSweepState::new()),
      clearance_left_ordered: true,
      clearance_right_ordered: true,
      timeout_elapsed: Cell::new(None),
      current_y: 0.0,
    }
  }

  /// Returns the containing block width
  pub fn containing_block_width(&self) -> f32 {
    self.containing_block_width
  }

  fn reset_sweep_state(&mut self) {
    self.sweep_state = RefCell::new(FloatSweepState::new(self.float_map.len()));
  }

  fn reset_clearance_state(&mut self) {
    self.clearance_state = RefCell::new(ClearanceSweepState::new());
  }

  fn record_timeout(&self, elapsed: Duration) {
    let existing = self.timeout_elapsed.get();
    if existing.map_or(true, |current| elapsed < current) {
      self.timeout_elapsed.set(Some(elapsed));
    }
  }

  /// Returns and clears the recorded timeout, if any.
  pub fn take_timeout_error(&self) -> Option<LayoutError> {
    self
      .timeout_elapsed
      .take()
      .map(|elapsed| LayoutError::Timeout { elapsed })
  }

  fn float_info(&self, id: usize) -> &FloatInfo {
    let FloatRef { side, index } = self.float_map[id];
    match side {
      FloatSide::Left => &self.left_floats[index],
      FloatSide::Right => &self.right_floats[index],
    }
  }

  fn sort_events(&mut self) {
    self.events.sort_by(
      |a, b| match a.y.partial_cmp(&b.y).unwrap_or(Ordering::Equal) {
        Ordering::Equal => match (a.kind, b.kind) {
          (FloatEventKind::Start, FloatEventKind::End) => Ordering::Less,
          (FloatEventKind::End, FloatEventKind::Start) => Ordering::Greater,
          _ => a.float_id.cmp(&b.float_id),
        },
        other => other,
      },
    );
  }

  fn ensure_sweep_state(&self, y: f32) -> std::cell::RefMut<FloatSweepState> {
    let mut state = self.sweep_state.borrow_mut();
    if y < state.current_y {
      *state = FloatSweepState::new(self.float_map.len());
    }
    state
  }

  fn apply_event(&self, event: &FloatEvent, state: &mut FloatSweepState) {
    let float = self.float_info(event.float_id);
    match event.kind {
      FloatEventKind::Start => {
        state.active[event.float_id] = true;
        match float.side {
          FloatSide::Left => {
            if float.shape.is_some() {
              state.active_shape_left.push(event.float_id);
            } else {
              state
                .active_left
                .push((FloatKey(float.right_edge()), event.float_id));
            }
          }
          FloatSide::Right => {
            if float.shape.is_some() {
              state.active_shape_right.push(event.float_id);
            } else {
              state
                .active_right
                .push((Reverse(FloatKey(float.left_edge())), event.float_id));
            }
          }
        }
      }
      FloatEventKind::End => {
        state.active[event.float_id] = false;
        if float.shape.is_some() {
          match float.side {
            FloatSide::Left => {
              state
                .active_shape_left
                .retain(|id| *id != event.float_id && state.active[*id]);
            }
            FloatSide::Right => {
              state
                .active_shape_right
                .retain(|id| *id != event.float_id && state.active[*id]);
            }
          }
        }
      }
    }
  }

  fn prune_heaps(&self, state: &mut FloatSweepState) {
    while let Some(&(_, id)) = state.active_left.peek() {
      if state.active[id] {
        break;
      }
      state.active_left.pop();
    }
    while let Some(&(Reverse(_), id)) = state.active_right.peek() {
      if state.active[id] {
        break;
      }
      state.active_right.pop();
    }
  }

  fn advance_sweep_to(&self, target_y: f32, state: &mut FloatSweepState) {
    if target_y < state.current_y {
      *state = FloatSweepState::new(self.float_map.len());
    }
    let mut steps = 0;
    while let Some(event) = self.events.get(state.event_cursor) {
      if event.y > target_y {
        break;
      }
      self.apply_event(event, state);
      state.event_cursor += 1;
      steps += 1;
    }
    if steps > 0 {
      profile_count_boundary_step(steps as u64);
    }
    state.current_y = target_y;
    self.prune_heaps(state);
  }

  fn rect_edges(&self, state: &mut FloatSweepState) -> (f32, f32) {
    self.prune_heaps(state);
    let left_edge = state
      .active_left
      .peek()
      .map(|(edge, _)| edge.0)
      .unwrap_or(0.0);
    let right_edge = state
      .active_right
      .peek()
      .map(|(Reverse(edge), _)| edge.0)
      .unwrap_or(self.containing_block_width);
    (left_edge, right_edge)
  }

  fn edges_at_with_state(&self, state: &mut FloatSweepState, y: f32) -> (f32, f32) {
    let (mut left_edge, mut right_edge) = self.rect_edges(state);
    if !state.active_shape_left.is_empty() {
      for id in state.active_shape_left.iter().copied() {
        if let Some(shape) = self.float_info(id).shape.as_ref() {
          if let Some((_min_x, max_x)) = shape.span_at(y) {
            left_edge = left_edge.max(max_x);
          }
        }
      }
    }
    if !state.active_shape_right.is_empty() {
      for id in state.active_shape_right.iter().copied() {
        if let Some(shape) = self.float_info(id).shape.as_ref() {
          if let Some((min_x, _max_x)) = shape.span_at(y) {
            right_edge = right_edge.min(min_x);
          }
        }
      }
    }
    (left_edge, right_edge)
  }

  fn edges_in_range_with_state(
    &self,
    state: &mut FloatSweepState,
    start: f32,
    end: f32,
  ) -> (f32, f32) {
    let (mut left_edge, mut right_edge) = self.rect_edges(state);
    if !state.active_shape_left.is_empty() {
      for id in state.active_shape_left.iter().copied() {
        if let Some(shape) = self.float_info(id).shape.as_ref() {
          if let Some((_min_x, max_x)) = shape.span_in_range(start, end) {
            left_edge = left_edge.max(max_x);
          }
        }
      }
    }
    if !state.active_shape_right.is_empty() {
      for id in state.active_shape_right.iter().copied() {
        if let Some(shape) = self.float_info(id).shape.as_ref() {
          if let Some((min_x, _max_x)) = shape.span_in_range(start, end) {
            right_edge = right_edge.min(min_x);
          }
        }
      }
    }
    (left_edge, right_edge)
  }

  fn edges_in_range_min_width_with_state(
    &self,
    state: &mut FloatSweepState,
    start: f32,
    end: f32,
  ) -> (f32, f32, f32) {
    debug_assert!(
      start >= state.current_y || state.current_y == f32::NEG_INFINITY,
      "float sweep queries must advance monotonically"
    );
    self.advance_sweep_to(start, state);

    let mut counter = 0usize;
    let mut scan_start = start;
    let mut best_left = 0.0f32;
    let mut best_right = self.containing_block_width;
    let mut best_width = best_right - best_left;
    let mut next_boundary = self
      .next_float_boundary_after_internal(&*state, start)
      .min(end);

    loop {
      if let Err(RenderError::Timeout { elapsed, .. }) =
        check_active_periodic(&mut counter, 256, RenderStage::Layout)
      {
        self.record_timeout(elapsed);
        break;
      }

      let boundary = self
        .next_float_boundary_after_internal(&*state, scan_start)
        .min(end);
      let (left_edge, right_edge) = self.edges_in_range_with_state(state, scan_start, boundary);
      let width = (right_edge - left_edge).max(0.0);
      if width < best_width - f32::EPSILON
        || (width - best_width).abs() < f32::EPSILON && left_edge > best_left
      {
        best_left = left_edge;
        best_right = right_edge;
        best_width = width;
        next_boundary = boundary;
      }

      if boundary >= end || !boundary.is_finite() || boundary <= scan_start {
        break;
      }
      scan_start = boundary;
      self.advance_sweep_to(scan_start, state);
    }

    (best_left, best_right, next_boundary)
  }

  fn edges_in_range_min_width(&self, start: f32, end: f32) -> (f32, f32, f32) {
    let mut state = self.ensure_sweep_state(start);
    self.edges_in_range_min_width_with_state(&mut state, start, end)
  }

  fn next_event_y(&self, state: &FloatSweepState) -> f32 {
    self
      .events
      .get(state.event_cursor)
      .map(|e| e.y)
      .unwrap_or(f32::INFINITY)
  }

  fn next_shape_boundary_after(&self, state: &FloatSweepState, y: f32) -> f32 {
    let mut next = f32::INFINITY;
    for id in state
      .active_shape_left
      .iter()
      .chain(state.active_shape_right.iter())
    {
      if let Some(shape) = self.float_info(*id).shape.as_ref() {
        if let Some(change) = shape.next_change_after(y) {
          if change > y {
            next = next.min(change);
          }
        }
      }
    }
    next
  }

  fn next_float_boundary_after_internal(&self, state: &FloatSweepState, y: f32) -> f32 {
    self
      .next_event_y(state)
      .min(self.next_shape_boundary_after(state, y))
  }

  /// Returns the current Y position
  pub fn current_y(&self) -> f32 {
    self.current_y
  }

  /// Set the current Y position
  ///
  /// This is used to update the position as layout progresses.
  pub fn set_current_y(&mut self, y: f32) {
    self.current_y = y;
  }

  /// Advance the current Y position by the given amount
  pub fn advance_y(&mut self, delta: f32) {
    self.current_y += delta;
  }

  /// Returns true if there are no floats
  pub fn is_empty(&self) -> bool {
    self.float_map.is_empty()
  }

  /// Returns the total number of floats
  pub fn float_count(&self) -> usize {
    self.float_map.len()
  }

  /// Returns all left floats
  pub fn left_floats(&self) -> &[FloatInfo] {
    &self.left_floats
  }

  /// Returns all right floats
  pub fn right_floats(&self) -> &[FloatInfo] {
    &self.right_floats
  }

  /// Add a float at the specified position
  ///
  /// This directly adds a float without computing its position.
  /// Use `compute_float_position` to determine where a float should be placed,
  /// then call this method.
  ///
  /// # Arguments
  ///
  /// * `side` - Which side to place the float
  /// * `x` - X coordinate of the float's margin box
  /// * `y` - Y coordinate of the float's margin box
  /// * `width` - Width of the float's margin box
  /// * `height` - Height of the float's margin box
  pub fn add_float_at(&mut self, side: FloatSide, x: f32, y: f32, width: f32, height: f32) {
    let width = clamp_positive_finite(width);
    let height = clamp_positive_finite(height);
    let float_info = FloatInfo::new(side, Rect::from_xywh(x, y, width, height));
    self.add_float(float_info);
  }

  /// Add a float at the specified position with an optional `shape-outside` wrapping shape.
  pub fn add_float_with_shape(
    &mut self,
    side: FloatSide,
    x: f32,
    y: f32,
    width: f32,
    height: f32,
    shape: Option<FloatShape>,
  ) {
    let width = clamp_positive_finite(width);
    let height = clamp_positive_finite(height);
    let float_info = FloatInfo::new_with_shape(
      side,
      Rect::from_xywh(x, y, width, height),
      shape.map(Arc::new),
    );
    self.add_float(float_info);
  }

  /// Add a float with the given FloatInfo
  pub fn add_float(&mut self, float_info: FloatInfo) {
    let (storage, side) = match float_info.side {
      FloatSide::Left => (&mut self.left_floats, FloatSide::Left),
      FloatSide::Right => (&mut self.right_floats, FloatSide::Right),
    };
    let (start_y, end_y) = float_vertical_span(&float_info);
    if side == FloatSide::Left && self.clearance_left_ordered {
      if let Some(previous) = storage.last() {
        let (prev_start, _) = float_vertical_span(previous);
        if start_y < prev_start {
          self.clearance_left_ordered = false;
        }
      }
    }
    if side == FloatSide::Right && self.clearance_right_ordered {
      if let Some(previous) = storage.last() {
        let (prev_start, _) = float_vertical_span(previous);
        if start_y < prev_start {
          self.clearance_right_ordered = false;
        }
      }
    }
    let index = storage.len();
    storage.push(float_info);

    let id = self.float_map.len();
    self.float_map.push(FloatRef { side, index });

    self.events.push(FloatEvent {
      y: start_y,
      kind: FloatEventKind::Start,
      float_id: id,
    });
    self.events.push(FloatEvent {
      y: end_y,
      kind: FloatEventKind::End,
      float_id: id,
    });
    self.sort_events();
    self.reset_sweep_state();
  }

  fn clearance_side_max_bottom(
    &self,
    y: f32,
    floats: &[FloatInfo],
    state: &mut ClearanceSideState,
  ) -> f32 {
    if y < state.current_y {
      state.reset();
    }

    let mut steps = 0u64;
    while let Some(float) = floats.get(state.cursor) {
      let (top, bottom) = float_vertical_span(float);
      if top <= y {
        state.max_bottom = state.max_bottom.max(bottom);
        state.cursor += 1;
        steps += 1;
      } else {
        break;
      }
    }
    state.current_y = y;
    if steps > 0 {
      profile_count_clearance_step(steps);
    }
    state.max_bottom
  }

  fn clearance_side_max_bottom_slow(&self, y: f32, floats: &[FloatInfo]) -> f32 {
    let mut max_bottom = f32::NEG_INFINITY;
    let mut steps = 0u64;
    for float in floats {
      steps += 1;
      let (top, bottom) = float_vertical_span(float);
      if top <= y {
        max_bottom = max_bottom.max(bottom);
      }
    }
    if steps > 0 {
      profile_count_clearance_step(steps);
    }
    max_bottom
  }

  /// Get the left edge at a given Y position (accounting for left floats)
  ///
  /// Returns the X coordinate where content can start at the given Y.
  pub fn left_edge_at_y(&self, y: f32) -> f32 {
    profile_count_width_query();
    let mut state = self.ensure_sweep_state(y);
    self.advance_sweep_to(y, &mut state);
    let (left_edge, _) = self.edges_at_with_state(&mut state, y);
    left_edge
  }

  /// Get the right edge at a given Y position (accounting for right floats)
  ///
  /// Returns the X coordinate where content must end at the given Y.
  pub fn right_edge_at_y(&self, y: f32) -> f32 {
    profile_count_width_query();
    let mut state = self.ensure_sweep_state(y);
    self.advance_sweep_to(y, &mut state);
    let (_, right_edge) = self.edges_at_with_state(&mut state, y);
    right_edge
  }

  /// Compute available width at a given Y position
  ///
  /// Returns a tuple of (left_edge, available_width) where:
  /// - `left_edge` is the X coordinate where content can start
  /// - `available_width` is the horizontal space available
  ///
  /// # Arguments
  ///
  /// * `y` - The Y coordinate to query
  ///
  /// # Example
  ///
  /// ```
  /// use fastrender::{FloatContext, FloatSide};
  ///
  /// let mut ctx = FloatContext::new(800.0);
  /// ctx.add_float_at(FloatSide::Left, 0.0, 0.0, 200.0, 100.0);
  /// ctx.add_float_at(FloatSide::Right, 600.0, 0.0, 200.0, 100.0);
  ///
  /// let (left, width) = ctx.available_width_at_y(50.0);
  /// assert_eq!(left, 200.0);
  /// assert_eq!(width, 400.0); // 800 - 200 - 200
  /// ```
  pub fn available_width_at_y(&self, y: f32) -> (f32, f32) {
    profile_count_width_query();
    let mut state = self.ensure_sweep_state(y);
    self.advance_sweep_to(y, &mut state);
    let (left_edge, right_edge) = self.edges_at_with_state(&mut state, y);
    let available_width = (right_edge - left_edge).max(0.0);
    (left_edge, available_width)
  }

  /// Compute available width over a vertical range
  ///
  /// Returns the minimum available width (and corresponding left edge)
  /// over the given vertical range. This is used when an element spans
  /// multiple Y positions.
  ///
  /// # Arguments
  ///
  /// * `y_start` - Start of the vertical range (top)
  /// * `y_end` - End of the vertical range (bottom)
  ///
  /// # Returns
  ///
  /// A tuple of (left_edge, available_width) representing the most
  /// constrained position within the range.
  pub fn available_width_in_range(&self, y_start: f32, y_end: f32) -> (f32, f32) {
    profile_count_range_query();
    let end = if y_end > y_start { y_end } else { y_start };
    let (left_edge, right_edge, _) = self.edges_in_range_min_width(y_start, end);
    (left_edge, (right_edge - left_edge).max(0.0))
  }

  /// Returns the next Y coordinate after `y` where float-induced available
  /// width might change.
  ///
  /// This is the minimum of the next float entering/leaving the sweep or the
  /// next `shape-outside` span change for active shapes.
  pub fn next_float_boundary_after(&self, y: f32) -> f32 {
    let mut state = self.ensure_sweep_state(y);
    self.advance_sweep_to(y, &mut state);
    let mut next = self.next_float_boundary_after_internal(&*state, y);
    if next <= y {
      let mut event_cursor = state.event_cursor;
      while let Some(event) = self.events.get(event_cursor) {
        if event.y > y {
          next = next.min(event.y);
          break;
        }
        event_cursor += 1;
      }
      let shape_next = self.next_shape_boundary_after(&*state, y + f32::EPSILON);
      if shape_next > y {
        next = next.min(shape_next);
      }
    }
    if next.is_finite() && next > y {
      next
    } else {
      y
    }
  }

  /// Compute the clearance needed for an element with the given clear value
  ///
  /// Clearance is the amount of extra vertical space needed to push the
  /// element below any interfering floats.
  ///
  /// # Arguments
  ///
  /// * `y` - The current Y position before clearance
  /// * `clear` - The CSS clear property value
  ///
  /// # Returns
  ///
  /// The Y position after applying clearance.
  ///
  /// # Example
  ///
  /// ```
  /// use fastrender::{FloatContext, FloatSide};
  /// use fastrender::Clear;
  ///
  /// let mut ctx = FloatContext::new(800.0);
  /// ctx.add_float_at(FloatSide::Left, 0.0, 0.0, 200.0, 100.0);
  ///
  /// // Clear left at y=50 should push us below the float
  /// let new_y = ctx.compute_clearance(50.0, Clear::Left);
  /// assert_eq!(new_y, 100.0); // Float ends at y=100
  ///
  /// // Clear right at y=50 does nothing (no right floats)
  /// let new_y = ctx.compute_clearance(50.0, Clear::Right);
  /// assert_eq!(new_y, 50.0);
  /// ```
  pub fn compute_clearance(&self, y: f32, clear: Clear) -> f32 {
    if !clear.is_clearing() {
      return y;
    }

    if y.is_nan() {
      return y;
    }

    profile_count_clearance_query();
    let mut clear_y = y;
    let mut state = self.clearance_state.borrow_mut();

    if clear.clears_left() {
      let max_bottom = if self.clearance_left_ordered {
        self.clearance_side_max_bottom(y, &self.left_floats, &mut state.left)
      } else {
        self.clearance_side_max_bottom_slow(y, &self.left_floats)
      };
      clear_y = clear_y.max(max_bottom);
    }

    if clear.clears_right() {
      let max_bottom = if self.clearance_right_ordered {
        self.clearance_side_max_bottom(y, &self.right_floats, &mut state.right)
      } else {
        self.clearance_side_max_bottom_slow(y, &self.right_floats)
      };
      clear_y = clear_y.max(max_bottom);
    }

    clear_y
  }

  /// Get clearance amount as a delta from the current position
  ///
  /// Returns how much the Y position needs to increase to clear floats.
  ///
  /// # Arguments
  ///
  /// * `y` - The current Y position before clearance
  /// * `clear` - The CSS clear property value
  ///
  /// # Returns
  ///
  /// The additional Y offset needed (0 if no clearance needed).
  pub fn clearance_amount(&self, y: f32, clear: Clear) -> f32 {
    let cleared_y = self.compute_clearance(y, clear);
    (cleared_y - y).max(0.0)
  }

  /// Compute the position for a new float
  ///
  /// This implements the CSS 2.1 float positioning algorithm:
  /// 1. The float is placed as high as possible
  /// 2. Left floats go as far left as possible
  /// 3. Right floats go as far right as possible
  /// 4. Floats may not overlap horizontally with other floats
  /// 5. The float's full height must fit alongside existing floats
  ///
  /// # Arguments
  ///
  /// * `side` - Which side to place the float
  /// * `width` - Width of the float's margin box
  /// * `height` - Height of the float's margin box
  /// * `min_y` - Minimum Y position (typically current_y)
  ///
  /// # Returns
  ///
  /// The (x, y) position where the float should be placed.
  ///
  /// # Example
  ///
  /// ```
  /// use fastrender::{FloatContext, FloatSide};
  ///
  /// let mut ctx = FloatContext::new(800.0);
  ///
  /// // First left float goes at (0, 0)
  /// let (x, y) = ctx.compute_float_position(FloatSide::Left, 200.0, 100.0, 0.0);
  /// assert_eq!((x, y), (0.0, 0.0));
  /// ctx.add_float_at(FloatSide::Left, x, y, 200.0, 100.0);
  ///
  /// // Second left float at same Y goes next to first
  /// let (x, y) = ctx.compute_float_position(FloatSide::Left, 200.0, 100.0, 0.0);
  /// assert_eq!((x, y), (200.0, 0.0));
  /// ```
  pub fn compute_float_position(
    &self,
    side: FloatSide,
    width: f32,
    height: f32,
    min_y: f32,
  ) -> (f32, f32) {
    let mut y = min_y;
    let target_width = clamp_positive_finite(width);
    let target_height = clamp_positive_finite(height);
    let mut state = self.ensure_sweep_state(y);
    let mut deadline_counter = 0usize;
    let mut last_left = 0.0f32;
    let mut last_width = self.containing_block_width;

    loop {
      if let Err(RenderError::Timeout { elapsed, .. }) =
        check_active_periodic(&mut deadline_counter, 128, RenderStage::Layout)
      {
        self.record_timeout(elapsed);
        break;
      }

      self.advance_sweep_to(y, &mut state);
      let range_end = y + target_height;
      let (left_edge, right_edge, next_boundary) =
        self.edges_in_range_min_width_with_state(&mut state, y, range_end);
      let available_width = (right_edge - left_edge).max(0.0);

      last_left = left_edge;
      last_width = available_width;

      if target_width <= available_width {
        let x = match side {
          FloatSide::Left => left_edge,
          FloatSide::Right => left_edge + available_width - target_width,
        };
        return (x, y);
      }

      let mut candidate_y = next_boundary;
      if !candidate_y.is_finite() || candidate_y <= y {
        let x = match side {
          FloatSide::Left => last_left,
          FloatSide::Right => (last_left + last_width - target_width).max(last_left),
        };
        return (x, y);
      }

      y = candidate_y;
    }

    let x = match side {
      FloatSide::Left => last_left,
      FloatSide::Right => (last_left + last_width - target_width).max(last_left),
    };
    (x, y)
  }

  /// Get the bottom of all floats (the Y where all floats end)
  ///
  /// This is useful for determining the minimum height of a BFC that
  /// contains floats (to ensure floats don't overflow their container).
  ///
  /// # Returns
  ///
  /// The maximum bottom edge of all floats, or 0 if there are no floats.
  pub fn floats_bottom(&self) -> f32 {
    let mut bottom = 0.0f32;
    for id in 0..self.float_map.len() {
      bottom = bottom.max(self.float_info(id).bottom());
    }
    bottom
  }

  /// Check if a box would fit at the given position
  ///
  /// # Arguments
  ///
  /// * `y` - The Y position to check
  /// * `width` - Required width
  /// * `height` - Required height
  ///
  /// # Returns
  ///
  /// True if a box of the given size would fit at position y.
  pub fn fits_at(&self, y: f32, width: f32, height: f32) -> bool {
    let width = clamp_positive_finite(width);
    let height = clamp_positive_finite(height);
    let (_, available_width) = self.available_width_in_range(y, y + height);
    available_width >= width
  }

  /// Find the first Y position where a box of given dimensions would fit
  ///
  /// # Arguments
  ///
  /// * `width` - Required width
  /// * `height` - Required height
  /// * `min_y` - Minimum starting Y position
  ///
  /// # Returns
  ///
  /// The Y position where the box can be placed.
  pub fn find_fit(&self, width: f32, height: f32, min_y: f32) -> f32 {
    let mut y = min_y;
    let target_width = clamp_positive_finite(width);
    let target_height = clamp_positive_finite(height);
    let mut state = self.ensure_sweep_state(y);
    let mut deadline_counter = 0usize;

    loop {
      if let Err(RenderError::Timeout { elapsed, .. }) =
        check_active_periodic(&mut deadline_counter, 128, RenderStage::Layout)
      {
        self.record_timeout(elapsed);
        break;
      }

      self.advance_sweep_to(y, &mut state);
      let range_end = y + target_height;
      let (left_edge, right_edge, next_boundary) =
        self.edges_in_range_min_width_with_state(&mut state, y, range_end);
      let available_width = (right_edge - left_edge).max(0.0);

      if available_width >= target_width {
        return y;
      }

      if !next_boundary.is_finite() || next_boundary <= y {
        break;
      }
      y = next_boundary;
    }

    y
  }

  /// Clear all floats from the context
  ///
  /// This resets the float context as if no floats had been added.
  pub fn clear_all(&mut self) {
    self.left_floats.clear();
    self.right_floats.clear();
    self.float_map.clear();
    self.events.clear();
    self.reset_sweep_state();
    self.reset_clearance_state();
    self.clearance_left_ordered = true;
    self.clearance_right_ordered = true;
    self.timeout_elapsed.set(None);
  }

  /// Clone the context with a new containing block width
  ///
  /// Useful when creating a nested BFC with different width.
  pub fn with_width(&self, new_width: f32) -> Self {
    FloatContext::new(new_width)
  }
}

impl Default for FloatContext {
  fn default() -> Self {
    Self::new(0.0)
  }
}

#[cfg(test)]
mod tests {
  use super::*;
  use std::sync::Mutex;

  static FLOAT_PROFILE_LOCK: Mutex<()> = Mutex::new(());

  struct FloatProfileGuard {
    _lock: std::sync::MutexGuard<'static, ()>,
    previous_override: Option<bool>,
  }

  impl FloatProfileGuard {
    fn new(enabled: bool) -> Self {
      let lock = FLOAT_PROFILE_LOCK
        .lock()
        .expect("float profile lock poisoned");
      let previous_override = FLOAT_PROFILE_OVERRIDE.with(|cell| {
        let previous = cell.get();
        cell.set(Some(enabled));
        previous
      });
      Self {
        _lock: lock,
        previous_override,
      }
    }
  }

  impl Drop for FloatProfileGuard {
    fn drop(&mut self) {
      FLOAT_PROFILE_OVERRIDE.with(|cell| cell.set(self.previous_override));
    }
  }

  // ==================== FloatInfo Tests ====================

  #[test]
  fn test_float_info_new() {
    let float = FloatInfo::new(FloatSide::Left, Rect::from_xywh(10.0, 20.0, 100.0, 50.0));
    assert_eq!(float.side, FloatSide::Left);
    assert_eq!(float.rect.x(), 10.0);
    assert_eq!(float.rect.y(), 20.0);
    assert_eq!(float.rect.width(), 100.0);
    assert_eq!(float.rect.height(), 50.0);
  }

  #[test]
  fn test_float_info_left_constructor() {
    let float = FloatInfo::new_left(0.0, 0.0, 200.0, 100.0);
    assert_eq!(float.side, FloatSide::Left);
    assert_eq!(float.top(), 0.0);
    assert_eq!(float.bottom(), 100.0);
    assert_eq!(float.left_edge(), 0.0);
    assert_eq!(float.right_edge(), 200.0);
  }

  #[test]
  fn test_float_info_right_constructor() {
    let float = FloatInfo::new_right(500.0, 50.0, 300.0, 200.0);
    assert_eq!(float.side, FloatSide::Right);
    assert_eq!(float.top(), 50.0);
    assert_eq!(float.bottom(), 250.0);
    assert_eq!(float.left_edge(), 500.0);
    assert_eq!(float.right_edge(), 800.0);
  }

  #[test]
  fn test_float_info_overlaps_y_range() {
    let float = FloatInfo::new_left(0.0, 100.0, 200.0, 100.0); // y: 100-200

    // Overlapping ranges
    assert!(float.overlaps_y_range(50.0, 150.0)); // Partial overlap at start
    assert!(float.overlaps_y_range(150.0, 250.0)); // Partial overlap at end
    assert!(float.overlaps_y_range(120.0, 180.0)); // Fully inside
    assert!(float.overlaps_y_range(50.0, 250.0)); // Fully contains

    // Non-overlapping ranges
    assert!(!float.overlaps_y_range(0.0, 100.0)); // Just before
    assert!(!float.overlaps_y_range(200.0, 300.0)); // Just after
    assert!(!float.overlaps_y_range(0.0, 50.0)); // Well before
    assert!(!float.overlaps_y_range(250.0, 300.0)); // Well after
  }

  #[test]
  fn test_float_info_contains_y() {
    let float = FloatInfo::new_left(0.0, 100.0, 200.0, 100.0); // y: 100-200

    assert!(float.contains_y(100.0)); // Start edge (inclusive)
    assert!(float.contains_y(150.0)); // Middle
    assert!(float.contains_y(199.0)); // Near end
    assert!(!float.contains_y(99.0)); // Just before
    assert!(!float.contains_y(200.0)); // End edge (exclusive)
    assert!(!float.contains_y(250.0)); // Well after
  }

  // ==================== FloatContext Basic Tests ====================

  #[test]
  fn test_float_context_new() {
    let ctx = FloatContext::new(800.0);
    assert_eq!(ctx.containing_block_width(), 800.0);
    assert_eq!(ctx.current_y(), 0.0);
    assert!(ctx.is_empty());
    assert_eq!(ctx.float_count(), 0);
  }

  #[test]
  fn test_float_context_default() {
    let ctx = FloatContext::default();
    assert_eq!(ctx.containing_block_width(), 0.0);
    assert!(ctx.is_empty());
  }

  #[test]
  fn test_float_context_current_y() {
    let mut ctx = FloatContext::new(800.0);
    assert_eq!(ctx.current_y(), 0.0);

    ctx.set_current_y(100.0);
    assert_eq!(ctx.current_y(), 100.0);

    ctx.advance_y(50.0);
    assert_eq!(ctx.current_y(), 150.0);
  }

  #[test]
  fn test_add_single_left_float() {
    let mut ctx = FloatContext::new(800.0);
    ctx.add_float_at(FloatSide::Left, 0.0, 0.0, 200.0, 100.0);

    assert!(!ctx.is_empty());
    assert_eq!(ctx.float_count(), 1);
    assert_eq!(ctx.left_floats().len(), 1);
    assert_eq!(ctx.right_floats().len(), 0);
  }

  #[test]
  fn test_add_single_right_float() {
    let mut ctx = FloatContext::new(800.0);
    ctx.add_float_at(FloatSide::Right, 600.0, 0.0, 200.0, 100.0);

    assert!(!ctx.is_empty());
    assert_eq!(ctx.float_count(), 1);
    assert_eq!(ctx.left_floats().len(), 0);
    assert_eq!(ctx.right_floats().len(), 1);
  }

  #[test]
  fn test_add_multiple_floats() {
    let mut ctx = FloatContext::new(800.0);
    ctx.add_float_at(FloatSide::Left, 0.0, 0.0, 200.0, 100.0);
    ctx.add_float_at(FloatSide::Left, 200.0, 0.0, 100.0, 50.0);
    ctx.add_float_at(FloatSide::Right, 600.0, 0.0, 200.0, 150.0);

    assert_eq!(ctx.float_count(), 3);
    assert_eq!(ctx.left_floats().len(), 2);
    assert_eq!(ctx.right_floats().len(), 1);
  }

  // ==================== Available Width Tests ====================

  #[test]
  fn test_available_width_no_floats() {
    let ctx = FloatContext::new(800.0);
    let (left_edge, width) = ctx.available_width_at_y(0.0);
    assert_eq!(left_edge, 0.0);
    assert_eq!(width, 800.0);
  }

  #[test]
  fn test_available_width_with_left_float() {
    let mut ctx = FloatContext::new(800.0);
    ctx.add_float_at(FloatSide::Left, 0.0, 0.0, 200.0, 100.0);

    // Within float range
    let (left_edge, width) = ctx.available_width_at_y(50.0);
    assert_eq!(left_edge, 200.0);
    assert_eq!(width, 600.0);

    // Below float
    let (left_edge, width) = ctx.available_width_at_y(150.0);
    assert_eq!(left_edge, 0.0);
    assert_eq!(width, 800.0);
  }

  #[test]
  fn test_available_width_with_right_float() {
    let mut ctx = FloatContext::new(800.0);
    ctx.add_float_at(FloatSide::Right, 600.0, 0.0, 200.0, 100.0);

    // Within float range
    let (left_edge, width) = ctx.available_width_at_y(50.0);
    assert_eq!(left_edge, 0.0);
    assert_eq!(width, 600.0);

    // Below float
    let (left_edge, width) = ctx.available_width_at_y(150.0);
    assert_eq!(left_edge, 0.0);
    assert_eq!(width, 800.0);
  }

  #[test]
  fn test_available_width_with_both_floats() {
    let mut ctx = FloatContext::new(800.0);
    ctx.add_float_at(FloatSide::Left, 0.0, 0.0, 200.0, 100.0);
    ctx.add_float_at(FloatSide::Right, 600.0, 0.0, 200.0, 100.0);

    let (left_edge, width) = ctx.available_width_at_y(50.0);
    assert_eq!(left_edge, 200.0);
    assert_eq!(width, 400.0); // 800 - 200 - 200
  }

  #[test]
  fn test_available_width_in_range() {
    let mut ctx = FloatContext::new(800.0);
    ctx.add_float_at(FloatSide::Left, 0.0, 0.0, 200.0, 100.0);
    ctx.add_float_at(FloatSide::Left, 0.0, 50.0, 300.0, 100.0); // Wider, overlapping

    // Range that spans both floats
    let (left_edge, width) = ctx.available_width_in_range(0.0, 100.0);
    assert_eq!(left_edge, 300.0); // Most constrained
    assert_eq!(width, 500.0);
  }

  #[test]
  fn test_edges_at_y() {
    let mut ctx = FloatContext::new(800.0);
    ctx.add_float_at(FloatSide::Left, 0.0, 0.0, 200.0, 100.0);
    ctx.add_float_at(FloatSide::Right, 600.0, 0.0, 200.0, 100.0);

    assert_eq!(ctx.left_edge_at_y(50.0), 200.0);
    assert_eq!(ctx.right_edge_at_y(50.0), 600.0);
    assert_eq!(ctx.left_edge_at_y(150.0), 0.0);
    assert_eq!(ctx.right_edge_at_y(150.0), 800.0);
  }

  // ==================== Clearance Tests ====================

  #[test]
  fn test_clearance_no_floats() {
    let ctx = FloatContext::new(800.0);
    assert_eq!(ctx.compute_clearance(0.0, Clear::Left), 0.0);
    assert_eq!(ctx.compute_clearance(0.0, Clear::Right), 0.0);
    assert_eq!(ctx.compute_clearance(0.0, Clear::Both), 0.0);
    assert_eq!(ctx.compute_clearance(0.0, Clear::None), 0.0);
  }

  #[test]
  fn test_clearance_clear_left() {
    let mut ctx = FloatContext::new(800.0);
    ctx.add_float_at(FloatSide::Left, 0.0, 0.0, 200.0, 100.0);

    assert_eq!(ctx.compute_clearance(50.0, Clear::Left), 100.0);
    assert_eq!(ctx.compute_clearance(50.0, Clear::Right), 50.0); // No change
    assert_eq!(ctx.compute_clearance(150.0, Clear::Left), 150.0); // Already below
  }

  #[test]
  fn test_clearance_clear_right() {
    let mut ctx = FloatContext::new(800.0);
    ctx.add_float_at(FloatSide::Right, 600.0, 0.0, 200.0, 100.0);

    assert_eq!(ctx.compute_clearance(50.0, Clear::Right), 100.0);
    assert_eq!(ctx.compute_clearance(50.0, Clear::Left), 50.0); // No change
  }

  #[test]
  fn test_clearance_clear_both() {
    let mut ctx = FloatContext::new(800.0);
    ctx.add_float_at(FloatSide::Left, 0.0, 0.0, 200.0, 100.0);
    ctx.add_float_at(FloatSide::Right, 600.0, 0.0, 200.0, 150.0);

    // Should clear to bottom of tallest float
    assert_eq!(ctx.compute_clearance(50.0, Clear::Both), 150.0);
  }

  #[test]
  fn test_clearance_amount() {
    let mut ctx = FloatContext::new(800.0);
    ctx.add_float_at(FloatSide::Left, 0.0, 0.0, 200.0, 100.0);

    assert_eq!(ctx.clearance_amount(50.0, Clear::Left), 50.0);
    assert_eq!(ctx.clearance_amount(100.0, Clear::Left), 0.0);
    assert_eq!(ctx.clearance_amount(150.0, Clear::Left), 0.0);
  }

  // ==================== Float Positioning Tests ====================

  #[test]
  fn test_compute_float_position_empty() {
    let ctx = FloatContext::new(800.0);

    // Left float goes to left edge
    let (x, y) = ctx.compute_float_position(FloatSide::Left, 200.0, 100.0, 0.0);
    assert_eq!((x, y), (0.0, 0.0));

    // Right float goes to right edge
    let (x, y) = ctx.compute_float_position(FloatSide::Right, 200.0, 100.0, 0.0);
    assert_eq!((x, y), (600.0, 0.0));
  }

  #[test]
  fn test_compute_float_position_stacking_left() {
    let mut ctx = FloatContext::new(800.0);

    // First left float
    let (x, y) = ctx.compute_float_position(FloatSide::Left, 200.0, 100.0, 0.0);
    assert_eq!((x, y), (0.0, 0.0));
    ctx.add_float_at(FloatSide::Left, x, y, 200.0, 100.0);

    // Second left float stacks horizontally
    let (x, y) = ctx.compute_float_position(FloatSide::Left, 200.0, 100.0, 0.0);
    assert_eq!((x, y), (200.0, 0.0));
    ctx.add_float_at(FloatSide::Left, x, y, 200.0, 100.0);

    // Third left float continues stacking
    let (x, y) = ctx.compute_float_position(FloatSide::Left, 200.0, 100.0, 0.0);
    assert_eq!((x, y), (400.0, 0.0));
  }

  #[test]
  fn test_compute_float_position_stacking_right() {
    let mut ctx = FloatContext::new(800.0);

    // First right float
    let (x, y) = ctx.compute_float_position(FloatSide::Right, 200.0, 100.0, 0.0);
    assert_eq!((x, y), (600.0, 0.0));
    ctx.add_float_at(FloatSide::Right, x, y, 200.0, 100.0);

    // Second right float stacks to the left
    let (x, y) = ctx.compute_float_position(FloatSide::Right, 200.0, 100.0, 0.0);
    assert_eq!((x, y), (400.0, 0.0));
  }

  #[test]
  fn test_compute_float_position_drops_down() {
    let mut ctx = FloatContext::new(400.0);

    // First left float takes half the width
    ctx.add_float_at(FloatSide::Left, 0.0, 0.0, 200.0, 100.0);

    // Second left float that's too wide must drop down
    let (x, y) = ctx.compute_float_position(FloatSide::Left, 300.0, 50.0, 0.0);
    assert_eq!((x, y), (0.0, 100.0)); // Drops to y=100 where first float ends
  }

  #[test]
  fn test_compute_float_position_with_min_y() {
    let ctx = FloatContext::new(800.0);

    // Float respects min_y
    let (x, y) = ctx.compute_float_position(FloatSide::Left, 200.0, 100.0, 50.0);
    assert_eq!((x, y), (0.0, 50.0));
  }

  #[test]
  fn test_compute_float_position_considers_height_overlap() {
    let mut ctx = FloatContext::new(400.0);

    // Existing float sits lower in the flow.
    ctx.add_float_at(FloatSide::Left, 0.0, 50.0, 200.0, 150.0); // spans 50..200

    // New float would overlap vertically if kept at y=0; it should drop below.
    let (x, y) = ctx.compute_float_position(FloatSide::Left, 300.0, 80.0, 0.0);
    assert_eq!((x, y), (0.0, 200.0));
  }

  // ==================== Other Tests ====================

  #[test]
  fn test_floats_bottom() {
    let mut ctx = FloatContext::new(800.0);
    assert_eq!(ctx.floats_bottom(), 0.0);

    ctx.add_float_at(FloatSide::Left, 0.0, 0.0, 200.0, 100.0);
    assert_eq!(ctx.floats_bottom(), 100.0);

    ctx.add_float_at(FloatSide::Right, 600.0, 50.0, 200.0, 150.0);
    assert_eq!(ctx.floats_bottom(), 200.0); // 50 + 150
  }

  #[test]
  fn test_fits_at() {
    let mut ctx = FloatContext::new(800.0);
    ctx.add_float_at(FloatSide::Left, 0.0, 0.0, 200.0, 100.0);

    // Fits in remaining space
    assert!(ctx.fits_at(0.0, 500.0, 50.0));

    // Doesn't fit
    assert!(!ctx.fits_at(0.0, 700.0, 50.0));

    // Fits below float
    assert!(ctx.fits_at(100.0, 700.0, 50.0));
  }

  #[test]
  fn test_find_fit() {
    let mut ctx = FloatContext::new(800.0);
    ctx.add_float_at(FloatSide::Left, 0.0, 0.0, 600.0, 100.0);

    // Small box fits at y=0
    assert_eq!(ctx.find_fit(100.0, 50.0, 0.0), 0.0);

    // Large box must wait until y=100
    assert_eq!(ctx.find_fit(700.0, 50.0, 0.0), 100.0);
  }

  #[test]
  fn test_clear_all() {
    let mut ctx = FloatContext::new(800.0);
    ctx.add_float_at(FloatSide::Left, 0.0, 0.0, 200.0, 100.0);
    ctx.add_float_at(FloatSide::Right, 600.0, 0.0, 200.0, 100.0);

    assert_eq!(ctx.float_count(), 2);
    ctx.clear_all();
    assert!(ctx.is_empty());
    assert_eq!(ctx.float_count(), 0);
  }

  #[test]
  fn test_with_width() {
    let mut ctx = FloatContext::new(800.0);
    ctx.add_float_at(FloatSide::Left, 0.0, 0.0, 200.0, 100.0);
    ctx.set_current_y(50.0);

    let new_ctx = ctx.with_width(400.0);
    assert_eq!(new_ctx.containing_block_width(), 400.0);
    assert!(new_ctx.is_empty()); // Floats are not copied
    assert_eq!(new_ctx.current_y(), 0.0); // Y is reset
  }

  #[test]
  fn test_float_side_from_float() {
    assert_eq!(
      Option::<FloatSide>::from(Float::Left),
      Some(FloatSide::Left)
    );
    assert_eq!(
      Option::<FloatSide>::from(Float::Right),
      Some(FloatSide::Right)
    );
    assert_eq!(Option::<FloatSide>::from(Float::None), None);
  }

  // ==================== Complex Scenario Tests ====================

  #[test]
  fn test_staggered_floats() {
    let mut ctx = FloatContext::new(800.0);

    // Left float at top
    ctx.add_float_at(FloatSide::Left, 0.0, 0.0, 200.0, 100.0);

    // Right float starting lower
    ctx.add_float_at(FloatSide::Right, 600.0, 50.0, 200.0, 100.0);

    // At y=25: only left float affects width
    let (left_edge, width) = ctx.available_width_at_y(25.0);
    assert_eq!(left_edge, 200.0);
    assert_eq!(width, 600.0);

    // At y=75: both floats affect width
    let (left_edge, width) = ctx.available_width_at_y(75.0);
    assert_eq!(left_edge, 200.0);
    assert_eq!(width, 400.0);

    // At y=125: only right float affects width
    let (left_edge, width) = ctx.available_width_at_y(125.0);
    assert_eq!(left_edge, 0.0);
    assert_eq!(width, 600.0);
  }

  #[test]
  fn test_overlapping_left_floats() {
    let mut ctx = FloatContext::new(800.0);

    // Two left floats that overlap vertically but have different widths
    ctx.add_float_at(FloatSide::Left, 0.0, 0.0, 200.0, 100.0);
    ctx.add_float_at(FloatSide::Left, 0.0, 50.0, 300.0, 100.0);

    // At y=25: only first float
    assert_eq!(ctx.left_edge_at_y(25.0), 200.0);

    // At y=75: both floats, use rightmost edge
    assert_eq!(ctx.left_edge_at_y(75.0), 300.0);

    // At y=125: only second float
    assert_eq!(ctx.left_edge_at_y(125.0), 300.0);

    // At y=175: no floats
    assert_eq!(ctx.left_edge_at_y(175.0), 0.0);
  }

  #[test]
  fn test_nested_bfc_scenario() {
    // Outer BFC
    let mut outer = FloatContext::new(800.0);
    outer.add_float_at(FloatSide::Left, 0.0, 0.0, 200.0, 200.0);

    // Inner BFC would be created with remaining width
    let (left_edge, available) = outer.available_width_at_y(0.0);
    let inner = outer.with_width(available);

    assert_eq!(left_edge, 200.0);
    assert_eq!(inner.containing_block_width(), 600.0);
    assert!(inner.is_empty());
  }

  #[test]
  fn float_sweep_counts_events_instead_of_rescanning() {
    let _guard = FloatProfileGuard::new(true);
    reset_float_profile_counters();
    let mut ctx = FloatContext::new(200.0);
    for i in 0..100 {
      ctx.add_float_at(FloatSide::Left, 0.0, i as f32 * 5.0, 20.0, 5.0);
    }

    for y in 0..500 {
      let _ = ctx.available_width_at_y(y as f32);
    }
    let stats = float_profile_stats();

    assert_eq!(stats.range_queries, 0);
    assert_eq!(stats.width_queries, 500);
    assert!(
      stats.boundary_steps <= 210,
      "boundary steps should scale with float events, got {}",
      stats.boundary_steps
    );
  }

  #[test]
  fn dense_float_stack_find_fit_progresses() {
    let mut ctx = FloatContext::new(100.0);
    for i in 0..100 {
      let y = i as f32;
      if i % 2 == 0 {
        ctx.add_float_at(FloatSide::Left, 0.0, y, 50.0, 1.0);
      } else {
        ctx.add_float_at(FloatSide::Right, 50.0, y, 50.0, 1.0);
      }
    }

    assert_eq!(ctx.find_fit(60.0, 1.0, 0.0), 100.0);
    let (x, y) = ctx.compute_float_position(FloatSide::Left, 60.0, 1.0, 0.0);
    assert_eq!(y, 100.0);
    assert_eq!(x, 0.0);
  }

  #[test]
  fn range_queries_reuse_sweep_state_for_dense_boundaries() {
    let _guard = FloatProfileGuard::new(true);
    reset_float_profile_counters();
    let mut ctx = FloatContext::new(200.0);
    for i in 0..500 {
      let y = i as f32;
      ctx.add_float_at(FloatSide::Left, 0.0, y, 100.0, 1.0);
      ctx.add_float_at(FloatSide::Right, 100.0, y, 100.0, 1.0);
    }

    for i in 0..500 {
      let start = i as f32;
      let _ = ctx.available_width_in_range(start, start + 1.0);
    }
    let stats = float_profile_stats();

    assert!(
      stats.boundary_steps <= 2500,
      "range queries should sweep floats once, got {}",
      stats.boundary_steps
    );
  }

  #[test]
  fn clearance_matches_naive_scan() {
    fn naive(ctx: &FloatContext, y: f32, clear: Clear) -> f32 {
      if !clear.is_clearing() {
        return y;
      }
      let mut clear_y = y;
      if clear.clears_left() {
        for float in ctx.left_floats() {
          let (top, bottom) = float_vertical_span(float);
          if top <= y {
            clear_y = clear_y.max(bottom);
          }
        }
      }
      if clear.clears_right() {
        for float in ctx.right_floats() {
          let (top, bottom) = float_vertical_span(float);
          if top <= y {
            clear_y = clear_y.max(bottom);
          }
        }
      }
      clear_y
    }

    let mut ctx = FloatContext::new(800.0);
    for i in 0..1000usize {
      let y = (i as f32) * 2.0;
      if i % 2 == 0 {
        ctx.add_float_at(FloatSide::Left, 0.0, y, 100.0, 5.0);
      } else {
        ctx.add_float_at(FloatSide::Right, 700.0, y, 100.0, 3.0);
      }
    }

    for i in 0..2000usize {
      let y = i as f32;
      for clear in [Clear::Left, Clear::Right, Clear::Both, Clear::None] {
        assert_eq!(ctx.compute_clearance(y, clear), naive(&ctx, y, clear));
      }
    }

    for &y in &[250.0, 125.0, 375.0, 10.0, 999.0, 0.0, 500.0] {
      for clear in [Clear::Left, Clear::Right, Clear::Both] {
        assert_eq!(ctx.compute_clearance(y, clear), naive(&ctx, y, clear));
      }
    }
  }

  #[test]
  fn clearance_queries_scale_with_insertions() {
    let _guard = FloatProfileGuard::new(true);
    reset_float_profile_counters();
    let mut ctx = FloatContext::new(200.0);
    for i in 0..2000usize {
      let y = i as f32;
      ctx.add_float_at(FloatSide::Left, 0.0, y, 20.0, 1.0);
      ctx.add_float_at(FloatSide::Right, 180.0, y, 20.0, 1.0);
      let _ = ctx.compute_clearance(y, Clear::Both);
    }
    let stats = float_profile_stats();

    assert_eq!(stats.clearance_queries, 2000);
    assert!(
      stats.clearance_steps <= 4500,
      "clearance should advance incrementally, got {} steps",
      stats.clearance_steps
    );
  }

  #[test]
  fn clearance_falls_back_for_out_of_order_floats() {
    let mut ctx = FloatContext::new(800.0);
    ctx.add_float_at(FloatSide::Left, 0.0, 100.0, 200.0, 50.0);
    ctx.add_float_at(FloatSide::Left, 0.0, 50.0, 200.0, 25.0);

    assert_eq!(ctx.compute_clearance(60.0, Clear::Left), 75.0);
  }
}
