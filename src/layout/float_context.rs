//! Float Context for CSS float layout
//!
//! This module implements the float context that manages floated boxes within
//! a block formatting context. It tracks float positions and computes available
//! space for content and new floats.
//!
//! # CSS Float Layout Algorithm
//!
//! According to CSS 2.1 Section 9.5, floats are positioned as follows:
//!
//! 1. The float's top may not be higher than the top of its containing block
//! 2. The float's top may not be higher than the top of any earlier float
//! 3. A float's left (or right) outer edge may not be to the left (or right)
//!    of its containing block's edge
//! 4. A left-floating box must be as far left as possible; a right-floating
//!    box must be as far right as possible
//! 5. The outer top of a floating box may not be higher than the outer top
//!    of any block or floated box generated by an element earlier in the source
//! 6. A floating box's outer top may not be higher than the top of any line-box
//!    containing a box generated by an element earlier in the source
//! 7. A left-floating box that has another left-floating box to its left may
//!    not have its right outer edge to the right of its containing block's
//!    right edge
//! 8. A floating box must be placed as high as possible
//! 9. A left-floating box must be put as far to the left as possible, a
//!    right-floating box must be put as far to the right as possible
//!
//! # Clear Property
//!
//! CSS 2.1 Section 9.5.2 defines the `clear` property which introduces
//! clearance - extra space above an element's margin-top that pushes the
//! element below any floats.
//!
//! # References
//!
//! - CSS 2.1 Section 9.5: <https://www.w3.org/TR/CSS21/visuren.html#floats>
//! - CSS 2.1 Section 9.5.1: <https://www.w3.org/TR/CSS21/visuren.html#float-position>
//! - CSS 2.1 Section 9.5.2: <https://www.w3.org/TR/CSS21/visuren.html#propdef-clear>

use crate::geometry::Rect;
use crate::layout::float_shape::FloatShape;
use crate::style::float::Clear;
use crate::style::float::Float;
use std::sync::Arc;

/// Side on which a float is placed
///
/// This enum represents the physical side where a float is positioned,
/// derived from the CSS `float` property value.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum FloatSide {
  /// Float is positioned on the left side
  Left,
  /// Float is positioned on the right side
  Right,
}

impl From<Float> for Option<FloatSide> {
  fn from(float: Float) -> Self {
    match float {
      Float::Left => Some(FloatSide::Left),
      Float::Right => Some(FloatSide::Right),
      Float::None => None,
    }
  }
}

/// Information about a single float
///
/// Stores the position and dimensions of a floated box within a BFC.
/// All coordinates are relative to the BFC's origin.
#[derive(Debug, Clone, PartialEq)]
pub struct FloatInfo {
  /// The side on which this float is placed
  pub side: FloatSide,

  /// The float's bounding rectangle (margin box)
  ///
  /// Coordinates are relative to the containing block formatting context.
  /// This is the margin box of the float, including margins.
  pub rect: Rect,

  /// Optional wrapping shape from `shape-outside`.
  pub shape: Option<Arc<FloatShape>>,
}

impl FloatInfo {
  /// Create a new float info
  pub fn new(side: FloatSide, rect: Rect) -> Self {
    Self {
      side,
      rect,
      shape: None,
    }
  }

  pub fn new_with_shape(side: FloatSide, rect: Rect, shape: Option<Arc<FloatShape>>) -> Self {
    Self { side, rect, shape }
  }

  /// Create a left float at the given position
  pub fn new_left(x: f32, y: f32, width: f32, height: f32) -> Self {
    Self {
      side: FloatSide::Left,
      rect: Rect::from_xywh(x, y, width, height),
      shape: None,
    }
  }

  /// Create a right float at the given position
  pub fn new_right(x: f32, y: f32, width: f32, height: f32) -> Self {
    Self {
      side: FloatSide::Right,
      rect: Rect::from_xywh(x, y, width, height),
      shape: None,
    }
  }

  /// Returns the top edge of the float
  pub fn top(&self) -> f32 {
    self.rect.y()
  }

  /// Returns the bottom edge of the float (y + height)
  pub fn bottom(&self) -> f32 {
    self.rect.y() + self.rect.height()
  }

  /// Returns the left edge of the float
  pub fn left_edge(&self) -> f32 {
    self.rect.x()
  }

  /// Returns the right edge of the float (x + width)
  pub fn right_edge(&self) -> f32 {
    self.rect.x() + self.rect.width()
  }

  /// Returns true if the float overlaps vertically with a given y range
  pub fn overlaps_y_range(&self, y_start: f32, y_end: f32) -> bool {
    // Float overlaps if it starts before y_end and ends after y_start
    self.top() < y_end && self.bottom() > y_start
  }

  /// Returns true if the float contains the given y coordinate
  pub fn contains_y(&self, y: f32) -> bool {
    y >= self.top() && y < self.bottom()
  }
}

/// Float context for managing floats within a block formatting context
///
/// A FloatContext is created for each block formatting context (BFC) and
/// tracks all floats within that context. It provides methods for:
///
/// - Adding new floats and computing their positions
/// - Computing available width at a given vertical position
/// - Computing clearance for elements with the `clear` property
///
/// # Coordinate System
///
/// All coordinates in FloatContext are relative to the BFC's content box origin.
/// The Y axis increases downward. X increases to the right.
///
/// # Example
///
/// ```
/// use fastrender::{FloatContext, FloatSide};
///
/// // Create a context with a 800px wide containing block
/// let mut ctx = FloatContext::new(800.0);
///
/// // Add a left float at position (0, 0) that is 200x100
/// ctx.add_float_at(
///     FloatSide::Left,
///     0.0, 0.0, 200.0, 100.0
/// );
///
/// // Query available width at y=50 (within the float's vertical extent)
/// let (left_edge, available_width) = ctx.available_width_at_y(50.0);
/// assert_eq!(left_edge, 200.0); // Left edge is pushed right by the float
/// assert_eq!(available_width, 600.0); // 800 - 200 = 600
///
/// // Query available width at y=150 (below the float)
/// let (left_edge, available_width) = ctx.available_width_at_y(150.0);
/// assert_eq!(left_edge, 0.0); // No float interference
/// assert_eq!(available_width, 800.0); // Full width available
/// ```
#[derive(Debug, Clone)]
pub struct FloatContext {
  /// Width of the containing block
  containing_block_width: f32,

  /// List of left floats, sorted by top edge
  left_floats: Vec<FloatInfo>,

  /// List of right floats, sorted by top edge
  right_floats: Vec<FloatInfo>,

  /// Current Y position for float placement
  /// This tracks the "float ceiling" - the lowest point we've processed
  current_y: f32,
}

impl FloatContext {
  /// Create a new float context for a containing block of the given width
  ///
  /// # Arguments
  ///
  /// * `containing_block_width` - The width of the BFC's content box
  ///
  /// # Example
  ///
  /// ```
  /// use fastrender::FloatContext;
  ///
  /// let ctx = FloatContext::new(800.0);
  /// assert_eq!(ctx.containing_block_width(), 800.0);
  /// ```
  pub fn new(containing_block_width: f32) -> Self {
    Self {
      containing_block_width,
      left_floats: Vec::new(),
      right_floats: Vec::new(),
      current_y: 0.0,
    }
  }

  /// Returns the containing block width
  pub fn containing_block_width(&self) -> f32 {
    self.containing_block_width
  }

  /// Returns the current Y position
  pub fn current_y(&self) -> f32 {
    self.current_y
  }

  /// Set the current Y position
  ///
  /// This is used to update the position as layout progresses.
  pub fn set_current_y(&mut self, y: f32) {
    self.current_y = y;
  }

  /// Advance the current Y position by the given amount
  pub fn advance_y(&mut self, delta: f32) {
    self.current_y += delta;
  }

  /// Returns true if there are no floats
  pub fn is_empty(&self) -> bool {
    self.left_floats.is_empty() && self.right_floats.is_empty()
  }

  /// Returns the total number of floats
  pub fn float_count(&self) -> usize {
    self.left_floats.len() + self.right_floats.len()
  }

  /// Returns all left floats
  pub fn left_floats(&self) -> &[FloatInfo] {
    &self.left_floats
  }

  /// Returns all right floats
  pub fn right_floats(&self) -> &[FloatInfo] {
    &self.right_floats
  }

  /// Add a float at the specified position
  ///
  /// This directly adds a float without computing its position.
  /// Use `compute_float_position` to determine where a float should be placed,
  /// then call this method.
  ///
  /// # Arguments
  ///
  /// * `side` - Which side to place the float
  /// * `x` - X coordinate of the float's margin box
  /// * `y` - Y coordinate of the float's margin box
  /// * `width` - Width of the float's margin box
  /// * `height` - Height of the float's margin box
  pub fn add_float_at(&mut self, side: FloatSide, x: f32, y: f32, width: f32, height: f32) {
    let float_info = FloatInfo::new(side, Rect::from_xywh(x, y, width, height));
    self.add_float(float_info);
  }

  /// Add a float at the specified position with an optional `shape-outside` wrapping shape.
  pub fn add_float_with_shape(
    &mut self,
    side: FloatSide,
    x: f32,
    y: f32,
    width: f32,
    height: f32,
    shape: Option<FloatShape>,
  ) {
    let float_info = FloatInfo::new_with_shape(
      side,
      Rect::from_xywh(x, y, width, height),
      shape.map(Arc::new),
    );
    self.add_float(float_info);
  }

  /// Add a float with the given FloatInfo
  pub fn add_float(&mut self, float_info: FloatInfo) {
    match float_info.side {
      FloatSide::Left => {
        self.left_floats.push(float_info);
        // Keep sorted by top edge for efficient queries
        self
          .left_floats
          .sort_by(|a, b| a.top().partial_cmp(&b.top()).unwrap());
      }
      FloatSide::Right => {
        self.right_floats.push(float_info);
        self
          .right_floats
          .sort_by(|a, b| a.top().partial_cmp(&b.top()).unwrap());
      }
    }
  }

  /// Get the left edge at a given Y position (accounting for left floats)
  ///
  /// Returns the X coordinate where content can start at the given Y.
  pub fn left_edge_at_y(&self, y: f32) -> f32 {
    let mut left_edge: f32 = 0.0;

    for float in &self.left_floats {
      if let Some(shape) = float.shape.as_ref() {
        if let Some((_min_x, max_x)) = shape.span_at(y) {
          left_edge = left_edge.max(max_x);
        }
      } else if float.contains_y(y) {
        left_edge = left_edge.max(float.right_edge());
      }
    }

    left_edge
  }

  /// Get the right edge at a given Y position (accounting for right floats)
  ///
  /// Returns the X coordinate where content must end at the given Y.
  pub fn right_edge_at_y(&self, y: f32) -> f32 {
    let mut right_edge = self.containing_block_width;

    for float in &self.right_floats {
      if let Some(shape) = float.shape.as_ref() {
        if let Some((min_x, _max_x)) = shape.span_at(y) {
          right_edge = right_edge.min(min_x);
        }
      } else if float.contains_y(y) {
        right_edge = right_edge.min(float.left_edge());
      }
    }

    right_edge
  }

  /// Compute available width at a given Y position
  ///
  /// Returns a tuple of (left_edge, available_width) where:
  /// - `left_edge` is the X coordinate where content can start
  /// - `available_width` is the horizontal space available
  ///
  /// # Arguments
  ///
  /// * `y` - The Y coordinate to query
  ///
  /// # Example
  ///
  /// ```
  /// use fastrender::{FloatContext, FloatSide};
  ///
  /// let mut ctx = FloatContext::new(800.0);
  /// ctx.add_float_at(FloatSide::Left, 0.0, 0.0, 200.0, 100.0);
  /// ctx.add_float_at(FloatSide::Right, 600.0, 0.0, 200.0, 100.0);
  ///
  /// let (left, width) = ctx.available_width_at_y(50.0);
  /// assert_eq!(left, 200.0);
  /// assert_eq!(width, 400.0); // 800 - 200 - 200
  /// ```
  pub fn available_width_at_y(&self, y: f32) -> (f32, f32) {
    let left_edge = self.left_edge_at_y(y);
    let right_edge = self.right_edge_at_y(y);
    let available_width = (right_edge - left_edge).max(0.0);
    (left_edge, available_width)
  }

  /// Compute available width over a vertical range
  ///
  /// Returns the minimum available width (and corresponding left edge)
  /// over the given vertical range. This is used when an element spans
  /// multiple Y positions.
  ///
  /// # Arguments
  ///
  /// * `y_start` - Start of the vertical range (top)
  /// * `y_end` - End of the vertical range (bottom)
  ///
  /// # Returns
  ///
  /// A tuple of (left_edge, available_width) representing the most
  /// constrained position within the range.
  pub fn available_width_in_range(&self, y_start: f32, y_end: f32) -> (f32, f32) {
    let mut max_left_edge: f32 = 0.0;
    let mut min_right_edge = self.containing_block_width;

    // Check all left floats that overlap this range
    for float in &self.left_floats {
      if let Some(shape) = float.shape.as_ref() {
        if let Some((_min_x, max_x)) = shape.span_in_range(y_start, y_end) {
          max_left_edge = max_left_edge.max(max_x);
        }
      } else if float.overlaps_y_range(y_start, y_end) {
        max_left_edge = max_left_edge.max(float.right_edge());
      }
    }

    // Check all right floats that overlap this range
    for float in &self.right_floats {
      if let Some(shape) = float.shape.as_ref() {
        if let Some((min_x, _max_x)) = shape.span_in_range(y_start, y_end) {
          min_right_edge = min_right_edge.min(min_x);
        }
      } else if float.overlaps_y_range(y_start, y_end) {
        min_right_edge = min_right_edge.min(float.left_edge());
      }
    }

    let available_width = (min_right_edge - max_left_edge).max(0.0);
    (max_left_edge, available_width)
  }

  /// Compute the clearance needed for an element with the given clear value
  ///
  /// Clearance is the amount of extra vertical space needed to push the
  /// element below any interfering floats.
  ///
  /// # Arguments
  ///
  /// * `y` - The current Y position before clearance
  /// * `clear` - The CSS clear property value
  ///
  /// # Returns
  ///
  /// The Y position after applying clearance.
  ///
  /// # Example
  ///
  /// ```
  /// use fastrender::{FloatContext, FloatSide};
  /// use fastrender::Clear;
  ///
  /// let mut ctx = FloatContext::new(800.0);
  /// ctx.add_float_at(FloatSide::Left, 0.0, 0.0, 200.0, 100.0);
  ///
  /// // Clear left at y=50 should push us below the float
  /// let new_y = ctx.compute_clearance(50.0, Clear::Left);
  /// assert_eq!(new_y, 100.0); // Float ends at y=100
  ///
  /// // Clear right at y=50 does nothing (no right floats)
  /// let new_y = ctx.compute_clearance(50.0, Clear::Right);
  /// assert_eq!(new_y, 50.0);
  /// ```
  pub fn compute_clearance(&self, y: f32, clear: Clear) -> f32 {
    if !clear.is_clearing() {
      return y;
    }

    let mut clear_y = y;

    // Find the bottom of all left floats that we need to clear
    if clear.clears_left() {
      for float in &self.left_floats {
        // We need to clear floats that start at or before our position
        if float.top() <= y {
          clear_y = clear_y.max(float.bottom());
        }
      }
    }

    // Find the bottom of all right floats that we need to clear
    if clear.clears_right() {
      for float in &self.right_floats {
        if float.top() <= y {
          clear_y = clear_y.max(float.bottom());
        }
      }
    }

    clear_y
  }

  /// Get clearance amount as a delta from the current position
  ///
  /// Returns how much the Y position needs to increase to clear floats.
  ///
  /// # Arguments
  ///
  /// * `y` - The current Y position before clearance
  /// * `clear` - The CSS clear property value
  ///
  /// # Returns
  ///
  /// The additional Y offset needed (0 if no clearance needed).
  pub fn clearance_amount(&self, y: f32, clear: Clear) -> f32 {
    let cleared_y = self.compute_clearance(y, clear);
    (cleared_y - y).max(0.0)
  }

  /// Compute the position for a new float
  ///
  /// This implements the CSS 2.1 float positioning algorithm:
  /// 1. The float is placed as high as possible
  /// 2. Left floats go as far left as possible
  /// 3. Right floats go as far right as possible
  /// 4. Floats may not overlap horizontally with other floats
  /// 5. The float's full height must fit alongside existing floats
  ///
  /// # Arguments
  ///
  /// * `side` - Which side to place the float
  /// * `width` - Width of the float's margin box
  /// * `height` - Height of the float's margin box
  /// * `min_y` - Minimum Y position (typically current_y)
  ///
  /// # Returns
  ///
  /// The (x, y) position where the float should be placed.
  ///
  /// # Example
  ///
  /// ```
  /// use fastrender::{FloatContext, FloatSide};
  ///
  /// let mut ctx = FloatContext::new(800.0);
  ///
  /// // First left float goes at (0, 0)
  /// let (x, y) = ctx.compute_float_position(FloatSide::Left, 200.0, 100.0, 0.0);
  /// assert_eq!((x, y), (0.0, 0.0));
  /// ctx.add_float_at(FloatSide::Left, x, y, 200.0, 100.0);
  ///
  /// // Second left float at same Y goes next to first
  /// let (x, y) = ctx.compute_float_position(FloatSide::Left, 200.0, 100.0, 0.0);
  /// assert_eq!((x, y), (200.0, 0.0));
  /// ```
  pub fn compute_float_position(
    &self,
    side: FloatSide,
    width: f32,
    height: f32,
    min_y: f32,
  ) -> (f32, f32) {
    // Start at the minimum Y position
    let mut y = min_y;

    loop {
      let (left_edge, available_width) = self.available_width_in_range(y, y + height);

      // Check if the float fits at this Y position
      if width <= available_width {
        // It fits! Compute X position based on side
        let x = match side {
          FloatSide::Left => left_edge,
          FloatSide::Right => left_edge + available_width - width,
        };
        return (x, y);
      }

      // Doesn't fit - move to the next "band" where a float ends
      let next_y = self.next_float_bottom_after(y);

      if next_y <= y {
        // No more floats to clear, force fit at current position
        // This handles edge cases where the float is wider than available space
        let (left_edge, available_width) = self.available_width_in_range(y, y + height);
        let x = match side {
          FloatSide::Left => left_edge,
          FloatSide::Right => (left_edge + available_width - width).max(left_edge),
        };
        return (x, y);
      }

      y = next_y;
    }
  }

  /// Find the bottom of the next float that ends after the given Y
  ///
  /// Returns the Y position where available width might change due to
  /// a float ending. Returns the input Y if no more floats.
  fn next_float_bottom_after(&self, y: f32) -> f32 {
    let mut next_y = f32::MAX;

    for float in self.left_floats.iter().chain(self.right_floats.iter()) {
      let bottom = float.bottom();
      // We want the smallest bottom that is greater than y
      if bottom > y && bottom < next_y {
        next_y = bottom;
      }
    }

    if next_y == f32::MAX {
      y // No more floats
    } else {
      next_y
    }
  }

  /// Get the bottom of all floats (the Y where all floats end)
  ///
  /// This is useful for determining the minimum height of a BFC that
  /// contains floats (to ensure floats don't overflow their container).
  ///
  /// # Returns
  ///
  /// The maximum bottom edge of all floats, or 0 if there are no floats.
  pub fn floats_bottom(&self) -> f32 {
    let mut bottom = 0.0f32;

    for float in self.left_floats.iter().chain(self.right_floats.iter()) {
      bottom = bottom.max(float.bottom());
    }

    bottom
  }

  /// Check if a box would fit at the given position
  ///
  /// # Arguments
  ///
  /// * `y` - The Y position to check
  /// * `width` - Required width
  /// * `height` - Required height
  ///
  /// # Returns
  ///
  /// True if a box of the given size would fit at position y.
  pub fn fits_at(&self, y: f32, width: f32, height: f32) -> bool {
    let (_, available_width) = self.available_width_in_range(y, y + height);
    available_width >= width
  }

  /// Find the first Y position where a box of given dimensions would fit
  ///
  /// # Arguments
  ///
  /// * `width` - Required width
  /// * `height` - Required height
  /// * `min_y` - Minimum starting Y position
  ///
  /// # Returns
  ///
  /// The Y position where the box can be placed.
  pub fn find_fit(&self, width: f32, height: f32, min_y: f32) -> f32 {
    let mut y = min_y;

    loop {
      if self.fits_at(y, width, height) {
        return y;
      }

      let next_y = self.next_float_bottom_after(y);
      if next_y <= y {
        // No more floats to check
        return y;
      }
      y = next_y;
    }
  }

  /// Clear all floats from the context
  ///
  /// This resets the float context as if no floats had been added.
  pub fn clear_all(&mut self) {
    self.left_floats.clear();
    self.right_floats.clear();
  }

  /// Clone the context with a new containing block width
  ///
  /// Useful when creating a nested BFC with different width.
  pub fn with_width(&self, new_width: f32) -> Self {
    Self {
      containing_block_width: new_width,
      left_floats: Vec::new(),
      right_floats: Vec::new(),
      current_y: 0.0,
    }
  }
}

impl Default for FloatContext {
  fn default() -> Self {
    Self::new(0.0)
  }
}

#[cfg(test)]
mod tests {
  use super::*;

  // ==================== FloatInfo Tests ====================

  #[test]
  fn test_float_info_new() {
    let float = FloatInfo::new(FloatSide::Left, Rect::from_xywh(10.0, 20.0, 100.0, 50.0));
    assert_eq!(float.side, FloatSide::Left);
    assert_eq!(float.rect.x(), 10.0);
    assert_eq!(float.rect.y(), 20.0);
    assert_eq!(float.rect.width(), 100.0);
    assert_eq!(float.rect.height(), 50.0);
  }

  #[test]
  fn test_float_info_left_constructor() {
    let float = FloatInfo::new_left(0.0, 0.0, 200.0, 100.0);
    assert_eq!(float.side, FloatSide::Left);
    assert_eq!(float.top(), 0.0);
    assert_eq!(float.bottom(), 100.0);
    assert_eq!(float.left_edge(), 0.0);
    assert_eq!(float.right_edge(), 200.0);
  }

  #[test]
  fn test_float_info_right_constructor() {
    let float = FloatInfo::new_right(500.0, 50.0, 300.0, 200.0);
    assert_eq!(float.side, FloatSide::Right);
    assert_eq!(float.top(), 50.0);
    assert_eq!(float.bottom(), 250.0);
    assert_eq!(float.left_edge(), 500.0);
    assert_eq!(float.right_edge(), 800.0);
  }

  #[test]
  fn test_float_info_overlaps_y_range() {
    let float = FloatInfo::new_left(0.0, 100.0, 200.0, 100.0); // y: 100-200

    // Overlapping ranges
    assert!(float.overlaps_y_range(50.0, 150.0)); // Partial overlap at start
    assert!(float.overlaps_y_range(150.0, 250.0)); // Partial overlap at end
    assert!(float.overlaps_y_range(120.0, 180.0)); // Fully inside
    assert!(float.overlaps_y_range(50.0, 250.0)); // Fully contains

    // Non-overlapping ranges
    assert!(!float.overlaps_y_range(0.0, 100.0)); // Just before
    assert!(!float.overlaps_y_range(200.0, 300.0)); // Just after
    assert!(!float.overlaps_y_range(0.0, 50.0)); // Well before
    assert!(!float.overlaps_y_range(250.0, 300.0)); // Well after
  }

  #[test]
  fn test_float_info_contains_y() {
    let float = FloatInfo::new_left(0.0, 100.0, 200.0, 100.0); // y: 100-200

    assert!(float.contains_y(100.0)); // Start edge (inclusive)
    assert!(float.contains_y(150.0)); // Middle
    assert!(float.contains_y(199.0)); // Near end
    assert!(!float.contains_y(99.0)); // Just before
    assert!(!float.contains_y(200.0)); // End edge (exclusive)
    assert!(!float.contains_y(250.0)); // Well after
  }

  // ==================== FloatContext Basic Tests ====================

  #[test]
  fn test_float_context_new() {
    let ctx = FloatContext::new(800.0);
    assert_eq!(ctx.containing_block_width(), 800.0);
    assert_eq!(ctx.current_y(), 0.0);
    assert!(ctx.is_empty());
    assert_eq!(ctx.float_count(), 0);
  }

  #[test]
  fn test_float_context_default() {
    let ctx = FloatContext::default();
    assert_eq!(ctx.containing_block_width(), 0.0);
    assert!(ctx.is_empty());
  }

  #[test]
  fn test_float_context_current_y() {
    let mut ctx = FloatContext::new(800.0);
    assert_eq!(ctx.current_y(), 0.0);

    ctx.set_current_y(100.0);
    assert_eq!(ctx.current_y(), 100.0);

    ctx.advance_y(50.0);
    assert_eq!(ctx.current_y(), 150.0);
  }

  #[test]
  fn test_add_single_left_float() {
    let mut ctx = FloatContext::new(800.0);
    ctx.add_float_at(FloatSide::Left, 0.0, 0.0, 200.0, 100.0);

    assert!(!ctx.is_empty());
    assert_eq!(ctx.float_count(), 1);
    assert_eq!(ctx.left_floats().len(), 1);
    assert_eq!(ctx.right_floats().len(), 0);
  }

  #[test]
  fn test_add_single_right_float() {
    let mut ctx = FloatContext::new(800.0);
    ctx.add_float_at(FloatSide::Right, 600.0, 0.0, 200.0, 100.0);

    assert!(!ctx.is_empty());
    assert_eq!(ctx.float_count(), 1);
    assert_eq!(ctx.left_floats().len(), 0);
    assert_eq!(ctx.right_floats().len(), 1);
  }

  #[test]
  fn test_add_multiple_floats() {
    let mut ctx = FloatContext::new(800.0);
    ctx.add_float_at(FloatSide::Left, 0.0, 0.0, 200.0, 100.0);
    ctx.add_float_at(FloatSide::Left, 200.0, 0.0, 100.0, 50.0);
    ctx.add_float_at(FloatSide::Right, 600.0, 0.0, 200.0, 150.0);

    assert_eq!(ctx.float_count(), 3);
    assert_eq!(ctx.left_floats().len(), 2);
    assert_eq!(ctx.right_floats().len(), 1);
  }

  // ==================== Available Width Tests ====================

  #[test]
  fn test_available_width_no_floats() {
    let ctx = FloatContext::new(800.0);
    let (left_edge, width) = ctx.available_width_at_y(0.0);
    assert_eq!(left_edge, 0.0);
    assert_eq!(width, 800.0);
  }

  #[test]
  fn test_available_width_with_left_float() {
    let mut ctx = FloatContext::new(800.0);
    ctx.add_float_at(FloatSide::Left, 0.0, 0.0, 200.0, 100.0);

    // Within float range
    let (left_edge, width) = ctx.available_width_at_y(50.0);
    assert_eq!(left_edge, 200.0);
    assert_eq!(width, 600.0);

    // Below float
    let (left_edge, width) = ctx.available_width_at_y(150.0);
    assert_eq!(left_edge, 0.0);
    assert_eq!(width, 800.0);
  }

  #[test]
  fn test_available_width_with_right_float() {
    let mut ctx = FloatContext::new(800.0);
    ctx.add_float_at(FloatSide::Right, 600.0, 0.0, 200.0, 100.0);

    // Within float range
    let (left_edge, width) = ctx.available_width_at_y(50.0);
    assert_eq!(left_edge, 0.0);
    assert_eq!(width, 600.0);

    // Below float
    let (left_edge, width) = ctx.available_width_at_y(150.0);
    assert_eq!(left_edge, 0.0);
    assert_eq!(width, 800.0);
  }

  #[test]
  fn test_available_width_with_both_floats() {
    let mut ctx = FloatContext::new(800.0);
    ctx.add_float_at(FloatSide::Left, 0.0, 0.0, 200.0, 100.0);
    ctx.add_float_at(FloatSide::Right, 600.0, 0.0, 200.0, 100.0);

    let (left_edge, width) = ctx.available_width_at_y(50.0);
    assert_eq!(left_edge, 200.0);
    assert_eq!(width, 400.0); // 800 - 200 - 200
  }

  #[test]
  fn test_available_width_in_range() {
    let mut ctx = FloatContext::new(800.0);
    ctx.add_float_at(FloatSide::Left, 0.0, 0.0, 200.0, 100.0);
    ctx.add_float_at(FloatSide::Left, 0.0, 50.0, 300.0, 100.0); // Wider, overlapping

    // Range that spans both floats
    let (left_edge, width) = ctx.available_width_in_range(0.0, 100.0);
    assert_eq!(left_edge, 300.0); // Most constrained
    assert_eq!(width, 500.0);
  }

  #[test]
  fn test_edges_at_y() {
    let mut ctx = FloatContext::new(800.0);
    ctx.add_float_at(FloatSide::Left, 0.0, 0.0, 200.0, 100.0);
    ctx.add_float_at(FloatSide::Right, 600.0, 0.0, 200.0, 100.0);

    assert_eq!(ctx.left_edge_at_y(50.0), 200.0);
    assert_eq!(ctx.right_edge_at_y(50.0), 600.0);
    assert_eq!(ctx.left_edge_at_y(150.0), 0.0);
    assert_eq!(ctx.right_edge_at_y(150.0), 800.0);
  }

  // ==================== Clearance Tests ====================

  #[test]
  fn test_clearance_no_floats() {
    let ctx = FloatContext::new(800.0);
    assert_eq!(ctx.compute_clearance(0.0, Clear::Left), 0.0);
    assert_eq!(ctx.compute_clearance(0.0, Clear::Right), 0.0);
    assert_eq!(ctx.compute_clearance(0.0, Clear::Both), 0.0);
    assert_eq!(ctx.compute_clearance(0.0, Clear::None), 0.0);
  }

  #[test]
  fn test_clearance_clear_left() {
    let mut ctx = FloatContext::new(800.0);
    ctx.add_float_at(FloatSide::Left, 0.0, 0.0, 200.0, 100.0);

    assert_eq!(ctx.compute_clearance(50.0, Clear::Left), 100.0);
    assert_eq!(ctx.compute_clearance(50.0, Clear::Right), 50.0); // No change
    assert_eq!(ctx.compute_clearance(150.0, Clear::Left), 150.0); // Already below
  }

  #[test]
  fn test_clearance_clear_right() {
    let mut ctx = FloatContext::new(800.0);
    ctx.add_float_at(FloatSide::Right, 600.0, 0.0, 200.0, 100.0);

    assert_eq!(ctx.compute_clearance(50.0, Clear::Right), 100.0);
    assert_eq!(ctx.compute_clearance(50.0, Clear::Left), 50.0); // No change
  }

  #[test]
  fn test_clearance_clear_both() {
    let mut ctx = FloatContext::new(800.0);
    ctx.add_float_at(FloatSide::Left, 0.0, 0.0, 200.0, 100.0);
    ctx.add_float_at(FloatSide::Right, 600.0, 0.0, 200.0, 150.0);

    // Should clear to bottom of tallest float
    assert_eq!(ctx.compute_clearance(50.0, Clear::Both), 150.0);
  }

  #[test]
  fn test_clearance_amount() {
    let mut ctx = FloatContext::new(800.0);
    ctx.add_float_at(FloatSide::Left, 0.0, 0.0, 200.0, 100.0);

    assert_eq!(ctx.clearance_amount(50.0, Clear::Left), 50.0);
    assert_eq!(ctx.clearance_amount(100.0, Clear::Left), 0.0);
    assert_eq!(ctx.clearance_amount(150.0, Clear::Left), 0.0);
  }

  // ==================== Float Positioning Tests ====================

  #[test]
  fn test_compute_float_position_empty() {
    let ctx = FloatContext::new(800.0);

    // Left float goes to left edge
    let (x, y) = ctx.compute_float_position(FloatSide::Left, 200.0, 100.0, 0.0);
    assert_eq!((x, y), (0.0, 0.0));

    // Right float goes to right edge
    let (x, y) = ctx.compute_float_position(FloatSide::Right, 200.0, 100.0, 0.0);
    assert_eq!((x, y), (600.0, 0.0));
  }

  #[test]
  fn test_compute_float_position_stacking_left() {
    let mut ctx = FloatContext::new(800.0);

    // First left float
    let (x, y) = ctx.compute_float_position(FloatSide::Left, 200.0, 100.0, 0.0);
    assert_eq!((x, y), (0.0, 0.0));
    ctx.add_float_at(FloatSide::Left, x, y, 200.0, 100.0);

    // Second left float stacks horizontally
    let (x, y) = ctx.compute_float_position(FloatSide::Left, 200.0, 100.0, 0.0);
    assert_eq!((x, y), (200.0, 0.0));
    ctx.add_float_at(FloatSide::Left, x, y, 200.0, 100.0);

    // Third left float continues stacking
    let (x, y) = ctx.compute_float_position(FloatSide::Left, 200.0, 100.0, 0.0);
    assert_eq!((x, y), (400.0, 0.0));
  }

  #[test]
  fn test_compute_float_position_stacking_right() {
    let mut ctx = FloatContext::new(800.0);

    // First right float
    let (x, y) = ctx.compute_float_position(FloatSide::Right, 200.0, 100.0, 0.0);
    assert_eq!((x, y), (600.0, 0.0));
    ctx.add_float_at(FloatSide::Right, x, y, 200.0, 100.0);

    // Second right float stacks to the left
    let (x, y) = ctx.compute_float_position(FloatSide::Right, 200.0, 100.0, 0.0);
    assert_eq!((x, y), (400.0, 0.0));
  }

  #[test]
  fn test_compute_float_position_drops_down() {
    let mut ctx = FloatContext::new(400.0);

    // First left float takes half the width
    ctx.add_float_at(FloatSide::Left, 0.0, 0.0, 200.0, 100.0);

    // Second left float that's too wide must drop down
    let (x, y) = ctx.compute_float_position(FloatSide::Left, 300.0, 50.0, 0.0);
    assert_eq!((x, y), (0.0, 100.0)); // Drops to y=100 where first float ends
  }

  #[test]
  fn test_compute_float_position_with_min_y() {
    let ctx = FloatContext::new(800.0);

    // Float respects min_y
    let (x, y) = ctx.compute_float_position(FloatSide::Left, 200.0, 100.0, 50.0);
    assert_eq!((x, y), (0.0, 50.0));
  }

  #[test]
  fn test_compute_float_position_considers_height_overlap() {
    let mut ctx = FloatContext::new(400.0);

    // Existing float sits lower in the flow.
    ctx.add_float_at(FloatSide::Left, 0.0, 50.0, 200.0, 150.0); // spans 50..200

    // New float would overlap vertically if kept at y=0; it should drop below.
    let (x, y) = ctx.compute_float_position(FloatSide::Left, 300.0, 80.0, 0.0);
    assert_eq!((x, y), (0.0, 200.0));
  }

  // ==================== Other Tests ====================

  #[test]
  fn test_floats_bottom() {
    let mut ctx = FloatContext::new(800.0);
    assert_eq!(ctx.floats_bottom(), 0.0);

    ctx.add_float_at(FloatSide::Left, 0.0, 0.0, 200.0, 100.0);
    assert_eq!(ctx.floats_bottom(), 100.0);

    ctx.add_float_at(FloatSide::Right, 600.0, 50.0, 200.0, 150.0);
    assert_eq!(ctx.floats_bottom(), 200.0); // 50 + 150
  }

  #[test]
  fn test_fits_at() {
    let mut ctx = FloatContext::new(800.0);
    ctx.add_float_at(FloatSide::Left, 0.0, 0.0, 200.0, 100.0);

    // Fits in remaining space
    assert!(ctx.fits_at(0.0, 500.0, 50.0));

    // Doesn't fit
    assert!(!ctx.fits_at(0.0, 700.0, 50.0));

    // Fits below float
    assert!(ctx.fits_at(100.0, 700.0, 50.0));
  }

  #[test]
  fn test_find_fit() {
    let mut ctx = FloatContext::new(800.0);
    ctx.add_float_at(FloatSide::Left, 0.0, 0.0, 600.0, 100.0);

    // Small box fits at y=0
    assert_eq!(ctx.find_fit(100.0, 50.0, 0.0), 0.0);

    // Large box must wait until y=100
    assert_eq!(ctx.find_fit(700.0, 50.0, 0.0), 100.0);
  }

  #[test]
  fn test_clear_all() {
    let mut ctx = FloatContext::new(800.0);
    ctx.add_float_at(FloatSide::Left, 0.0, 0.0, 200.0, 100.0);
    ctx.add_float_at(FloatSide::Right, 600.0, 0.0, 200.0, 100.0);

    assert_eq!(ctx.float_count(), 2);
    ctx.clear_all();
    assert!(ctx.is_empty());
    assert_eq!(ctx.float_count(), 0);
  }

  #[test]
  fn test_with_width() {
    let mut ctx = FloatContext::new(800.0);
    ctx.add_float_at(FloatSide::Left, 0.0, 0.0, 200.0, 100.0);
    ctx.set_current_y(50.0);

    let new_ctx = ctx.with_width(400.0);
    assert_eq!(new_ctx.containing_block_width(), 400.0);
    assert!(new_ctx.is_empty()); // Floats are not copied
    assert_eq!(new_ctx.current_y(), 0.0); // Y is reset
  }

  #[test]
  fn test_float_side_from_float() {
    assert_eq!(
      Option::<FloatSide>::from(Float::Left),
      Some(FloatSide::Left)
    );
    assert_eq!(
      Option::<FloatSide>::from(Float::Right),
      Some(FloatSide::Right)
    );
    assert_eq!(Option::<FloatSide>::from(Float::None), None);
  }

  // ==================== Complex Scenario Tests ====================

  #[test]
  fn test_staggered_floats() {
    let mut ctx = FloatContext::new(800.0);

    // Left float at top
    ctx.add_float_at(FloatSide::Left, 0.0, 0.0, 200.0, 100.0);

    // Right float starting lower
    ctx.add_float_at(FloatSide::Right, 600.0, 50.0, 200.0, 100.0);

    // At y=25: only left float affects width
    let (left_edge, width) = ctx.available_width_at_y(25.0);
    assert_eq!(left_edge, 200.0);
    assert_eq!(width, 600.0);

    // At y=75: both floats affect width
    let (left_edge, width) = ctx.available_width_at_y(75.0);
    assert_eq!(left_edge, 200.0);
    assert_eq!(width, 400.0);

    // At y=125: only right float affects width
    let (left_edge, width) = ctx.available_width_at_y(125.0);
    assert_eq!(left_edge, 0.0);
    assert_eq!(width, 600.0);
  }

  #[test]
  fn test_overlapping_left_floats() {
    let mut ctx = FloatContext::new(800.0);

    // Two left floats that overlap vertically but have different widths
    ctx.add_float_at(FloatSide::Left, 0.0, 0.0, 200.0, 100.0);
    ctx.add_float_at(FloatSide::Left, 0.0, 50.0, 300.0, 100.0);

    // At y=25: only first float
    assert_eq!(ctx.left_edge_at_y(25.0), 200.0);

    // At y=75: both floats, use rightmost edge
    assert_eq!(ctx.left_edge_at_y(75.0), 300.0);

    // At y=125: only second float
    assert_eq!(ctx.left_edge_at_y(125.0), 300.0);

    // At y=175: no floats
    assert_eq!(ctx.left_edge_at_y(175.0), 0.0);
  }

  #[test]
  fn test_nested_bfc_scenario() {
    // Outer BFC
    let mut outer = FloatContext::new(800.0);
    outer.add_float_at(FloatSide::Left, 0.0, 0.0, 200.0, 200.0);

    // Inner BFC would be created with remaining width
    let (left_edge, available) = outer.available_width_at_y(0.0);
    let inner = outer.with_width(available);

    assert_eq!(left_edge, 200.0);
    assert_eq!(inner.containing_block_width(), 600.0);
    assert!(inner.is_empty());
  }
}
