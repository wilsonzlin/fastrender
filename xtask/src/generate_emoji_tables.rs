use anyhow::{bail, Context, Result};
use clap::Args;
use std::cmp::Ordering;
use std::fs;
use std::path::{Path, PathBuf};

#[derive(Debug, Args)]
pub struct GenerateEmojiTablesArgs {
  /// Verify that the checked-in tables are up-to-date (do not modify files).
  #[arg(long)]
  pub check: bool,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
struct Range {
  start: u32,
  end: u32,
}

impl Range {
  fn new(start: u32, end: u32) -> Self {
    debug_assert!(start <= end);
    Self { start, end }
  }
}

pub fn run_generate_emoji_tables(args: GenerateEmojiTablesArgs) -> Result<()> {
  let repo_root = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
    .parent()
    .context("xtask should live one directory below the repo root")?
    .to_path_buf();
  let input = repo_root.join("tools/unicode/emoji-data.txt");
  let output = repo_root.join("src/text/emoji_tables.rs");
  let generated =
    generate_tables(&input).with_context(|| format!("generating tables from {input:?}"))?;

  if args.check {
    let existing = fs::read_to_string(&output).with_context(|| format!("reading {output:?}"))?;
    if existing != generated {
      bail!(
        "emoji tables out of date: re-run `cargo xtask generate-emoji-tables` (diff against {output:?})"
      );
    }
    return Ok(());
  }

  fs::write(&output, generated).with_context(|| format!("writing {output:?}"))?;
  Ok(())
}

fn generate_tables(path: &Path) -> Result<String> {
  let contents =
    fs::read_to_string(path).with_context(|| format!("reading emoji data from {path:?}"))?;
  let mut emoji = Vec::new();
  let mut emoji_presentation = Vec::new();
  let mut emoji_modifier = Vec::new();
  let mut emoji_modifier_base = Vec::new();
  let mut emoji_component = Vec::new();

  for (idx, raw_line) in contents.lines().enumerate() {
    let line_no = idx + 1;
    let line = raw_line.split('#').next().unwrap_or("").trim();
    if line.is_empty() {
      continue;
    }

    let (range_raw, property_raw) = line
      .split_once(';')
      .with_context(|| format!("invalid emoji-data line {line_no}: missing ';'"))?;
    let range_raw = range_raw.trim();
    let property_raw = property_raw.trim();

    let (start, end) = parse_range(range_raw).with_context(|| {
      format!("invalid emoji-data line {line_no}: unable to parse codepoint/range {range_raw:?}")
    })?;

    match property_raw {
      "Emoji" => emoji.push(Range::new(start, end)),
      "Emoji_Presentation" => emoji_presentation.push(Range::new(start, end)),
      "Emoji_Modifier" => emoji_modifier.push(Range::new(start, end)),
      "Emoji_Modifier_Base" => emoji_modifier_base.push(Range::new(start, end)),
      "Emoji_Component" => emoji_component.push(Range::new(start, end)),
      _ => {}
    }
  }

  emoji.sort_by(range_sort);
  emoji_presentation.sort_by(range_sort);
  emoji_modifier.sort_by(range_sort);
  emoji_modifier_base.sort_by(range_sort);
  emoji_component.sort_by(range_sort);

  merge_ranges(&mut emoji);
  merge_ranges(&mut emoji_presentation);
  merge_ranges(&mut emoji_modifier);
  merge_ranges(&mut emoji_modifier_base);
  merge_ranges(&mut emoji_component);

  let mut out = String::new();
  out.push_str("//! Unicode emoji property tables.\n");
  out.push_str("//!\n");
  out.push_str("//! This file is @generated by `cargo xtask generate-emoji-tables`.\n");
  out.push_str("//! Source: `tools/unicode/emoji-data.txt` (Unicode 15.1.0).\n");
  out.push_str("//!\n");
  out.push_str(
    "//! The renderer intentionally treats Emoji + Emoji_Component as \"emoji\" so that\n",
  );
  out.push_str("//! modifiers/joiners/variation selectors remain in the emoji fallback path.\n");
  out.push_str("\n");
  out.push_str("#[derive(Clone, Copy, Debug)]\n");
  out.push_str("pub(crate) struct EmojiRange {\n");
  out.push_str("  pub(crate) start: u32,\n");
  out.push_str("  pub(crate) end: u32,\n");
  out.push_str("}\n\n");

  write_ranges(&mut out, "EMOJI_RANGES", &emoji);
  write_ranges(&mut out, "EMOJI_PRESENTATION_RANGES", &emoji_presentation);
  write_ranges(&mut out, "EMOJI_MODIFIER_RANGES", &emoji_modifier);
  write_ranges(&mut out, "EMOJI_MODIFIER_BASE_RANGES", &emoji_modifier_base);
  write_ranges(&mut out, "EMOJI_COMPONENT_RANGES", &emoji_component);

  out.push_str("#[inline]\n");
  out.push_str("pub(crate) fn is_emoji(cp: u32) -> bool {\n");
  out.push_str("  in_ranges(cp, EMOJI_RANGES) || in_ranges(cp, EMOJI_COMPONENT_RANGES)\n");
  out.push_str("}\n\n");

  out.push_str("#[inline]\n");
  out.push_str("pub(crate) fn is_emoji_presentation(cp: u32) -> bool {\n");
  out.push_str("  in_ranges(cp, EMOJI_PRESENTATION_RANGES)\n");
  out.push_str("}\n\n");

  out.push_str("#[inline]\n");
  out.push_str("pub(crate) fn is_emoji_modifier(cp: u32) -> bool {\n");
  out.push_str("  in_ranges(cp, EMOJI_MODIFIER_RANGES)\n");
  out.push_str("}\n\n");

  out.push_str("#[inline]\n");
  out.push_str("pub(crate) fn is_emoji_modifier_base(cp: u32) -> bool {\n");
  out.push_str("  in_ranges(cp, EMOJI_MODIFIER_BASE_RANGES)\n");
  out.push_str("}\n\n");

  out.push_str("#[inline]\n");
  out.push_str("fn in_ranges(cp: u32, ranges: &[EmojiRange]) -> bool {\n");
  out.push_str("  let mut lo = 0usize;\n");
  out.push_str("  let mut hi = ranges.len();\n");
  out.push_str("  while lo < hi {\n");
  out.push_str("    let mid = (lo + hi) / 2;\n");
  out.push_str("    let range = ranges[mid];\n");
  out.push_str("    if cp < range.start {\n");
  out.push_str("      hi = mid;\n");
  out.push_str("    } else if cp > range.end {\n");
  out.push_str("      lo = mid + 1;\n");
  out.push_str("    } else {\n");
  out.push_str("      return true;\n");
  out.push_str("    }\n");
  out.push_str("  }\n");
  out.push_str("  false\n");
  out.push_str("}\n");

  Ok(out)
}

fn parse_range(raw: &str) -> Result<(u32, u32)> {
  if let Some((start, end)) = raw.split_once("..") {
    let start = u32::from_str_radix(start.trim(), 16)?;
    let end = u32::from_str_radix(end.trim(), 16)?;
    if start > end {
      bail!("range start > end: {raw:?}");
    }
    return Ok((start, end));
  }

  let value = u32::from_str_radix(raw.trim(), 16)?;
  Ok((value, value))
}

fn range_sort(a: &Range, b: &Range) -> Ordering {
  match a.start.cmp(&b.start) {
    Ordering::Equal => a.end.cmp(&b.end),
    other => other,
  }
}

fn merge_ranges(ranges: &mut Vec<Range>) {
  ranges.dedup();
  let mut out: Vec<Range> = Vec::with_capacity(ranges.len());
  for range in ranges.iter().copied() {
    if let Some(last) = out.last_mut() {
      if range.start <= last.end.saturating_add(1) {
        last.end = last.end.max(range.end);
        continue;
      }
    }
    out.push(range);
  }
  *ranges = out;
}

fn write_ranges(out: &mut String, name: &str, ranges: &[Range]) {
  out.push_str(&format!("pub(crate) const {name}: &[EmojiRange] = &[\n"));
  for range in ranges {
    out.push_str(&format!(
      "  EmojiRange {{ start: 0x{start:04X}, end: 0x{end:04X} }},\n",
      start = range.start,
      end = range.end
    ));
  }
  out.push_str("];\n\n");
}
