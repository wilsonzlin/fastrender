From 14c0d0c47be89feaf7eda53c39ad5081049bad5f Mon Sep 17 00:00:00 2001
From: Wilson Lin <code@wilsonl.in>
Date: Wed, 17 Dec 2025 15:03:00 -0500
Subject: [PATCH 1/3] Honor marker gaps for marker images in RTL

---
 src/layout/contexts/inline/mod.rs | 160 +++++++++++++++++++++++++++---
 1 file changed, 146 insertions(+), 14 deletions(-)

diff --git a/src/layout/contexts/inline/mod.rs b/src/layout/contexts/inline/mod.rs
index 63b1300..8ba4a96 100644
--- a/src/layout/contexts/inline/mod.rs
+++ b/src/layout/contexts/inline/mod.rs
@@ -435,19 +435,7 @@ impl InlineFormattingContext {
                     MarkerContent::Image(replaced_box) => {
                         let mut item =
                             self.create_replaced_item(child, replaced_box, available_width, available_height)?;
-                        let raw_gap = child
-                            .style
-                            .margin_right
-                            .as_ref()
-                            .map(|m| {
-                                resolve_length_for_width(*m, 0.0, &child.style, &self.font_context, self.viewport_size)
-                            })
-                            .unwrap_or(0.0);
-                        let gap = if raw_gap.abs() > f32::EPSILON {
-                            raw_gap
-                        } else {
-                            child.style.font_size * 0.5
-                        };
+                        let gap = marker_inline_gap(&child.style, &self.font_context, self.viewport_size);
                         item = item.as_marker(gap, child.style.list_style_position, child.style.direction);
                         current_items.push(InlineItem::Replaced(item));
                     }
@@ -2601,7 +2589,7 @@ impl InlineFormattingContext {
 
         for (i, positioned) in items.iter().enumerate() {
             let item_width = positioned.item.width();
-            let (block_pos, inline_pos) = if inline_vertical {
+            let (block_pos, mut inline_pos) = if inline_vertical {
                 let inline_pos = if rtl { cursor - item_width } else { cursor };
                 let block_pos =
                     line.baseline + positioned.baseline_offset - positioned.item.baseline_metrics().baseline_offset;
@@ -2613,6 +2601,15 @@ impl InlineFormattingContext {
                 (block_pos, inline_pos)
             };
 
+            if rtl {
+                let marker_gap = match &positioned.item {
+                    InlineItem::Text(t) if t.is_marker => (item_width - (t.advance + t.paint_offset.abs())).max(0.0),
+                    InlineItem::Replaced(r) if r.is_marker => (item_width - r.width).max(0.0),
+                    _ => 0.0,
+                };
+                inline_pos += marker_gap;
+            }
+
             let fragment = self.create_item_fragment_oriented(&positioned.item, block_pos, inline_pos, inline_vertical);
             if log_line {
                 let metrics = positioned.item.baseline_metrics();
@@ -6899,6 +6896,141 @@ mod tests {
         assert!(x > 17.0 && x < 19.5, "expected text after marker gap, got {}", x);
     }
 
+    #[test]
+    fn marker_image_inside_uses_inline_end_margin_in_vertical_ltr() {
+        let ifc = InlineFormattingContext::new();
+        let mut root_style = ComputedStyle::default();
+        root_style.writing_mode = WritingMode::VerticalRl;
+        let root_style = Arc::new(root_style);
+
+        let mut marker_style = (*root_style).clone();
+        marker_style.list_style_position = ListStylePosition::Inside;
+        marker_style.margin_bottom = Some(Length::px(20.0));
+        let marker_style = Arc::new(marker_style);
+        let marker_style_for_gap = marker_style.clone();
+
+        let text_style = Arc::new((*root_style).clone());
+
+        let marker = BoxNode::new_marker(
+            marker_style,
+            MarkerContent::Image(ReplacedBox {
+                replaced_type: ReplacedType::Image {
+                    src: String::new(),
+                    alt: None,
+                    sizes: None,
+                    srcset: Vec::new(),
+                },
+                intrinsic_size: Some(Size::new(10.0, 10.0)),
+                aspect_ratio: Some(1.0),
+            }),
+        );
+        let text = BoxNode::new_text(text_style, "content".to_string());
+        let root = BoxNode::new_block(root_style, FormattingContextType::Block, vec![marker, text]);
+        let constraints = LayoutConstraints::definite(200.0, 200.0);
+
+        let fragment = ifc.layout(&root, &constraints).unwrap();
+        let line = fragment.children.first().expect("line fragment");
+        let marker_fragment = line
+            .children
+            .iter()
+            .find(|child| matches!(child.content, FragmentContent::Replaced { .. }))
+            .expect("marker fragment");
+        let text_fragment = line
+            .children
+            .iter()
+            .find(|child| matches!(child.content, FragmentContent::Text { .. }))
+            .expect("text fragment");
+
+        let gap = if marker_fragment.bounds.y() <= text_fragment.bounds.y() {
+            text_fragment.bounds.y() - (marker_fragment.bounds.y() + marker_fragment.bounds.height())
+        } else {
+            marker_fragment.bounds.y() - (text_fragment.bounds.y() + text_fragment.bounds.height())
+        };
+        let gap_x = if marker_fragment.bounds.x() <= text_fragment.bounds.x() {
+            text_fragment.bounds.x() - (marker_fragment.bounds.x() + marker_fragment.bounds.width())
+        } else {
+            marker_fragment.bounds.x() - (text_fragment.bounds.x() + text_fragment.bounds.width())
+        };
+        let expected_gap = marker_inline_gap(&marker_style_for_gap, &ifc.font_context, ifc.viewport_size);
+        assert!(
+            (gap - expected_gap).abs() < 0.5,
+            "expected inline-end margin gap of {}, got {} (gap_x={}, marker={:?}, text={:?})",
+            expected_gap,
+            gap,
+            gap_x,
+            marker_fragment.bounds,
+            text_fragment.bounds
+        );
+    }
+
+    #[test]
+    fn marker_image_inside_uses_inline_end_margin_in_vertical_rtl() {
+        let ifc = InlineFormattingContext::new();
+        let mut root_style = ComputedStyle::default();
+        root_style.writing_mode = WritingMode::VerticalRl;
+        root_style.direction = crate::style::types::Direction::Rtl;
+        let root_style = Arc::new(root_style);
+
+        let mut marker_style = (*root_style).clone();
+        marker_style.list_style_position = ListStylePosition::Inside;
+        marker_style.margin_top = Some(Length::px(14.0));
+        let marker_style = Arc::new(marker_style);
+        let marker_style_for_gap = marker_style.clone();
+
+        let text_style = Arc::new((*root_style).clone());
+
+        let marker = BoxNode::new_marker(
+            marker_style,
+            MarkerContent::Image(ReplacedBox {
+                replaced_type: ReplacedType::Image {
+                    src: String::new(),
+                    alt: None,
+                    sizes: None,
+                    srcset: Vec::new(),
+                },
+                intrinsic_size: Some(Size::new(10.0, 10.0)),
+                aspect_ratio: Some(1.0),
+            }),
+        );
+        let text = BoxNode::new_text(text_style, "content".to_string());
+        let root = BoxNode::new_block(root_style, FormattingContextType::Block, vec![marker, text]);
+        let constraints = LayoutConstraints::definite(200.0, 200.0);
+
+        let fragment = ifc.layout(&root, &constraints).unwrap();
+        let line = fragment.children.first().expect("line fragment");
+        let marker_fragment = line
+            .children
+            .iter()
+            .find(|child| matches!(child.content, FragmentContent::Replaced { .. }))
+            .expect("marker fragment");
+        let text_fragment = line
+            .children
+            .iter()
+            .find(|child| matches!(child.content, FragmentContent::Text { .. }))
+            .expect("text fragment");
+
+        let gap = if marker_fragment.bounds.y() <= text_fragment.bounds.y() {
+            text_fragment.bounds.y() - (marker_fragment.bounds.y() + marker_fragment.bounds.height())
+        } else {
+            marker_fragment.bounds.y() - (text_fragment.bounds.y() + text_fragment.bounds.height())
+        };
+        let gap_x = if marker_fragment.bounds.x() <= text_fragment.bounds.x() {
+            text_fragment.bounds.x() - (marker_fragment.bounds.x() + marker_fragment.bounds.width())
+        } else {
+            marker_fragment.bounds.x() - (text_fragment.bounds.x() + text_fragment.bounds.width())
+        };
+        let expected_gap = marker_inline_gap(&marker_style_for_gap, &ifc.font_context, ifc.viewport_size);
+        assert!(
+            (gap - expected_gap).abs() < 0.5,
+            "expected inline-end margin gap of {}, got {} (gap_x={}, marker={:?}, text={:?})",
+            expected_gap,
+            gap,
+            gap_x,
+            marker_fragment.bounds,
+            text_fragment.bounds
+        );
+    }
+
     #[test]
     fn marker_outside_positions_inline_start_in_vertical_rl() {
         let ifc = InlineFormattingContext::new();
-- 
2.43.0

