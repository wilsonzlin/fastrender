From f8881363cd2db594b47aebec80cdd05773250b50 Mon Sep 17 00:00:00 2001
From: Wilson Lin <code@wilsonl.in>
Date: Wed, 17 Dec 2025 14:45:39 -0500
Subject: [PATCH 01/18] Delegate PositionedLayout absolute helper

---
 scratchpad.md                     |   1 +
 src/layout/contexts/positioned.rs | 265 ++----------------------------
 tests/layout/test_positioned.rs   |  29 +++-
 3 files changed, 38 insertions(+), 257 deletions(-)

diff --git a/scratchpad.md b/scratchpad.md
index 5fb495d..0d22083 100644
--- a/scratchpad.md
+++ b/scratchpad.md
@@ -1,5 +1,6 @@
 # Scratchpad â€“ rendering engine session notes
 Idle; no current tasks. Available for new tasks.
+- PositionedLayout absolute helper now delegates to AbsoluteLayout for spec-accurate shrink-to-fit/auto-margin handling; positioned layout tests updated (shrink-to-fit expectation) and an auto-margin centering regression added. `cargo test --quiet test_absolute_position_left_right_shrink_to_fit` and `cargo test --quiet absolute_position_auto_margins_center_between_insets` pass (existing display_list_renderer warnings still present during test compile).
 - Added aria-label/aria-labelledby no-op regressions: aria attributes do not change display/visibility (`aria_label_does_not_change_display`, `aria_labelledby_does_not_hide`).
 - Added display-list regression for `color-mix()` backgrounds: srgb/srgb-linear mixes and currentColor participation render to the resolved color (`paint_color_mix_display_list_test.rs`).
 - Added counter-style fallback regressions for out-of-range lower-greek/lower-armenian counters falling back to decimal markers.
diff --git a/src/layout/contexts/positioned.rs b/src/layout/contexts/positioned.rs
index 23cbb67..dea6b7d 100644
--- a/src/layout/contexts/positioned.rs
+++ b/src/layout/contexts/positioned.rs
@@ -40,10 +40,9 @@
 //! ```
 
 use crate::geometry::{Point, Rect, Size};
+use crate::layout::absolute_positioning::{AbsoluteLayout, AbsoluteLayoutInput};
 use crate::layout::formatting_context::LayoutError;
-use crate::layout::utils::{
-    content_size_from_box_sizing, resolve_length_with_percentage, resolve_offset_for_positioned,
-};
+use crate::layout::utils::resolve_offset_for_positioned;
 use crate::style::computed::PositionedStyle;
 use crate::style::position::Position;
 use crate::text::font_loader::FontContext;
@@ -331,263 +330,23 @@ impl PositionedLayout {
         Point::new(offset_x, offset_y)
     }
 
-    /// Resolves a length-or-auto for width/height using percentage, viewport, or font bases.
+    /// Computes the position and size for an absolutely positioned element.
     ///
-    /// Percentages use the provided base, viewport units use the containing viewport, and
-    /// font-relative units use the element/root font sizes. Returns `None` for `auto`.
-    fn resolve_length_for_size(
-        &self,
-        value: &crate::style::values::LengthOrAuto,
-        percentage_base: Option<f32>,
-        viewport: Size,
-        style: &PositionedStyle,
-    ) -> Option<f32> {
-        match value {
-            crate::style::values::LengthOrAuto::Auto => None,
-            crate::style::values::LengthOrAuto::Length(length) => resolve_length_with_percentage(
-                *length,
-                percentage_base,
-                viewport,
-                style.font_size,
-                style.root_font_size,
-            ),
-        }
-    }
-
-    /// Computes the position and size for an absolutely positioned element
-    ///
-    /// Absolutely positioned elements are removed from normal flow and positioned
-    /// relative to their containing block.
-    ///
-    /// # CSS 2.1 Section 10.3.7 (width) and 10.6.4 (height)
-    ///
-    /// The constraint equation for horizontal positioning:
-    /// `left + margin-left + border-left + padding-left + width +
-    ///  padding-right + border-right + margin-right + right = containing block width`
-    ///
-    /// # Arguments
-    ///
-    /// * `style` - The computed style
-    /// * `containing_block` - The containing block (padding box of positioned ancestor)
-    /// * `intrinsic_size` - The intrinsic size if width/height are auto
-    ///
-    /// # Returns
-    ///
-    /// Tuple of (position, size) in containing block coordinates
+    /// This delegates to the shared AbsoluteLayout engine so consumers of
+    /// PositionedLayout get the same shrink-to-fit and auto-margin behavior
+    /// used by the main layout pipeline. The static position defaults to the
+    /// origin because this helper does not yet receive the box's normal-flow
+    /// position.
     pub fn compute_absolute_position(
         &self,
         style: &PositionedStyle,
         containing_block: &ContainingBlock,
         intrinsic_size: Size,
     ) -> Result<(Point, Size), LayoutError> {
-        let cb_width = containing_block.width();
-        let cb_height = containing_block.height();
-        let viewport = containing_block.viewport_size();
-        let inline_base = containing_block.inline_percentage_base();
-        let block_base = containing_block.block_percentage_base();
-
-        // Compute horizontal position and width
-        let (x, width) =
-            self.compute_absolute_horizontal(style, cb_width, inline_base, viewport, intrinsic_size.width)?;
-
-        // Compute vertical position and height
-        let (y, height) =
-            self.compute_absolute_vertical(style, cb_height, block_base, viewport, intrinsic_size.height)?;
-
-        let mut width = width;
-        let mut height = height;
-        if let crate::style::types::AspectRatio::Ratio(ratio) = style.aspect_ratio {
-            if ratio > 0.0 {
-                let width_auto = matches!(style.width, crate::style::values::LengthOrAuto::Auto);
-                let height_auto = matches!(style.height, crate::style::values::LengthOrAuto::Auto);
-                if width_auto && !height_auto {
-                    width = height * ratio;
-                } else if height_auto && !width_auto {
-                    height = width / ratio;
-                } else if width_auto && height_auto {
-                    if intrinsic_size.width > 0.0 {
-                        width = intrinsic_size.width;
-                        height = width / ratio;
-                    } else if intrinsic_size.height > 0.0 {
-                        height = intrinsic_size.height;
-                        width = height * ratio;
-                    }
-                }
-            }
-        }
-
-        // Position is relative to containing block origin
-        let position = Point::new(containing_block.origin().x + x, containing_block.origin().y + y);
-
-        Ok((position, Size::new(width, height)))
-    }
-
-    /// Computes horizontal position and width for absolutely positioned element
-    ///
-    /// Handles the constraint equation and various combinations of
-    /// specified/auto values for left, right, width.
-    fn compute_absolute_horizontal(
-        &self,
-        style: &PositionedStyle,
-        cb_width: f32,
-        inline_base: Option<f32>,
-        viewport: Size,
-        intrinsic_width: f32,
-    ) -> Result<(f32, f32), LayoutError> {
-        let left = resolve_offset_for_positioned(&style.left, inline_base, viewport, style, &self.font_context);
-        let right = resolve_offset_for_positioned(&style.right, inline_base, viewport, style, &self.font_context);
-
-        // Get margin values (auto margins = 0 for absolute positioning unless overconstrained)
-        let margin_left = style.margin.left;
-        let margin_right = style.margin.right;
-
-        // Get padding and border (never auto)
-        let padding_left = style.padding.left;
-        let padding_right = style.padding.right;
-        let border_left = style.border_width.left;
-        let border_right = style.border_width.right;
-
-        let total_horizontal = padding_left + padding_right + border_left + border_right;
-
-        // Get width value (may be auto)
-        let specified_width = self
-            .resolve_length_for_size(&style.width, inline_base, viewport, style)
-            .map(|w| content_size_from_box_sizing(w, total_horizontal, style.box_sizing));
-
-        match (left, specified_width, right) {
-            // Case 1: All three specified (overconstrained) - ignore right for LTR
-            (Some(l), Some(w), Some(_r)) => {
-                let x = l + margin_left + border_left + padding_left;
-                Ok((x, w))
-            }
-
-            // Case 2: left and width specified, right is auto
-            (Some(l), Some(w), None) => {
-                let x = l + margin_left + border_left + padding_left;
-                Ok((x, w))
-            }
-
-            // Case 3: right and width specified, left is auto
-            (None, Some(w), Some(r)) => {
-                let x = cb_width - r - margin_right - border_right - padding_right - w;
-                Ok((x, w))
-            }
-
-            // Case 4: left and right specified, width is auto
-            (Some(l), None, Some(r)) => {
-                let available = cb_width - l - r - margin_left - margin_right - total_horizontal;
-                let width = available.max(0.0);
-                let x = l + margin_left + border_left + padding_left;
-                Ok((x, width))
-            }
-
-            // Case 5: Only left specified
-            (Some(l), None, None) => {
-                let x = l + margin_left + border_left + padding_left;
-                Ok((x, intrinsic_width))
-            }
-
-            // Case 6: Only right specified
-            (None, None, Some(r)) => {
-                let x = cb_width - r - margin_right - border_right - padding_right - intrinsic_width;
-                Ok((x, intrinsic_width))
-            }
-
-            // Case 7: Only width specified - use static position
-            (None, Some(w), None) => {
-                // Static position - left edge aligns with where it would be in normal flow
-                let x = margin_left + border_left + padding_left;
-                Ok((x, w))
-            }
-
-            // Case 8: None specified - use static position and intrinsic width
-            (None, None, None) => {
-                let x = margin_left + border_left + padding_left;
-                Ok((x, intrinsic_width))
-            }
-        }
-    }
-
-    /// Computes vertical position and height for absolutely positioned element
-    fn compute_absolute_vertical(
-        &self,
-        style: &PositionedStyle,
-        cb_height: f32,
-        block_base: Option<f32>,
-        viewport: Size,
-        intrinsic_height: f32,
-    ) -> Result<(f32, f32), LayoutError> {
-        let top = resolve_offset_for_positioned(&style.top, block_base, viewport, style, &self.font_context);
-        let bottom = resolve_offset_for_positioned(&style.bottom, block_base, viewport, style, &self.font_context);
-
-        // Get margin values
-        let margin_top = style.margin.top;
-        let margin_bottom = style.margin.bottom;
-
-        // Get padding and border
-        let padding_top = style.padding.top;
-        let padding_bottom = style.padding.bottom;
-        let border_top = style.border_width.top;
-        let border_bottom = style.border_width.bottom;
-
-        let total_vertical = padding_top + padding_bottom + border_top + border_bottom;
-
-        // Get height value (may be auto)
-        let specified_height = self
-            .resolve_length_for_size(&style.height, block_base, viewport, style)
-            .map(|h| content_size_from_box_sizing(h, total_vertical, style.box_sizing));
-
-        match (top, specified_height, bottom) {
-            // All three specified (overconstrained) - ignore bottom
-            (Some(t), Some(h), Some(_b)) => {
-                let y = t + margin_top + border_top + padding_top;
-                Ok((y, h))
-            }
-
-            // top and height specified
-            (Some(t), Some(h), None) => {
-                let y = t + margin_top + border_top + padding_top;
-                Ok((y, h))
-            }
-
-            // bottom and height specified
-            (None, Some(h), Some(b)) => {
-                let y = cb_height - b - margin_bottom - border_bottom - padding_bottom - h;
-                Ok((y, h))
-            }
-
-            // top and bottom specified, height is auto
-            (Some(t), None, Some(b)) => {
-                let available = cb_height - t - b - margin_top - margin_bottom - total_vertical;
-                let height = available.max(0.0);
-                let y = t + margin_top + border_top + padding_top;
-                Ok((y, height))
-            }
-
-            // Only top specified
-            (Some(t), None, None) => {
-                let y = t + margin_top + border_top + padding_top;
-                Ok((y, intrinsic_height))
-            }
-
-            // Only bottom specified
-            (None, None, Some(b)) => {
-                let y = cb_height - b - margin_bottom - border_bottom - padding_bottom - intrinsic_height;
-                Ok((y, intrinsic_height))
-            }
-
-            // Only height specified - use static position
-            (None, Some(h), None) => {
-                let y = margin_top + border_top + padding_top;
-                Ok((y, h))
-            }
-
-            // None specified - use static position and intrinsic height
-            (None, None, None) => {
-                let y = margin_top + border_top + padding_top;
-                Ok((y, intrinsic_height))
-            }
-        }
+        let abs = AbsoluteLayout::with_font_context(self.font_context.clone());
+        let input = AbsoluteLayoutInput::new(style.clone(), intrinsic_size, Point::ZERO);
+        let result = abs.layout_absolute(&input, containing_block)?;
+        Ok((result.position, result.size))
     }
 
     /// Determines the containing block for a positioned element
diff --git a/tests/layout/test_positioned.rs b/tests/layout/test_positioned.rs
index 67bce5f..772802a 100644
--- a/tests/layout/test_positioned.rs
+++ b/tests/layout/test_positioned.rs
@@ -370,23 +370,23 @@ fn test_absolute_position_right_bottom() {
 }
 
 #[test]
-fn test_absolute_position_left_right_stretch() {
+fn test_absolute_position_left_right_shrink_to_fit() {
     let layout = PositionedLayout::new();
 
     let mut style = default_style();
     style.position = Position::Absolute;
     style.left = LengthOrAuto::px(100.0);
     style.right = LengthOrAuto::px(100.0);
-    // width is auto - should stretch
+    // width is auto - should shrink-to-fit the intrinsic size between insets
 
     let cb = create_containing_block(500.0, 300.0);
     let intrinsic = Size::new(50.0, 50.0);
 
     let (pos, size) = layout.compute_absolute_position(&style, &cb, intrinsic).unwrap();
 
-    // Width = 500 - 100 - 100 = 300
+    // Width shrink-to-fits to the intrinsic 50px
     assert_eq!(pos.x, 100.0);
-    assert_eq!(size.width, 300.0);
+    assert_eq!(size.width, 50.0);
 }
 
 #[test]
@@ -497,6 +497,27 @@ fn test_absolute_position_overconstrained_ignores_right() {
     assert_eq!(size.width, 100.0);
 }
 
+#[test]
+fn absolute_position_auto_margins_center_between_insets() {
+    let layout = PositionedLayout::new();
+
+    let mut style = default_style();
+    style.position = Position::Absolute;
+    style.left = LengthOrAuto::px(0.0);
+    style.right = LengthOrAuto::px(0.0);
+    style.width = LengthOrAuto::px(100.0);
+    style.margin_left_auto = true;
+    style.margin_right_auto = true;
+
+    let cb = create_containing_block(300.0, 200.0);
+    let intrinsic = Size::new(10.0, 10.0);
+
+    let (pos, size) = layout.compute_absolute_position(&style, &cb, intrinsic).unwrap();
+
+    assert!((pos.x - 100.0).abs() < 1e-3, "x was {}", pos.x);
+    assert_eq!(size.width, 100.0);
+}
+
 #[test]
 fn test_absolute_position_with_containing_block_offset() {
     let layout = PositionedLayout::new();
-- 
2.43.0

